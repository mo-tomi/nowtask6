# nowtask Android App - Complete Source Code

**Generated Date**: 2025-10-21 04:32:07
**Format**: Markdown
**Purpose**: Complete codebase documentation

---

## Table of Contents

1. [HTML](#html)
2. [CSS Modules](#css-modules)
3. [JavaScript Modules](#javascript-modules)

---

## HTML

### index.html

```html
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>nowtask</title>

  <!-- PWA設定 -->
  <link rel="manifest" href="./manifest.json">
  <meta name="theme-color" content="#000000">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="nowtask">
  <link rel="apple-touch-icon" href="./icon-192.png">
  <meta name="description" content="シンプルなモノクロデザインのタスク管理アプリ">

  <!-- 基本スタイル（必須） -->
  <link rel="stylesheet" href="css/style-01-reset-base.css?v=48">
  <link rel="stylesheet" href="css/style-02-header.css?v=48">
  <link rel="stylesheet" href="css/style-03-main-content.css?v=48">

  <!-- ゲージ & タスク -->
  <link rel="stylesheet" href="css/style-04-gauge-24hour.css?v=48">
  <link rel="stylesheet" href="css/style-05-task-list.css?v=48">
  <link rel="stylesheet" href="css/style-06-animations.css?v=48">
  <link rel="stylesheet" href="css/style-07-empty-state.css?v=48">
  <link rel="stylesheet" href="css/style-08-past-tasks.css?v=48">
  <link rel="stylesheet" href="css/style-09-completed.css?v=48">

  <!-- UI要素 -->
  <link rel="stylesheet" href="css/style-10-fab.css?v=48">
  <link rel="stylesheet" href="css/style-11-modals.css?v=48">
  <link rel="stylesheet" href="css/style-12-forms.css?v=48">
  <link rel="stylesheet" href="css/style-13-timer.css?v=48">
  <link rel="stylesheet" href="css/style-14-buttons.css?v=48">
  <link rel="stylesheet" href="css/style-15-subtasks.css?v=48">

  <!-- 高度な機能 -->
  <link rel="stylesheet" href="css/style-16-search-filter.css?v=48">
  <link rel="stylesheet" href="css/style-17-analytics.css?v=48">
  <link rel="stylesheet" href="css/style-18-calendar.css?v=48">
  <link rel="stylesheet" href="css/style-19-accessibility.css?v=48">

  <!-- レスポンシブ（最後に読み込み） -->
  <link rel="stylesheet" href="css/style-20-responsive-01.css?v=48">
  <link rel="stylesheet" href="css/style-21-responsive-02.css?v=48">
  <link rel="stylesheet" href="css/style-22-responsive-03.css?v=48">
  <link rel="stylesheet" href="css/style-23-responsive-04.css?v=48">
  <link rel="stylesheet" href="css/style-24-responsive-05.css?v=48">
  <link rel="stylesheet" href="css/style-25-responsive-06.css?v=48">
  <link rel="stylesheet" href="css/style-26-responsive-07.css?v=48">
  <link rel="stylesheet" href="css/style-27-responsive-08.css?v=48">

  <!-- HTML2Canvas for sharing screenshots -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
</head>
<body>
  <!-- 旧ヘッダー（後方互換性のため保持） -->
  <header class="header" id="old-header">
    <div class="header-content">
      <h1 class="app-title" id="app-title-btn" style="cursor: pointer;">nowtask</h1>
      <div class="header-actions">
        <button class="calendar-icon-btn" id="calendar-icon-btn" aria-label="カレンダー" title="カレンダー">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="16" y1="2" x2="16" y2="6"></line>
            <line x1="8" y1="2" x2="8" y2="6"></line>
            <line x1="3" y1="10" x2="21" y2="10"></line>
          </svg>
        </button>
        <button class="login-icon-btn" id="login-icon-btn" aria-label="アカウント" title="アカウント">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
            <circle cx="12" cy="7" r="4"></circle>
          </svg>
        </button>
        <button class="settings-icon-btn" id="settings-icon-btn" aria-label="設定" title="設定">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
          </svg>
        </button>
        <button class="header-menu-btn" id="header-menu-btn" aria-label="メニュー" title="メニュー">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="1"></circle>
            <circle cx="12" cy="5" r="1"></circle>
            <circle cx="12" cy="19" r="1"></circle>
          </svg>
        </button>
      </div>
    </div>
  </header>

  <!-- 新ヘッダー（新しいデザイン） -->
  <header class="new-header" id="new-header">
    <div class="new-header-content">
      <h1 class="new-app-title">nowtask</h1>
      <div class="new-header-actions">
        <button class="new-header-btn" id="new-calendar-btn" aria-label="カレンダー" title="カレンダー">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="16" y1="2" x2="16" y2="6"></line>
            <line x1="8" y1="2" x2="8" y2="6"></line>
            <line x1="3" y1="10" x2="21" y2="10"></line>
          </svg>
        </button>
        <button class="new-header-btn" id="new-account-btn" aria-label="アカウント" title="アカウント">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
            <circle cx="12" cy="7" r="4"></circle>
          </svg>
        </button>
        <button class="new-header-btn" id="new-settings-btn" aria-label="設定" title="設定">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
          </svg>
        </button>
        <button class="new-header-btn" id="new-menu-btn" aria-label="メニュー" title="メニュー">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="1"></circle>
            <circle cx="12" cy="5" r="1"></circle>
            <circle cx="12" cy="19" r="1"></circle>
          </svg>
        </button>
      </div>
    </div>
  </header>

  <!-- メインコンテンツエリア -->
  <main class="main-content">
    <!-- タスクタブ -->
    <div class="tab-content active" id="tasks-tab">
      <!-- 旧24時間ゲージ（後方互換性のため保持） -->
      <section class="time-gauge" id="old-time-gauge-container" role="region" aria-label="24時間ゲージ">
        <header class="time-gauge-header">
          <button class="gauge-nav-btn" id="gauge-prev-btn" aria-label="前の日に移動" title="前の日に移動" type="button">‹</button>
          <div class="gauge-header-center">
            <div class="gauge-date-label" id="gauge-date-label">今日</div>
            <time class="current-time" id="current-time" datetime="00:00" aria-live="polite">00:00</time>
            <div class="remaining-tasks" id="remaining-tasks" role="status" aria-live="polite" aria-atomic="true">残り: 0時間</div>
          </div>
          <button class="gauge-nav-btn" id="gauge-next-btn" aria-label="次の日に移動" title="次の日に移動" type="button">›</button>
        </header>
        <div class="gauge-wrapper" id="old-gauge-wrapper">
          <div class="gauge-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" tabindex="0">
            <div class="time-gauge-elapsed" id="time-gauge-elapsed" aria-hidden="true"></div>
            <div class="time-gauge-scheduled" id="time-gauge-scheduled" aria-hidden="true"></div>
            <div class="time-gauge-free" id="time-gauge-free" aria-hidden="true"></div>
            <div class="time-marker" id="time-marker" aria-label="現在時刻マーカー" role="img"></div>
          </div>
          <div class="time-labels" role="list" aria-label="時間表記">
            <span class="time-label" role="listitem" aria-label="0時">0:00</span>
            <span class="time-label" role="listitem" aria-label="6時">6:00</span>
            <span class="time-label" role="listitem" aria-label="12時">12:00</span>
            <span class="time-label" role="listitem" aria-label="18時">18:00</span>
            <span class="time-label" role="listitem" aria-label="24時">24:00</span>
          </div>
        </div>
      </section>

      <!-- 新24時間ゲージ（新しいデザイン） -->
      <section class="new-time-gauge" id="new-time-gauge-container" role="region" aria-label="24時間ゲージ">
        <header class="new-gauge-header">
          <button class="new-gauge-nav-btn" id="new-gauge-prev-btn" aria-label="前の日に移動" title="前の日に移動" type="button">‹</button>
          <div class="new-gauge-header-center">
            <div class="new-gauge-date-label" id="new-gauge-date-label">今日</div>
            <time class="new-current-time" id="new-current-time-display" datetime="00:00" aria-live="polite">00:00</time>
            <div class="new-remaining-tasks" id="new-remaining-tasks" role="status" aria-live="polite" aria-atomic="true">残り: 0時間</div>
          </div>
          <button class="new-gauge-nav-btn" id="new-gauge-next-btn" aria-label="次の日に移動" title="次の日に移動" type="button">›</button>
        </header>
        <div class="new-gauge-wrapper" id="new-gauge-wrapper">
          <div class="new-gauge-bar" aria-label="24時間ゲージ" role="list">
            <!-- 24個のステップはJavaScriptで生成 -->
          </div>
          <div class="new-time-labels">
            <!-- 時間表記はJavaScriptで生成 -->
          </div>
        </div>
      </section>

      <!-- 旧複数選択ボタン（後方互換性のため保持） -->
      <div class="bulk-select-button-container" id="old-bulk-select-button-container">
        <button type="button" class="bulk-select-toggle-btn" id="bulk-select-toggle-btn">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;">
            <polyline points="9 11 12 14 22 4"></polyline>
            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
          </svg>
          複数選択
        </button>
      </div>

      <!-- 新複数選択ボタン（新しいデザイン） -->
      <div class="new-bulk-select-button-container" id="new-bulk-select-button-container">
        <button type="button" class="new-bulk-select-toggle-btn" id="new-bulk-select-toggle-btn">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="9 11 12 14 22 4"></polyline>
            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
          </svg>
          複数選択
        </button>
      </div>

      <div id="tasks-list" class="task-list"></div>
      <div class="empty-state" id="tasks-empty">
        <svg width="80" height="80" viewBox="0 0 100 100" fill="none" stroke="#d0d0d0" stroke-width="2" style="margin: 0 auto 24px;">
          <circle cx="50" cy="50" r="35" stroke-dasharray="5,5"></circle>
          <path d="M50 30 L50 50 L65 50" stroke-linecap="round"></path>
        </svg>
        <p style="font-size: 18px; font-weight: 500; margin-bottom: 12px; color: #9e9e9e;">タスクがありません</p>
        <small style="font-size: 14px; color: #bdbdbd;">+ ボタンからタスクを追加しましょう</small>
      </div>

      <!-- 完了済みセクション -->
      <div class="completed-section" id="completed-section">
        <button class="completed-toggle" id="completed-toggle">
          <span class="toggle-icon">▶</span>
          <span class="toggle-text">完了済み</span>
          <span class="completed-count" id="completed-count">(0)</span>
        </button>
        <div class="completed-content" id="completed-content">
          <div id="completed-list" class="task-list"></div>
        </div>
      </div>
    </div>
  </main>

  <!-- 複数選択ツールバー -->
  <div class="bulk-actions-toolbar" id="bulk-actions-toolbar" style="display: none;">
    <div class="bulk-toolbar-top">
      <button type="button" class="bulk-cancel-btn" id="bulk-cancel-btn">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
      <span class="bulk-selection-count" id="bulk-selection-count">0件選択中</span>
      <button type="button" class="btn-link" id="bulk-select-all-btn">すべて選択</button>
    </div>
    <div class="bulk-toolbar-actions">
      <button type="button" class="bulk-action-btn-with-label" id="bulk-complete-btn">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
        <span>完了</span>
      </button>
      <button type="button" class="bulk-action-btn-with-label" id="bulk-date-btn">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        <span>日付変更</span>
      </button>
      <button type="button" class="bulk-action-btn-with-label" id="bulk-priority-btn">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"></path>
        </svg>
        <span>優先度変更</span>
      </button>
      <button type="button" class="bulk-action-btn-with-label bulk-delete-btn" id="bulk-delete-btn">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="3 6 5 6 21 6"></polyline>
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        </svg>
        <span>削除</span>
      </button>
    </div>
  </div>

  <!-- 新規タスク作成FAB -->
  <button class="fab" id="create-task-btn" aria-label="新規タスク作成">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <line x1="12" y1="5" x2="12" y2="19"></line>
      <line x1="5" y1="12" x2="19" y2="12"></line>
    </svg>
  </button>

  <!-- タスク作成/編集モーダル -->
  <div class="modal" id="task-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="modal-title">新規タスク</h2>
        <button class="close-btn" id="close-modal-btn">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="task-title">タスク名<span class="required">*</span></label>
          <div style="display: flex; gap: 8px; margin-bottom: 8px;">
            <input type="text" id="task-title" maxlength="100" placeholder="タスク名を入力" autocomplete="off" style="flex: 1;">
            <button type="button" class="btn btn-secondary" id="template-select-btn" style="padding: 10px 16px; white-space: nowrap;">テンプレートから選択</button>
          </div>
          <div class="char-count"><span id="title-char-count">0</span>/100</div>
        </div>
        <div class="form-group">
          <label for="task-memo">メモ</label>
          <textarea id="task-memo" rows="4" placeholder="メモを入力（任意）"></textarea>
        </div>
        <div class="form-group">
          <label for="task-due-date">期日</label>
          <input type="date" id="task-due-date">
        </div>
        <div class="form-group">
          <label for="task-duration">所要時間</label>
          <select id="task-duration">
            <option value="">時間未設定</option>
            <option value="15">15分</option>
            <option value="30">30分</option>
            <option value="45">45分</option>
            <option value="60">1時間</option>
            <option value="90">1時間30分</option>
            <option value="120">2時間</option>
            <option value="150">2時間30分</option>
            <option value="180">3時間</option>
            <option value="210">3時間30分</option>
            <option value="240">4時間</option>
            <option value="270">4時間30分</option>
            <option value="300">5時間</option>
            <option value="330">5時間30分</option>
            <option value="360">6時間</option>
            <option value="390">6時間30分</option>
            <option value="420">7時間</option>
            <option value="450">7時間30分</option>
            <option value="480">8時間</option>
            <option value="510">8時間30分</option>
            <option value="540">9時間</option>
            <option value="570">9時間30分</option>
            <option value="600">10時間</option>
            <option value="630">10時間30分</option>
            <option value="660">11時間</option>
            <option value="690">11時間30分</option>
            <option value="720">12時間</option>
          </select>
        </div>
        <div class="form-group">
          <label for="task-start-time">開始時刻</label>
          <input type="time" id="task-start-time">
        </div>
        <div class="form-group">
          <label for="task-end-time">終了時刻</label>
          <input type="time" id="task-end-time">
        </div>
        <div class="form-group">
          <label>
            <input type="checkbox" id="task-urgent">
            緊急
          </label>
        </div>
        <div class="form-group">
          <label for="task-priority">優先度</label>
          <select id="task-priority">
            <option value="">未設定</option>
            <option value="high">高</option>
            <option value="medium">中</option>
            <option value="low">低</option>
          </select>
        </div>
        <div class="form-group timer-section" id="timer-section" style="display: none;">
          <label>経過時間</label>
          <div class="timer-display">
            <span id="timer-display">00:00:00</span>
            <button type="button" class="timer-btn" id="timer-toggle-btn">開始</button>
          </div>
        </div>
        <div class="form-group subtasks-section" id="subtasks-section" style="display: none;">
          <label>サブタスク</label>
          <div id="subtasks-list" class="subtasks-list"></div>
          <button type="button" class="btn-add-subtask" id="add-subtask-btn">+ サブタスクを追加</button>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="cancel-btn">キャンセル</button>
        <button class="btn btn-danger" id="delete-btn" style="display: none;">削除</button>
        <button class="btn btn-primary" id="save-btn">保存</button>
      </div>
    </div>
  </div>

  <!-- 確認ダイアログ -->
  <div class="modal" id="confirm-modal">
    <div class="modal-content confirm-modal">
      <div class="modal-header">
        <h2 id="confirm-title">確認</h2>
      </div>
      <div class="modal-body">
        <p id="confirm-message"></p>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="confirm-cancel-btn">キャンセル</button>
        <button class="btn btn-primary" id="confirm-ok-btn">OK</button>
      </div>
    </div>
  </div>

  <!-- 設定モーダル -->
  <div class="modal" id="settings-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>設定</h2>
        <button class="close-btn" id="close-settings-btn">&times;</button>
      </div>
      <div class="modal-body" id="settings-modal-body">
        <!-- 設定内容はJavaScriptで生成 -->
        <div id="routines-list"></div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="settings-cancel-btn">キャンセル</button>
        <button class="btn btn-primary" id="settings-save-btn">保存</button>
      </div>
    </div>
  </div>

  <!-- カレンダーモーダル -->
  <div class="modal" id="calendar-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>カレンダー</h2>
        <button class="close-btn" id="close-calendar-btn">&times;</button>
      </div>
      <div class="modal-body" id="calendar-modal-body">
        <!-- カレンダー内容はJavaScriptで生成 -->
      </div>
    </div>
  </div>

  <!-- 検索・フィルターモーダル -->
  <div class="modal" id="search-filter-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>検索・フィルター</h2>
        <button class="close-btn" id="close-search-filter-btn">&times;</button>
      </div>
      <div class="modal-body" id="search-filter-modal-body">
        <!-- 検索・フィルター内容はJavaScriptで生成 -->
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="search-filter-clear-all-btn">すべてクリア</button>
        <button class="btn btn-primary" id="search-filter-apply-btn">適用</button>
      </div>
    </div>
  </div>

  <!-- 時間オーバー警告モーダル -->
  <div class="modal" id="time-overload-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>時間オーバー警告</h2>
        <button class="close-btn" id="close-overload-btn">&times;</button>
      </div>
      <div class="modal-body">
        <div class="overload-warning">
          <p class="overload-message">
            今日のタスクの予定時間が24時間を超えています。<br>
            <strong id="overload-amount"></strong>分がオーバーしています。
          </p>
          <p class="overload-description">
            以下のタスクの時間を調整するか、別の日に移動することをおすすめします。
          </p>
        </div>
        <div id="overload-tasks-list" class="overload-tasks-list">
          <!-- タスクリストはJavaScriptで生成 -->
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="overload-cancel-btn">閉じる</button>
        <button class="btn btn-primary" id="overload-adjust-btn">タスクを調整する</button>
      </div>
    </div>
  </div>

  <!-- ログインモーダル -->
  <div class="modal" id="login-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="login-modal-title">ログイン</h2>
        <button class="close-btn" id="close-login-btn">&times;</button>
      </div>
      <div class="modal-body">
        <!-- ログインフォーム（未ログイン時に表示） -->
        <div id="login-form-section">
          <p class="settings-description">Googleアカウントでログインすると、データをクラウドに保存できます。</p>
          <button type="button" class="btn btn-primary" id="google-login-btn" style="width: 100%; margin-top: 16px;">
            <svg width="18" height="18" viewBox="0 0 48 48" style="vertical-align: middle; margin-right: 8px;">
              <path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path>
              <path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"></path>
              <path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path>
              <path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path>
              <path fill="none" d="M0 0h48v48H0z"></path>
            </svg>
            Googleでログイン
          </button>
          <button type="button" class="btn btn-secondary" id="continue-anonymous-btn" style="width: 100%; margin-top: 12px;">匿名のまま使い続ける</button>
        </div>

        <!-- アカウント情報（ログイン時に表示） -->
        <div id="account-info-section" style="display: none;">
          <div class="form-group">
            <label>表示名</label>
            <p id="account-display-name" style="font-size: 16px; font-weight: 500;">-</p>
          </div>
          <div class="form-group">
            <label>メールアドレス</label>
            <p id="account-email" style="font-size: 14px; color: #616161;">-</p>
          </div>
          <div class="form-group">
            <label>ステータス</label>
            <p id="account-status" style="font-size: 14px; color: #4CAF50;">-</p>
          </div>
          <button type="button" class="btn btn-danger" id="logout-btn" style="width: 100%; margin-top: 16px;">ログアウト</button>
        </div>

        <!-- ユーザー情報表示エリア -->
        <div id="current-user-info" style="margin-top: 20px; padding: 16px; background: #f5f5f5; border-radius: 8px;">
          <p style="font-size: 14px; color: #616161; margin: 0;">現在のユーザー: <span id="current-user-id" style="font-weight: 500;">-</span></p>
        </div>
      </div>
    </div>
  </div>

  <!-- 分析モーダル -->
  <div class="modal" id="analytics-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>分析</h2>
        <button class="close-btn" id="close-analytics-btn">&times;</button>
      </div>
      <div class="modal-body">
        <!-- タスク実績ランキング -->
        <section class="analytics-section">
          <h3>タスク実績ランキング（過去30日）</h3>
          <div id="task-ranking-list" class="ranking-list">
            <!-- JavaScriptで生成 -->
          </div>
        </section>

        <!-- 空き時間統計 -->
        <section class="analytics-section" style="margin-top: 24px;">
          <h3>今週の空き時間</h3>
          <div id="free-time-stats" class="free-time-stats">
            <!-- JavaScriptで生成 -->
          </div>
        </section>

        <!-- 年間空き時間 -->
        <section class="analytics-section" style="margin-top: 24px;">
          <h3>年間空き時間</h3>
          <div id="yearly-free-time" class="yearly-stats">
            <!-- JavaScriptで生成 -->
          </div>
        </section>
      </div>
    </div>
  </div>

  <!-- テンプレートモーダル -->
  <div class="modal" id="template-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>テンプレート選択</h2>
        <button class="close-btn" id="close-template-btn">&times;</button>
      </div>
      <div class="modal-body">
        <p class="settings-description">よく使うタスクをテンプレートとして保存できます。</p>

        <!-- テンプレート一覧 -->
        <div id="templates-list" class="templates-list">
          <!-- JavaScriptで生成 -->
        </div>

        <!-- テンプレート追加フォーム（最初は非表示） -->
        <div id="template-input-form" style="display: none; margin-top: 16px; padding: 16px; background: #f5f5f5; border-radius: 8px;">
          <div class="form-group">
            <label for="template-name">テンプレート名</label>
            <input type="text" id="template-name" class="form-control" placeholder="例: 朝のランニング">
          </div>
          <div class="form-group">
            <label for="template-duration">所要時間（分）</label>
            <input type="number" id="template-duration" class="form-control" placeholder="30">
          </div>
          <div class="form-group">
            <label for="template-start-time">開始時刻</label>
            <input type="time" id="template-start-time" class="form-control">
          </div>
          <div style="display: flex; gap: 8px; margin-top: 12px;">
            <button class="btn btn-secondary" id="template-cancel-btn">キャンセル</button>
            <button class="btn btn-primary" id="template-save-btn">保存</button>
          </div>
        </div>

        <!-- 追加ボタン -->
        <button class="btn btn-primary" id="add-template-btn" style="width: 100%; margin-top: 16px;">+ テンプレート追加</button>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="template-close-btn">閉じる</button>
      </div>
    </div>
  </div>

  <script src="js/core.js?v=48"></script>
  <script src="js/firebase-init.js?v=48"></script>
  <script src="js/auth.js?v=48"></script>
  <script src="js/tasks.js?v=48"></script>
  <script src="js/render.js?v=48"></script>
  <script src="js/modals.js?v=48"></script>
  <script src="js/gauge.js?v=48"></script>
  <script src="js/analytics.js?v=48"></script>
  <script src="js/overload.js?v=48"></script>
  <script src="js/share.js?v=48"></script>
  <script src="js/calendar.js?v=48"></script>
  <script src="js/templates.js?v=48"></script>
  <script src="js/events.js?v=48"></script>
  <script src="js/ui-main.js?v=48"></script>
  <script src="js/search-filter.js?v=46"></script>
  <script src="js/input-experience.js?v=48"></script>
  <script src="js/accessibility.js?v=49"></script>
  <script src="js/feedback.js?v=49"></script>
  <script src="js/help.js?v=49"></script>
  <script src="js/performance.js?v=50"></script>
  <script src="js/animations.js?v=51"></script>
  <script src="js/customization.js?v=52"></script>
</body>
</html>
```

---

## CSS Modules

### style-01-reset-base.css

```css
/* ========================================
   リセット & 基本設定
   ======================================== */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f5f5f5;
  color: #333;
  line-height: 1.6;
}

```

### style-02-header.css

```css
/* ========================================
   ヘッダー
   ======================================== */
.header {
  background-color: #000000;
  color: white;
  padding: 12px 16px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  position: sticky;
  top: 0;
  z-index: 100;
  transition: transform 0.3s ease;
}

.header-hidden {
  transform: translateY(-100%);
}

.header-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0px;
  max-width: 100%;
}

.app-title {
  font-size: 24px;
  font-weight: 500;
  letter-spacing: 0.5px;
  margin: 0;
  flex-shrink: 0;
  line-height: 36px;
}

.header-actions {
  display: flex;
  gap: 4px;
}

/* タスク管理ツールバー */
.task-toolbar-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 16px;
  background: #f5f5f5;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  color: #333;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.task-toolbar-btn:hover {
  background: #eeeeee;
  border-color: #bdbdbd;
}

.task-toolbar-btn:active {
  background: #e0e0e0;
}

.task-toolbar-btn svg {
  flex-shrink: 0;
}

.settings-icon-btn,
.share-icon-btn,
.calendar-icon-btn,
.analytics-icon-btn,
.login-icon-btn,
.select-mode-icon-btn,
.header-menu-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: white;
  transition: all 0.2s ease;
}

.settings-icon-btn:hover,
.share-icon-btn:hover,
.calendar-icon-btn:hover,
.analytics-icon-btn:hover,
.login-icon-btn:hover,
.select-mode-icon-btn:hover,
.header-menu-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: scale(1.05);
}

.settings-icon-btn:active,
.share-icon-btn:active,
.calendar-icon-btn:active,
.analytics-icon-btn:active,
.login-icon-btn:active,
.select-mode-icon-btn:active,
.header-menu-btn:active {
  transform: scale(0.95);
}

.quick-add {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 0;
  background: #000000;
  padding: 12px 16px;
  box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.15);
  z-index: 99;
  transition: transform 0.3s ease, opacity 0.3s ease;
  transform: translateY(0);
  opacity: 1;
}

.quick-add.hidden {
  transform: translateY(100%);
  opacity: 0;
  pointer-events: none;
}

.quick-input-row {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
}

.quick-input-wrapper {
  position: relative;
  display: flex;
  align-items: center;
  background: white;
  border-radius: 4px;
  padding-right: 4px;
  flex: 1;
}

.quick-add #quick-add-input {
  flex: 1;
  padding: 12px 14px;
  padding-right: 80px;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  outline: none;
  transition: box-shadow 0.2s ease;
  width: 100%;
  background: white;
  color: #333;
}

.quick-add #quick-add-input:focus {
  box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
}

.quick-add #quick-add-input::placeholder {
  color: #999;
}

.quick-input-actions {
  position: absolute;
  right: 4px;
  display: flex;
  gap: 4px;
  align-items: center;
  z-index: 10;
}

.quick-action-btn {
  background: #666666;
  border: 1px solid #555555;
  border-radius: 4px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: white;
  transition: all 0.2s ease;
  padding: 0;
  flex-shrink: 0;
}

.quick-action-btn:hover {
  background: #555555;
  transform: scale(1.05);
}

.quick-action-btn:active {
  transform: scale(0.95);
}

.quick-action-btn.has-date {
  background: #000000;
  color: white;
  border-color: #000000;
}

.quick-datetime-panel {
  position: relative;
  background: white;
  border-radius: 8px;
  padding: 16px;
  margin-top: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.quick-datetime-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  font-size: 14px;
  font-weight: 600;
  color: #333;
}

.quick-datetime-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
}

.quick-datetime-row:last-of-type {
  margin-bottom: 0;
}

.quick-datetime-row label {
  font-size: 13px;
  font-weight: 500;
  color: #333;
  min-width: 50px;
}

.quick-date-input-inline,
.quick-duration-input-inline {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  font-size: 14px;
  background-color: white;
  color: #333;
  outline: none;
  transition: border-color 0.2s ease;
}

.quick-date-input-inline:focus,
.quick-duration-input-inline:focus {
  border-color: #000000;
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
}

.quick-datetime-close {
  position: absolute;
  top: 8px;
  right: 8px;
  background: none;
  border: none;
  font-size: 24px;
  color: #757575;
  cursor: pointer;
  line-height: 1;
  padding: 4px;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  transition: background-color 0.2s ease;
}

.quick-datetime-close:hover {
  background-color: rgba(0, 0, 0, 0.05);
  color: #333;
}

.quick-history-tags {
  display: none;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 8px;
  margin-bottom: 4px;
  padding: 4px 0;
  max-height: 120px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.quick-history-tags::-webkit-scrollbar {
  width: 4px;
}

.quick-history-tags::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
}

.quick-history-tags::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.3);
  border-radius: 2px;
}

.quick-history-tags::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.5);
}

.quick-history-tag {
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid rgba(255, 255, 255, 0.5);
  border-radius: 16px;
  padding: 6px 12px;
  font-size: 13px;
  color: #000000;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.quick-history-tag:hover {
  background: white;
  border-color: white;
  transform: scale(1.05);
}

/* 絞り込みボタン */
.filter-btn {
  padding: 6px 12px;
  border: 1px solid #e0e0e0;
  border-radius: 16px;
  background: white;
  color: #616161;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.filter-btn:hover {
  background: #f5f5f5;
  border-color: #000000;
}

.filter-btn.active {
  background: #000000;
  color: white;
  border-color: #000000;
}

.filter-btn-clear {
  padding: 6px 12px;
  border: 1px solid #e0e0e0;
  border-radius: 16px;
  background: white;
  color: #d32f2f;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.filter-btn-clear:hover {
  background: #ffebee;
  border-color: #d32f2f;
}

/* タブナビゲーションのスタイルは廃止済み */

```

### style-03-main-content.css

```css
/* ========================================
   メインコンテンツ
   ======================================== */
.main-content {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px 16px 120px;
}

.tab-content {
  display: none;
}

.tab-content.active {
  display: block;
}

```

### style-04-gauge-24hour.css

```css
/* ========================================
   24時間ゲージ - 100点シンプル・モノクロデザイン
   ======================================== */

/* コンテナ - シンプルでクリーンなデザイン */
.time-gauge-container {
  position: relative;
  background: #ffffff;
  border-radius: 12px;
  padding: 16px 24px;
  margin-bottom: 16px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
  border: 1px solid #e0e0e0;
  transition: box-shadow 0.3s ease, border-left-color 0.5s ease;
}

.time-gauge-container:hover {
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
}

/* タスク密度による境界線の変化（モノクロ） - スムーズな色遷移 */
.time-gauge-container.density-green {
  border-left: 4px solid #000000;
  transition: border-left-color 0.5s ease;
}

.time-gauge-container.density-yellow {
  border-left: 4px solid #666666;
  transition: border-left-color 0.5s ease;
}

.time-gauge-container.density-red {
  border-left: 4px solid #333333;
  transition: border-left-color 0.5s ease;
}

/* ヘッダーセクション */
.time-gauge-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 14px;
  gap: 12px;
}

/* ナビゲーションボタン - シンプルデザイン */
.gauge-nav-btn {
  background: #f5f5f5;
  border: 1px solid #d0d0d0;
  border-radius: 6px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 20px;
  color: #333333;
  transition: all 0.2s ease;
  flex-shrink: 0;
}

.gauge-nav-btn:hover {
  background: #e0e0e0;
  border-color: #999999;
  color: #000000;
}

.gauge-nav-btn:active {
  background: #d0d0d0;
}

.gauge-nav-btn:focus {
  outline: 2px solid #000000;
  outline-offset: 2px;
}

/* 中央コンテンツエリア */
.gauge-header-center {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex: 1;
  gap: 12px;
  flex-wrap: wrap;
}

/* 日付ラベル */
.gauge-date-label {
  font-size: 14px;
  font-weight: 600;
  color: #333333;
  text-align: center;
  width: 100%;
  margin-bottom: 4px;
}

/* 現在時刻表示 - シンプルでクリア */
.current-time {
  font-size: 28px;
  font-weight: 700;
  color: #000000;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
  letter-spacing: 1.5px;
  line-height: 1;
}

/* ラベル */
.gauge-label {
  font-size: 14px;
  color: #666666;
  font-weight: 500;
  flex: 1;
  text-align: center;
  min-width: 120px;
}

/* 残りタスク表示 - モノクロシンプル */
.remaining-tasks {
  font-size: 13px;
  font-weight: 600;
  padding: 6px 12px;
  border-radius: 6px;
  transition: background-color 0.2s ease;
  letter-spacing: 0.3px;
  background: #f5f5f5;
  color: #333333;
  border: 1px solid #d0d0d0;
}

/* 密度に応じた表示の変化（モノクロ） */
.density-green .remaining-tasks {
  background: #000000;
  color: #ffffff;
  border-color: #000000;
}

.density-yellow .remaining-tasks {
  background: #666666;
  color: #ffffff;
  border-color: #666666;
}

.density-red .remaining-tasks {
  background: #333333;
  color: #ffffff;
  border-color: #333333;
}

/* ゲージバー本体 - シンプル・クリーン */
.time-gauge {
  position: relative;
  height: 16px;
  border-radius: 4px;
  overflow: visible;
  margin-bottom: 8px;
  background: #f8f8f8;
  border: 1px solid #e0e0e0;
}

.time-gauge-bg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #f8f8f8;
  border-radius: 6px;
}

/* グリッドライン - シンプル */
.time-gauge-gridlines {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 0;
}

.time-gauge-gridlines .gridline {
  position: absolute;
  top: 0;
  height: 100%;
  width: 1px;
  background: #d0d0d0;
  opacity: 0.6;
}

/* 経過時間バー - モノクロ */
.time-gauge-elapsed {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  background: #cccccc;
  transition: width 0.5s ease;
  z-index: 1;
  border-radius: 6px 0 0 6px;
}

/* 密度に応じた経過時間バーの色変化（モノクロ） */
.density-green .time-gauge-elapsed {
  background: #e0e0e0;
}

.density-yellow .time-gauge-elapsed {
  background: #d0d0d0;
}

.density-red .time-gauge-elapsed {
  background: #c0c0c0;
}

/* スケジュール済みバー - 明確な表示 */
.time-gauge-scheduled {
  position: absolute;
  top: 0;
  height: 100%;
  background: #666666;
  border-left: 2px solid #333333;
  border-right: 2px solid #333333;
  transition: all 0.3s ease;
  z-index: 2;
}

/* 自由時間バー - 白で明示 */
.time-gauge-free {
  position: absolute;
  top: 0;
  height: 100%;
  background: #ffffff;
  transition: all 0.3s ease;
  z-index: 1;
  border-radius: 0 6px 6px 0;
  border-right: 2px solid #e0e0e0;
}

/* 現在時刻マーカー - シンプルで明確 */
.time-marker {
  position: absolute;
  top: 0;
  width: 2px;
  height: 100%;
  background: #000000;
  transition: left 0.5s ease;
  z-index: 3;
  border-radius: 1px;
}

/* 現在時刻マーカーの三角形を削除してシンプルに */
.time-marker::before,
.time-marker::after {
  display: none;
}

/* ラベル - シンプルで読みやすい */
.time-gauge-labels {
  display: flex;
  justify-content: space-between;
  font-size: 10px;
  color: #999999;
  margin-top: 4px;
  padding: 0 2px;
  font-weight: 400;
  letter-spacing: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
}

.time-gauge-labels span {
  position: relative;
  padding: 4px 0;
}

.time-gauge-labels span:nth-child(3) {
  font-weight: 700;
  color: #000000;
}

.gauge-legend {
  display: flex;
  justify-content: center;
  gap: 24px;
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid #e0e0e0;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: #616161;
}

.legend-color {
  width: 24px;
  height: 12px;
  border-radius: 4px;
}

.legend-color.elapsed {
  background: linear-gradient(90deg, #000000 0%, #333333 100%);
}

.legend-color.scheduled {
  background: rgba(255, 152, 0, 0.3);
  border: 2px solid #333333;
}

.legend-color.marker {
  background: #000000;
  width: 3px;
  height: 16px;
  border-radius: 2px;
  box-shadow: 0 0 4px rgba(244, 67, 54, 0.5);
}

```

### style-05-task-list.css

```css
/* ========================================
   タスクリスト
   ======================================== */
.task-list {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* 日付セパレーター */
.date-separator {
  display: flex;
  align-items: center;
  gap: 16px;
  margin: 16px 0 12px;
}

.date-separator:first-child {
  margin-top: 0;
}

/* 昨日以前のタスクコンテンツの直後の日付セパレーター（今日の日付）の上余白をなくす */
.past-tasks-content + .date-separator {
  margin-top: 0;
}

.date-separator-line {
  flex: 1;
  height: 1px;
  background: linear-gradient(90deg, transparent, #e0e0e0, transparent);
}

.date-separator-label {
  font-size: 14px;
  font-weight: 600;
  color: #000000;
  padding: 4px 16px;
  background: #f5f5f5;
  border-radius: 16px;
  white-space: nowrap;
  letter-spacing: 0.5px;
}

/* 明日のタスク追加ボタン */
.add-tomorrow-task-btn {
  width: 100%;
  padding: 12px 16px;
  margin: 12px 0 24px 0;
  background: rgba(0, 0, 0, 0.05);
  border: 1px dashed #000000;
  border-radius: 8px;
  color: #000000;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  text-align: center;
}

.add-tomorrow-task-btn:hover {
  background: rgba(0, 0, 0, 0.1);
  border-style: solid;
  transform: translateY(-2px);
}

.add-tomorrow-task-btn:active {
  transform: translateY(0);
}

.task-item {
  background: white;
  border-radius: 12px;
  padding: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  display: flex;
  align-items: flex-start;
  gap: 16px;
  animation: taskFadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.task-item:not(.subtask):not(.level-1):not(.level-2):not(.level-3):not(.level-4) {
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
}

.task-item:not(.subtask):not(.level-1):not(.level-2):not(.level-3):not(.level-4):hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
}

@keyframes taskFadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.task-item.subtask {
  border-left: 3px solid #000000;
  background-color: #fafafa;
}

/* 階層別インデント */
.task-item.level-1 {
  margin-left: 24px;
  border-left: 3px solid #333333;
  background: #fafafa;
}

.task-item.level-2 {
  margin-left: 48px;
  border-left: 2px solid #666666;
  background: #f5f5f5;
}

.task-item.level-3 {
  margin-left: 72px;
  border-left: 1px solid #999999;
  background: #f0f0f0;
}

.task-item.level-4 {
  margin-left: 96px;
  border-left: 1px solid #cccccc;
  background: #eeeeee;
}

.task-item:hover {
  transform: translateY(-3px) scale(1.01);
}

.task-item.dragging {
  opacity: 0.6;
  transform: scale(1.05);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
  cursor: grabbing;
  z-index: 1000;
}

/* スワイプジェスチャー */
.task-item.swiping {
  position: relative;
  transition: transform 0.2s ease-out;
  z-index: 10;
}

.task-item.swiping-right {
  transform: translateX(80px);
}

.task-item.swiping-right::before {
  content: '✓';
  position: absolute;
  left: 16px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 32px;
  font-weight: bold;
  color: #4CAF50;
  opacity: 0;
  animation: swipeIconFadeIn 0.2s ease-out forwards;
}

.task-item.swiping-left {
  transform: translateX(-80px);
}

.task-item.swiping-left::before {
  content: '×';
  position: absolute;
  right: 16px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 32px;
  font-weight: bold;
  color: #F44336;
  opacity: 0;
  animation: swipeIconFadeIn 0.2s ease-out forwards;
}

@keyframes swipeIconFadeIn {
  from {
    opacity: 0;
    transform: translateY(-50%) scale(0.5);
  }
  to {
    opacity: 1;
    transform: translateY(-50%) scale(1);
  }
}

/* スワイプ後のリセットアニメーション */
.task-item.swipe-reset {
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  transform: translateX(0);
}

```

### style-06-animations.css

```css
/* ========================================
   タスク追加・削除アニメーション
   ======================================== */
.task-item-enter {
  animation: taskFadeIn 0.3s ease;
}

.task-item-exit {
  animation: taskFadeOut 0.3s ease forwards;
}

@keyframes taskFadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

@keyframes taskFadeOut {
  from {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
  to {
    opacity: 0;
    transform: translateY(-10px) scale(0.95);
  }
}

.task-item.tutorial {
  border-left: 4px solid #333333;
}

.task-checkbox {
  margin-top: 2px;
  width: 20px;
  height: 20px;
  cursor: pointer;
  flex-shrink: 0;
  transition: transform 0.2s ease;
}

.task-checkbox:hover {
  transform: scale(1.15);
  background: rgba(0, 0, 0, 0.04);
  border-radius: 50%;
  padding: 4px;
}

.task-checkbox:checked {
  animation: checkBounce 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}

@keyframes checkBounce {
  0% { transform: scale(1); }
  50% { transform: scale(1.3); }
  100% { transform: scale(1); }
}

.task-content {
  flex: 1;
  min-width: 0;
}

.task-title {
  font-size: 16px;
  font-weight: 500;
  line-height: 1.4;
  margin-bottom: 8px;
  word-wrap: break-word;
}

.task-item.completed .task-title {
  text-decoration: line-through;
  color: #9e9e9e;
  opacity: 0.6;
  transition: opacity 0.3s ease, color 0.3s ease;
  animation: strikethrough 0.4s ease-in-out;
}

@keyframes strikethrough {
  from {
    text-decoration-color: transparent;
  }
  to {
    text-decoration-color: #9e9e9e;
  }
}

.task-meta {
  font-size: 12px;
  color: #757575;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 12px;
}

.task-memo {
  color: #616161;
  font-size: 14px;
  margin-top: 8px;
  white-space: pre-wrap;
  word-wrap: break-word;
  line-height: 1.6;
}

.task-due-date {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: rgba(0, 0, 0, 0.04);
  border-radius: 6px;
}

.task-due-date.overdue {
  color: #000000;
  font-weight: 500;
  background: rgba(0, 0, 0, 0.1);
}

.task-timer {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: rgba(0, 0, 0, 0.04);
  border-radius: 6px;
}

.task-timer.running {
  color: #000000;
  font-weight: 500;
  background: rgba(0, 0, 0, 0.1);
}

.task-duration {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: rgba(0, 0, 0, 0.04);
  border-radius: 6px;
}

.task-urgent-label {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: #ff0000;
  color: white;
  font-weight: 600;
  border-radius: 6px;
  font-size: 11px;
}

.task-priority-label {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 11px;
  font-weight: 500;
}

.task-priority-label.high {
  background: #ffebee;
  color: #c62828;
}

.task-priority-label.medium {
  background: #fff3e0;
  color: #e65100;
}

.task-priority-label.low {
  background: #e8f5e9;
  color: #2e7d32;
}

.task-actions {
  display: flex;
  gap: 8px;
  flex-shrink: 0;
}

.icon-btn {
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px;
  color: #757575;
  transition: color 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.icon-btn:hover {
  color: #000000;
}

.icon-btn.delete:hover {
  color: #000000;
}

.icon-btn.restore:hover {
  color: #000000;
}

.task-card-actions {
  display: flex;
  gap: 4px;
  align-items: center;
  flex-shrink: 0;
}

.add-subtask-icon {
  background: rgba(0, 0, 0, 0.1);
  border: 1px solid #000000;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #000000;
  font-size: 18px;
  font-weight: bold;
  transition: all 0.2s ease;
  flex-shrink: 0;
  padding: 0;
  line-height: 1;
}

.add-subtask-icon:hover {
  background: rgba(0, 0, 0, 0.2);
  transform: scale(1.1);
}

.add-subtask-icon:active {
  transform: scale(0.95);
}

.task-menu-btn {
  background: rgba(0, 0, 0, 0.05);
  border: none;
  border-radius: 50%;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #757575;
  font-size: 20px;
  font-weight: bold;
  transition: all 0.2s ease;
  flex-shrink: 0;
  padding: 0;
  line-height: 1;
}

.task-menu-btn:hover {
  background: rgba(0, 0, 0, 0.1);
  color: #000000;
  transform: scale(1.1);
}

.task-menu-btn:active {
  transform: scale(0.95);
}

.add-subtask-btn {
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px 8px;
  color: #000000;
  font-size: 13px;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 4px;
  margin-top: 4px;
}

.add-subtask-btn:hover {
  background-color: #e3f2fd;
  border-radius: 4px;
}

/* 階層別インデント - 追加ボタン */
.add-subtask-btn.level-1 {
  margin-left: 24px;
}

.add-subtask-btn.level-2 {
  margin-left: 48px;
}

.add-subtask-btn.level-3 {
  margin-left: 72px;
}

.add-subtask-btn.level-4 {
  margin-left: 96px;
}

.subtask-input-inline {
  margin-top: 8px;
  background: white;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  display: flex;
  align-items: center;
  gap: 8px;
}

/* 階層別インデント - 入力欄 */
.subtask-input-inline.level-1 {
  margin-left: 24px;
}

.subtask-input-inline.level-2 {
  margin-left: 48px;
}

.subtask-input-inline.level-3 {
  margin-left: 72px;
}

.subtask-input-inline.level-4 {
  margin-left: 96px;
}

.subtask-input-inline input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid #000000;
  border-radius: 4px;
  font-size: 14px;
  outline: none;
}

.subtask-input-inline input:focus {
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
}

```

### style-07-empty-state.css

```css
/* ========================================
   空状態
   ======================================== */
.empty-state {
  text-align: center;
  padding: 80px 20px;
  color: #9e9e9e;
  display: none;
}

.empty-state.show {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

```

### style-08-past-tasks.css

```css
/* ========================================
   昨日以前のタスクセクション（折りたたみ）
   ======================================== */
.past-tasks-toggle {
  width: 100%;
  background: none;
  border: none;
  padding: 12px 16px;
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-size: 16px;
  font-weight: 500;
  color: #616161;
  transition: background-color 0.2s ease;
  border-radius: 4px;
  text-align: left;
  margin-bottom: 8px;
}

.past-tasks-toggle:hover {
  background-color: #f5f5f5;
}

.past-tasks-count {
  color: #9e9e9e;
  font-size: 14px;
  font-weight: 400;
}

.past-tasks-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
  margin-bottom: 0;
  padding-bottom: 0;
}

.past-tasks-content.open {
  max-height: 5000px;
}

```

### style-09-completed.css

```css
/* ========================================
   完了済みセクション（折りたたみ）
   ======================================== */
.completed-section {
  margin-top: 24px;
  border-top: 1px solid #e0e0e0;
  padding-top: 16px;
}

.completed-toggle {
  width: 100%;
  background: none;
  border: none;
  padding: 12px 16px;
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-size: 16px;
  font-weight: 500;
  color: #616161;
  transition: background-color 0.2s ease;
  border-radius: 4px;
  text-align: left;
}

.completed-toggle:hover {
  background-color: #f5f5f5;
}

.toggle-icon {
  font-size: 12px;
  transition: transform 0.2s ease;
  display: inline-block;
}

.completed-toggle.open .toggle-icon,
.past-tasks-toggle.open .toggle-icon {
  transform: rotate(90deg);
}

.toggle-text {
  flex: 1;
}

.completed-count {
  color: #9e9e9e;
  font-size: 14px;
  font-weight: 400;
}

.completed-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}

.completed-content.open {
  max-height: 5000px;
}

.completed-content .task-list {
  padding-top: 12px;
}

```

### style-10-fab.css

```css
/* ========================================
   FAB（Floating Action Button）
   ======================================== */
.fab {
  position: fixed;
  bottom: 24px;
  right: 24px;
  width: 56px;
  height: 56px;
  border-radius: 50%;
  background-color: #000000;
  color: white;
  border: none;
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  z-index: 50;
  overflow: hidden;
  position: relative;
}

/* リップルエフェクト */
.fab::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  transform: translate(-50%, -50%);
  transition: width 0.6s, height 0.6s;
}

.fab:active::before {
  width: 100px;
  height: 100px;
}

.fab:hover {
  background-color: #333333;
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
  transform: scale(1.1) rotate(90deg);
}

.fab:active {
  transform: scale(0.95) rotate(90deg);
}

.fab svg {
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.fab:hover svg {
  transform: rotate(-90deg);
}

```

### style-11-modals.css

```css
/* ========================================
   モーダル
   ======================================== */
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0);
  z-index: 1000;
  overflow-y: auto;
  padding: 20px;
  transition: background-color 0.2s ease;
}

.modal.show {
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: rgba(0, 0, 0, 0.5);
  animation: modalFadeIn 0.2s ease;
}

.modal.hiding {
  animation: modalFadeOut 0.2s ease forwards;
}

.modal-content {
  background: white;
  border-radius: 12px;
  width: 100%;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.16);
  animation: modalSlideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.modal.hiding .modal-content {
  animation: modalSlideDown 0.2s cubic-bezier(0.4, 0, 0.6, 1) forwards;
}

.confirm-modal {
  max-width: 400px;
}

/* モーダルアニメーション */
@keyframes modalFadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes modalFadeOut {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}

@keyframes modalSlideUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes modalSlideDown {
  from {
    opacity: 1;
    transform: translateY(0);
  }
  to {
    opacity: 0;
    transform: translateY(30px);
  }
}

.modal-header {
  padding: 20px;
  border-bottom: 1px solid #e0e0e0;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-header h2 {
  font-size: 20px;
  font-weight: 500;
}

.close-btn {
  background: none;
  border: none;
  font-size: 28px;
  color: #757575;
  cursor: pointer;
  line-height: 1;
  padding: 0;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.close-btn:hover {
  color: #333;
}

.modal-body {
  padding: 20px;
}

.modal-footer {
  padding: 16px 20px;
  border-top: 1px solid #e0e0e0;
  display: flex;
  justify-content: flex-end;
  gap: 12px;
}

/* 設定モーダル */
.settings-section-title {
  font-size: 18px;
  font-weight: 600;
  color: #333;
  margin-bottom: 8px;
}

.settings-description {
  font-size: 14px;
  color: #757575;
  margin-bottom: 24px;
  line-height: 1.5;
}

.routines-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 16px;
}

.routine-item {
  background: #f5f5f5;
  border-radius: 8px;
  padding: 16px;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 12px;
}

.routine-name-input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  font-size: 14px;
  background-color: white;
  outline: none;
}

.routine-name-input:focus {
  border-color: #000000;
}

.routine-duration-input {
  padding: 8px 12px;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  font-size: 14px;
  background-color: white;
  cursor: pointer;
  min-width: 120px;
  outline: none;
}

.routine-duration-input:focus {
  border-color: #000000;
}

.routine-delete-btn {
  background: rgba(244, 67, 54, 0.1);
  border: none;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #f44336;
  font-size: 20px;
  font-weight: bold;
  transition: all 0.2s ease;
  flex-shrink: 0;
}

.routine-delete-btn:hover {
  background: rgba(244, 67, 54, 0.2);
  transform: scale(1.1);
}

.routine-delete-btn:active {
  transform: scale(0.95);
}

.btn-add-routine {
  background: rgba(0, 0, 0, 0.05);
  border: 1px solid rgba(0, 0, 0, 0.1);
  border-radius: 8px;
  padding: 12px 16px;
  font-size: 14px;
  color: #000000;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
  width: 100%;
  text-align: left;
}

.btn-add-routine:hover {
  background: rgba(0, 0, 0, 0.1);
}

.btn-add-routine:active {
  transform: scale(0.98);
}

.routine-detail-btn {
  background: rgba(33, 150, 243, 0.1);
  border: none;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #2196F3;
  font-size: 16px;
  transition: all 0.2s ease;
  flex-shrink: 0;
}

.routine-detail-btn:hover {
  background: rgba(33, 150, 243, 0.2);
  transform: scale(1.1);
}

.routine-detail-btn:active {
  transform: scale(0.95);
}

.routine-detail-panel {
  width: 100%;
  display: flex;
  gap: 12px;
  align-items: center;
  padding-top: 8px;
  border-top: 1px solid #e0e0e0;
  margin-top: 8px;
}

.routine-detail-panel label {
  font-size: 13px;
  color: #757575;
  font-weight: 500;
}

.routine-time-input {
  padding: 6px 10px;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  font-size: 14px;
  background-color: white;
  outline: none;
}

.routine-time-input:focus {
  border-color: #2196F3;
}

```

### style-12-forms.css

```css
/* ========================================
   フォーム
   ======================================== */
.form-group {
  margin-bottom: 20px;
}

.form-group label {
  display: block;
  font-size: 14px;
  font-weight: 500;
  margin-bottom: 8px;
  color: #424242;
}

.required {
  color: #000000;
}

.form-group input[type="text"],
.form-group input[type="datetime-local"],
.form-group textarea {
  width: 100%;
  padding: 12px;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  font-size: 14px;
  font-family: inherit;
  transition: border-color 0.2s ease;
  outline: none;
}

.form-group input:focus,
.form-group textarea:focus {
  border-color: #000000;
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
}

.form-group textarea {
  resize: vertical;
  min-height: 80px;
}

.char-count {
  text-align: right;
  font-size: 12px;
  color: #9e9e9e;
  margin-top: 4px;
}

```

### style-13-timer.css

```css
/* ========================================
   タイマーセクション
   ======================================== */
.timer-section {
  background-color: #f5f5f5;
  padding: 16px;
  border-radius: 4px;
}

.timer-display {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

.timer-display span {
  font-size: 24px;
  font-weight: 500;
  font-family: 'Courier New', monospace;
  color: #424242;
}

.timer-btn {
  padding: 8px 16px;
  background-color: #000000;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: background-color 0.2s ease;
}

.timer-btn:hover {
  background-color: #45a049;
}

.timer-btn.running {
  background-color: #000000;
}

.timer-btn.running:hover {
  background-color: #d32f2f;
}

```

### style-14-buttons.css

```css
/* ========================================
   ボタン
   ======================================== */
.btn {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  outline: none;
}

.btn:hover {
  transform: scale(1.05);
}

.btn-primary {
  background-color: #000000;
  color: white;
}

.btn-primary:hover {
  background-color: #333333;
}

.btn-primary:disabled {
  background-color: #bbdefb;
  cursor: not-allowed;
}

.btn-secondary {
  background-color: #f5f5f5;
  color: #424242;
}

.btn-secondary:hover {
  background-color: #e0e0e0;
}

.btn-danger {
  background-color: #000000;
  color: white;
}

.btn-danger:hover {
  background-color: #d32f2f;
}

```

### style-15-subtasks.css

```css
/* ========================================
   サブタスクセクション
   ======================================== */
.subtasks-section {
  background-color: #f5f5f5;
  padding: 16px;
  border-radius: 4px;
}

.subtasks-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 12px;
}

.subtask-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background: white;
  border-radius: 4px;
  border: 1px solid #e0e0e0;
}

.subtask-item input[type="checkbox"] {
  width: 18px;
  height: 18px;
  cursor: pointer;
  flex-shrink: 0;
}

.subtask-item span {
  flex: 1;
  font-size: 14px;
  word-wrap: break-word;
}

.subtask-item.completed span {
  text-decoration: line-through;
  color: #9e9e9e;
}

.subtask-input {
  flex: 1;
  padding: 4px 8px;
  border: 1px solid #000000;
  border-radius: 4px;
  font-size: 14px;
  outline: none;
  font-family: inherit;
}

.subtask-input:focus {
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
}

.subtask-item button {
  background: none;
  border: none;
  color: #757575;
  cursor: pointer;
  padding: 4px;
  font-size: 16px;
  flex-shrink: 0;
}

.subtask-item button:hover {
  color: #000000;
}

.btn-add-subtask {
  width: 100%;
  padding: 8px 12px;
  background: white;
  border: 1px dashed #000000;
  border-radius: 4px;
  color: #000000;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.btn-add-subtask:hover {
  background-color: #e3f2fd;
  border-style: solid;
}

.subtask-count {
  font-size: 12px;
  color: #757575;
  margin-left: 4px;
}

```

### style-16-search-filter.css

```css
/* ========================================
   タスク内時間ゲージバー
   ======================================== */
.task-time-gauge-wrapper {
  margin-top: 12px;
  width: 100%;
}

.task-time-gauge {
  position: relative;
  height: 8px;
  border-radius: 4px;
  overflow: hidden;
  background: #f5f5f5;
  border: 1px solid #e0e0e0;
}

.task-time-gauge-bg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #f5f5f5;
}

.task-time-gauge-bar {
  position: absolute;
  top: 0;
  height: 100%;
  background: linear-gradient(90deg, #333333, #000000);
  transition: all 0.3s ease;
  border-radius: 3px;
}

```

### style-17-analytics.css

```css
/* ========================================
   レスポンシブ対応
   ======================================== */
@media (max-width: 600px) {
  .header {
    padding: 12px 16px;
  }

  .app-title {
    font-size: 20px;
    margin-bottom: 8px;
  }

  .time-gauge-container {
    padding: 20px;
    margin-bottom: 20px;
  }

  .time-gauge-header {
    margin-bottom: 20px;
    gap: 12px;
    flex-wrap: wrap;
  }

  .gauge-nav-btn {
    width: 36px;
    height: 36px;
    font-size: 18px;
  }

  .gauge-header-center {
    gap: 12px;
    width: 100%;
    justify-content: space-between;
  }

  .current-time {
    font-size: 28px;
    font-weight: 700;
    letter-spacing: 1.5px;
  }

  .remaining-tasks {
    font-size: 13px;
    padding: 8px 16px;
    border-radius: 6px;
    letter-spacing: 0.3px;
  }

  .time-gauge {
    height: 56px;
    border-radius: 6px;
  }

  .time-gauge-labels {
    font-size: 11px;
    margin-top: 10px;
  }

  .time-marker {
    width: 3px;
  }

  .time-marker::before,
  .time-marker::after {
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
  }

  .task-time-block::after {
    font-size: 9px;
  }

  .task-item.level-1,
  .add-subtask-btn.level-1,
  .subtask-input-inline.level-1 {
    margin-left: 16px;
  }

  .task-item.level-2,
  .add-subtask-btn.level-2,
  .subtask-input-inline.level-2 {
    margin-left: 32px;
  }

  .task-item.level-3,
  .add-subtask-btn.level-3,
  .subtask-input-inline.level-3 {
    margin-left: 48px;
  }

  .task-item.level-4,
  .add-subtask-btn.level-4,
  .subtask-input-inline.level-4 {
    margin-left: 64px;
  }

  .main-content {
    padding: 16px 12px 120px;
  }

  .task-item {
    padding: 12px;
  }

  .fab {
    bottom: 16px;
    right: 16px;
    width: 48px;
    height: 48px;
  }

  .modal {
    padding: 0;
  }

  .modal-content {
    border-radius: 0;
    max-height: 100vh;
    height: 100%;
  }

  .modal-footer {
    flex-direction: column-reverse;
  }

  .modal-footer .btn {
    width: 100%;
  }
}

```

### style-18-calendar.css

```css
/* ========================================
   タスクコンテキストメニュー
   ======================================== */
.task-context-menu,
.header-dropdown-menu {
  position: fixed;
  background: white;
  border: none;
  border-radius: 12px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
  z-index: 1000;
  min-width: 200px;
  max-width: 90vw;
  overflow: hidden;
}

.task-context-menu .menu-item,
.header-dropdown-menu .menu-item {
  padding: 14px 16px;
  cursor: pointer;
  transition: background-color 0.2s ease;
  font-size: 14px;
  color: #212121;
  display: flex;
  align-items: center;
  gap: 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  border: none;
  background: transparent;
}

.task-context-menu .menu-item:hover,
.header-dropdown-menu .menu-item:hover {
  background-color: #f5f5f5;
}

.task-context-menu .menu-item:active,
.header-dropdown-menu .menu-item:active {
  background-color: #eeeeee;
}

.task-context-menu .menu-item.delete-item {
  color: #d32f2f;
}

.task-context-menu .menu-item.delete-item:hover {
  background-color: #ffebee;
}

.task-context-menu .menu-item.delete-item:active {
  background-color: #ffcdd2;
}

/* スマホ対応 */
@media (max-width: 600px) {
  .task-context-menu,
  .header-dropdown-menu {
    left: 50% !important;
    transform: translateX(-50%);
    right: auto !important;
    min-width: 85vw;
    max-width: 85vw;
  }
}

```

### style-19-accessibility.css

```css
/* ========================================
   時間記録停止ボタン
   ======================================== */
.timer-stop-btn {
  background: rgba(244, 67, 54, 0.1);
  border: none;
  border-radius: 4px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #f44336;
  font-size: 16px;
  transition: all 0.2s ease;
  flex-shrink: 0;
}

.timer-stop-btn:hover {
  background: rgba(244, 67, 54, 0.2);
  transform: scale(1.05);
}

.timer-stop-btn:active {
  transform: scale(0.95);
}

```

### style-20-responsive-01.css

```css
/* ========================================
   タスク時間ブロック（ゲージ）
   ======================================== */
.task-time-block {
  position: absolute;
  height: 100%;
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.75) 0%, rgba(0, 0, 0, 0.85) 100%);
  cursor: pointer;
  transition: all 0.2s ease;
  border-left: 2px solid rgba(0, 0, 0, 0.9);
  border-right: 2px solid rgba(0, 0, 0, 0.9);
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

.task-time-block::after {
  content: attr(data-time-label);
  position: absolute;
  font-size: 10px;
  color: white;
  font-weight: 600;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
  white-space: nowrap;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.task-time-block:hover {
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.6) 0%, rgba(0, 0, 0, 0.7) 100%);
  transform: scaleY(1.1);
  z-index: 10;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
}

.task-time-block:hover::after {
  opacity: 1;
}

.task-time-block:active {
  transform: scaleY(0.95);
}

/* 密度に応じたタスクブロックの色変化 */
.density-green .task-time-block {
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.75) 0%, rgba(0, 0, 0, 0.85) 100%);
  border-left: 2px solid rgba(0, 0, 0, 0.9);
  border-right: 2px solid rgba(0, 0, 0, 0.9);
}

.density-green .task-time-block:hover {
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.6) 0%, rgba(0, 0, 0, 0.7) 100%);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
}

.density-yellow .task-time-block {
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.75) 0%, rgba(0, 0, 0, 0.85) 100%);
  border-left: 2px solid rgba(0, 0, 0, 0.9);
  border-right: 2px solid rgba(0, 0, 0, 0.9);
}

.density-yellow .task-time-block:hover {
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.6) 0%, rgba(0, 0, 0, 0.7) 100%);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
}

.density-red .task-time-block {
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.75) 0%, rgba(0, 0, 0, 0.85) 100%);
  border-left: 2px solid rgba(0, 0, 0, 0.9);
  border-right: 2px solid rgba(0, 0, 0, 0.9);
}

.density-red .task-time-block:hover {
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.6) 0%, rgba(0, 0, 0, 0.7) 100%);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
}

/* ========================================
   時間帯タスク一覧モーダル
   ======================================== */
.time-slot-modal {
  max-width: 500px;
}

.time-slot-task-item {
  padding: 12px;
  margin-bottom: 8px;
  background: #f5f5f5;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.time-slot-task-item:hover {
  background: #e0e0e0;
  transform: translateX(4px);
}

.time-slot-task-item .task-title {
  font-weight: 500;
  margin-bottom: 4px;
  color: #333;
}

.time-slot-task-item .task-time {
  font-size: 13px;
  color: #666;
  margin-bottom: 4px;
}

.time-slot-task-item .task-memo {
  font-size: 13px;
  color: #888;
  margin-top: 8px;
  white-space: pre-wrap;
}

/* ========================================
   元に戻すトースト
   ======================================== */
.undo-toast {
  position: fixed;
  bottom: 80px;
  left: 50%;
  transform: translateX(-50%) translateY(100px);
  background: #323232;
  color: white;
  padding: 12px 16px;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  z-index: 10000;
  opacity: 0;
  transition: all 0.3s ease;
  max-width: 90%;
}

.undo-toast.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

.undo-toast-content {
  display: flex;
  align-items: center;
  gap: 16px;
}

.undo-toast-text {
  font-size: 14px;
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 300px;
}

.undo-btn {
  background: transparent;
  border: none;
  color: #4CAF50;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.undo-btn:hover {
  background: rgba(76, 175, 80, 0.1);
}

.undo-btn:active {
  transform: scale(0.95);
}

@media (max-width: 768px) {
  .undo-toast {
    bottom: 70px;
    max-width: 85%;
  }

  .undo-toast-text {
    max-width: 200px;
  }
}

/* ========================================
   データ分析モーダル
   ======================================== */
.analytics-icon-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: white;
  transition: all 0.2s ease;
}

.analytics-icon-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: scale(1.05);
}

.analytics-icon-btn:active {
  transform: scale(0.95);
}

.analytics-section {
  margin-bottom: 32px;
}

.analytics-section:last-child {
  margin-bottom: 0;
}

.analytics-section-title {
  font-size: 18px;
  font-weight: 600;
  color: #333;
  margin-bottom: 8px;
}

.analytics-description {
  font-size: 14px;
  color: #757575;
  margin-bottom: 16px;
  line-height: 1.5;
}

.ranking-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.ranking-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px;
  background: #f5f5f5;
  border-radius: 8px;
  transition: all 0.2s ease;
  position: relative;
}

.ranking-item:hover {
  background: #e0e0e0;
  transform: translateX(4px);
}

.ranking-exclude-btn {
  background: rgba(244, 67, 54, 0.1);
  border: none;
  border-radius: 50%;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #f44336;
  transition: all 0.2s ease;
  flex-shrink: 0;
  padding: 0;
}

.ranking-exclude-btn:hover {
  background: rgba(244, 67, 54, 0.2);
  transform: scale(1.1);
}

.ranking-exclude-btn:active {
  transform: scale(0.95);
}

.ranking-position {
  font-size: 18px;
  font-weight: 700;
  color: #757575;
  min-width: 36px;
  text-align: center;
}

.ranking-position.gold {
  color: #ffd700;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

.ranking-position.silver {
  color: #c0c0c0;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

.ranking-position.bronze {
  color: #cd7f32;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

.ranking-info {
  flex: 1;
  min-width: 0;
}

.ranking-task-name {
  font-size: 15px;
  font-weight: 500;
  color: #333;
  margin-bottom: 4px;
  word-wrap: break-word;
}

.ranking-time {
  font-size: 14px;
  font-weight: 600;
  color: #000000;
  white-space: nowrap;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
}

.stat-card {
  background: #f5f5f5;
  border-radius: 8px;
  padding: 16px;
  text-align: center;
  transition: all 0.2s ease;
}

.stat-card:hover {
  background: #e0e0e0;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.stat-label {
  font-size: 13px;
  color: #757575;
  margin-bottom: 8px;
  font-weight: 500;
}

.stat-value {
  font-size: 32px;
  font-weight: 700;
  color: #000000;
  font-variant-numeric: tabular-nums;
}

.stat-unit {
  font-size: 16px;
  color: #757575;
  margin-left: 4px;
}
```

### style-21-responsive-02.css

```css

.empty-analytics {
  text-align: center;
  padding: 40px 20px;
  color: #9e9e9e;
  font-size: 14px;
}

@media (max-width: 600px) {
  .stats-grid {
    grid-template-columns: 1fr;
  }

  .stat-value {
    font-size: 28px;
  }

  .ranking-position {
    font-size: 16px;
    min-width: 28px;
  }

  .ranking-item {
    padding: 12px;
  }
}

/* ========================================
   年間空き時間グラフ
   ======================================== */
.yearly-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 24px;
}

.chart-container {
  background: #f5f5f5;
  border-radius: 12px;
  padding: 24px;
  border: 1px solid #e0e0e0;
}

.chart-title {
  font-size: 16px;
  font-weight: 600;
  color: #333;
  margin-bottom: 20px;
  text-align: center;
}

.chart-bars {
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  gap: 8px;
  height: 200px;
  padding: 0 4px;
}

.chart-bar-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  min-width: 0;
}

.chart-bar-wrapper {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  position: relative;
}

.chart-bar {
  width: 100%;
  max-width: 32px;
  background: linear-gradient(180deg, #666666 0%, #000000 100%);
  border-radius: 4px 4px 0 0;
  transition: all 0.3s ease;
  cursor: pointer;
  position: relative;
  display: flex;
  align-items: flex-start;
  justify-content: center;
  padding-top: 4px;
  min-height: 4px;
}

.chart-bar:hover {
  background: linear-gradient(180deg, #888888 0%, #333333 100%);
  transform: scaleY(1.05);
  box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.2);
}

.chart-bar-label {
  font-size: 10px;
  font-weight: 600;
  color: white;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  white-space: nowrap;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.chart-bar:hover .chart-bar-label {
  opacity: 1;
}

.chart-month-label {
  font-size: 11px;
  color: #757575;
  font-weight: 500;
  text-align: center;
  white-space: nowrap;
}

@media (max-width: 600px) {
  .yearly-stats {
    grid-template-columns: 1fr;
  }

  .chart-container {
    padding: 16px;
  }

  .chart-title {
    font-size: 14px;
    margin-bottom: 16px;
  }

  .chart-bars {
    height: 160px;
    gap: 4px;
    padding: 0 2px;
  }

  .chart-bar {
    max-width: 24px;
  }

  .chart-bar-label {
    font-size: 8px;
  }

  .chart-month-label {
    font-size: 9px;
  }
}

/* ========================================
   時間オーバー警告モーダル
   ======================================== */
.overload-warning {
  background: #f5f5f5;
  border-left: 4px solid #000000;
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 24px;
}

.overload-message {
  font-size: 16px;
  font-weight: 600;
  color: #333;
  margin-bottom: 12px;
  line-height: 1.6;
}

.overload-message strong {
  color: #000000;
  font-size: 18px;
  font-weight: 700;
}

.overload-description {
  font-size: 14px;
  color: #666;
  line-height: 1.5;
}

.overload-tasks-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
  max-height: 400px;
  overflow-y: auto;
  padding: 4px;
}

.overload-tasks-list::-webkit-scrollbar {
  width: 8px;
}

.overload-tasks-list::-webkit-scrollbar-track {
  background: #f5f5f5;
  border-radius: 4px;
}

.overload-tasks-list::-webkit-scrollbar-thumb {
  background: #cccccc;
  border-radius: 4px;
}

.overload-tasks-list::-webkit-scrollbar-thumb:hover {
  background: #999999;
}

.overload-task-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 16px;
  background: #ffffff;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  transition: all 0.2s ease;
}

.overload-task-item:hover {
  background: #f9f9f9;
  border-color: #cccccc;
  transform: translateX(4px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.overload-task-info {
  flex: 1;
  min-width: 0;
}

.overload-task-title {
  font-size: 15px;
  font-weight: 500;
  color: #333;
  margin-bottom: 6px;
  word-wrap: break-word;
  line-height: 1.4;
}

.overload-task-time {
  font-size: 13px;
  color: #666;
  font-weight: 500;
}

.overload-task-actions {
  display: flex;
  gap: 8px;
  flex-shrink: 0;
}

.btn-edit-task,
.btn-postpone-task,
.btn-delete-task {
  background: #f5f5f5;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #666;
  transition: all 0.2s ease;
  padding: 0;
}

.btn-edit-task:hover {
  background: #e0e0e0;
  border-color: #cccccc;
  color: #000000;
  transform: scale(1.05);
}

.btn-postpone-task:hover {
  background: #e0e0e0;
  border-color: #cccccc;
  color: #000000;
  transform: scale(1.05);
}

.btn-delete-task:hover {
  background: #ffebee;
  border-color: #ef9a9a;
  color: #d32f2f;
  transform: scale(1.05);
}

.btn-edit-task:active,
.btn-postpone-task:active,
.btn-delete-task:active {
  transform: scale(0.95);
}

@media (max-width: 600px) {
  .overload-warning {
    padding: 16px;
    margin-bottom: 20px;
  }

  .overload-message {
    font-size: 15px;
  }

  .overload-message strong {
    font-size: 17px;
  }

  .overload-description {
    font-size: 13px;
  }

  .overload-task-item {
    padding: 12px;
    gap: 8px;
  }

  .overload-task-title {
    font-size: 14px;
  }

  .overload-task-time {
    font-size: 12px;
  }

  .btn-edit-task,
  .btn-postpone-task,
  .btn-delete-task {
    width: 32px;
    height: 32px;
  }

  .btn-edit-task svg,
  .btn-postpone-task svg,
  .btn-delete-task svg {
    width: 14px;
    height: 14px;
  }
}

/* ========================================
   テンプレートモーダル
   ======================================== */
.templates-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 16px;
  max-height: 400px;
  overflow-y: auto;
}

.template-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px;
  background: #f5f5f5;
```

### style-22-responsive-03.css

```css
  border-radius: 8px;
  transition: all 0.2s ease;
  cursor: pointer;
}

.template-item:hover {
  background: #e0e0e0;
  transform: translateX(4px);
}

.template-info {
  flex: 1;
  min-width: 0;
}

.template-name {
  font-size: 15px;
  font-weight: 500;
  color: #333;
  margin-bottom: 4px;
  word-wrap: break-word;
}

.template-details {
  font-size: 13px;
  color: #666;
}

.template-actions {
  display: flex;
  gap: 8px;
  flex-shrink: 0;
}

.template-use-btn {
  background: #f5f5f5;
  border: 1px solid #e0e0e0;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #000000;
  transition: all 0.2s ease;
  padding: 0;
}

.template-use-btn:hover {
  background: #000000;
  border-color: #000000;
  color: white;
  transform: scale(1.1);
}

.template-use-btn:active {
  transform: scale(0.95);
}

.template-delete-btn {
  background: rgba(244, 67, 54, 0.1);
  border: none;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #f44336;
  font-size: 20px;
  font-weight: bold;
  transition: all 0.2s ease;
  flex-shrink: 0;
  padding: 0;
}

.template-delete-btn:hover {
  background: rgba(244, 67, 54, 0.2);
  transform: scale(1.1);
}

.template-delete-btn:active {
  transform: scale(0.95);
}

.btn-add-template {
  background: rgba(0, 0, 0, 0.05);
  border: 1px dashed rgba(0, 0, 0, 0.2);
  border-radius: 8px;
  padding: 12px 16px;
  font-size: 14px;
  color: #000000;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
  width: 100%;
  text-align: left;
}

.btn-add-template:hover {
  background: rgba(0, 0, 0, 0.1);
  border-style: solid;
}

.btn-add-template:active {
  transform: scale(0.98);
}

.template-input-form {
  background: #f5f5f5;
  border-radius: 8px;
  padding: 20px;
  margin-top: 16px;
}

.template-input-form .form-group {
  margin-bottom: 16px;
}

.template-input-form label {
  display: block;
  font-size: 14px;
  font-weight: 500;
  margin-bottom: 6px;
  color: #424242;
}

.template-input-form input[type="text"],
.template-input-form input[type="time"],
.template-input-form textarea,
.template-input-form select {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  font-size: 14px;
  font-family: inherit;
  transition: border-color 0.2s ease;
  outline: none;
  background: white;
}

.template-input-form input:focus,
.template-input-form textarea:focus,
.template-input-form select:focus {
  border-color: #000000;
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
}

.template-input-form textarea {
  resize: vertical;
  min-height: 60px;
}

/* ========================================
   カレンダーモーダル
   ======================================== */
.calendar-nav {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
}

.calendar-nav-btn {
  background: #f5f5f5;
  border: 1px solid #e0e0e0;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 24px;
  color: #333;
  transition: all 0.2s ease;
}

.calendar-nav-btn:hover {
  background: #e0e0e0;
  transform: scale(1.05);
}

.calendar-nav-btn:active {
  transform: scale(0.95);
}

.calendar-current-month {
  font-size: 18px;
  font-weight: 600;
  color: #333;
}

.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 8px;
  width: 100%;
}

.calendar-weekday {
  text-align: center;
  font-size: 12px;
  font-weight: 600;
  color: #757575;
  padding: 8px 0;
}

.calendar-day {
  aspect-ratio: 1;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  padding: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  background: white;
  min-height: 0;
  overflow: hidden;
}

.calendar-day.empty {
  border: none;
  cursor: default;
  background: transparent;
}

.calendar-day:not(.empty):hover {
  background: #f5f5f5;
  border-color: #000;
  transform: scale(1.05);
}

.calendar-day.today {
  background: #000;
  color: white;
  border-color: #000;
}

.calendar-day.today .calendar-day-number {
  color: white;
}

.calendar-day.today .calendar-task-count {
  color: #ddd;
}

.calendar-day-number {
  font-size: 16px;
  font-weight: 600;
  color: #333;
  margin-bottom: 4px;
}

.calendar-task-count {
  font-size: 11px;
  color: #666;
  margin-bottom: 2px;
}

.calendar-task-status {
  font-size: 10px;
  display: flex;
  align-items: center;
  gap: 4px;
  color: #999;
}

.incomplete-dot {
  display: inline-block;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: #ff9800;
}

.complete-dot {
  display: inline-block;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: #4caf50;
}

/* 月次統計 */
.calendar-monthly-stats {
  margin-top: 32px;
  padding-top: 24px;
  border-top: 2px solid #e0e0e0;
}

.monthly-stats-title {
  font-size: 18px;
  font-weight: 600;
  color: #333;
  margin-bottom: 20px;
  text-align: center;
}

.monthly-stats-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
}

.monthly-stat-card {
  background: #f5f5f5;
  border-radius: 12px;
  padding: 20px;
  text-align: center;
  transition: all 0.2s ease;
  border: 1px solid #e0e0e0;
}

.monthly-stat-card:hover {
  background: #e0e0e0;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.monthly-stat-card .stat-label {
  font-size: 13px;
  color: #757575;
  margin-bottom: 12px;
  font-weight: 500;
}

.monthly-stat-card .stat-value {
  font-size: 36px;
  font-weight: 700;
  color: #000000;
  font-variant-numeric: tabular-nums;
  line-height: 1.2;
}

.monthly-stat-card .stat-unit {
  font-size: 16px;
  color: #757575;
  margin-left: 4px;
  font-weight: 500;
}

@media (max-width: 600px) {
  .calendar-grid {
    gap: 1px;
  }

  .calendar-day {
    padding: 1px;
    border-radius: 2px;
    border-width: 0.5px;
  }

  .calendar-day-number {
    font-size: 10px;
    margin-bottom: 1px;
  }

  .calendar-task-count {
    font-size: 8px;
```

### style-23-responsive-04.css

```css
    margin-bottom: 0px;
  }

  .calendar-task-status {
    font-size: 7px;
    gap: 1px;
  }

  .incomplete-dot,
  .complete-dot {
    width: 3px;
    height: 3px;
  }

  .calendar-weekday {
    font-size: 9px;
    padding: 2px 0;
  }

  .calendar-nav {
    margin-bottom: 12px;
  }

  .calendar-nav-btn {
    width: 28px;
    height: 28px;
    font-size: 18px;
  }

  .calendar-current-month {
    font-size: 14px;
  }

  #calendar-modal .modal-body {
    padding: 12px;
  }

  #calendar-modal .modal-header {
    padding: 12px;
  }

  .calendar-monthly-stats {
    margin-top: 24px;
    padding-top: 16px;
  }

  .monthly-stats-title {
    font-size: 16px;
    margin-bottom: 16px;
  }

  .monthly-stats-grid {
    grid-template-columns: 1fr;
    gap: 12px;
  }

  .monthly-stat-card {
    padding: 16px;
  }

  .monthly-stat-card .stat-value {
    font-size: 28px;
  }

  .monthly-stat-card .stat-unit {
    font-size: 14px;
  }
}

/* ========================================
   複数選択モード
   ======================================== */

/* 選択モードトグルボタン */
.select-mode-icon-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: white;
  transition: all 0.2s ease;
}

.select-mode-icon-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: scale(1.05);
}

.select-mode-icon-btn:active {
  transform: scale(0.95);
}

.selection-mode .select-mode-icon-btn {
  background: rgba(255, 255, 255, 0.9);
  color: #000000;
}

/* タスク選択チェックボックス */
.task-select-checkbox {
  width: 20px;
  height: 20px;
  cursor: pointer;
  flex-shrink: 0;
  margin-right: 4px;
  accent-color: #000000;
  transition: transform 0.2s ease;
}

.task-select-checkbox:hover {
  transform: scale(1.15);
}

/* 選択されたタスク */
.task-item.selected {
  background: rgba(0, 0, 0, 0.08);
  border-left: 4px solid #000000;
  transform: translateX(2px);
}

.task-item.selected.subtask {
  border-left: 4px solid #000000;
}

/* 一括操作ツールバー */
.bulk-actions-toolbar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: #000000;
  padding: 10px 12px;
  box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.15);
  z-index: 99;
  animation: slideUp 0.3s ease;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

@keyframes slideUp {
  from {
    transform: translateY(100%);
  }
  to {
    transform: translateY(0);
  }
}

/* 上段: キャンセル、選択数、全選択 */
.bulk-toolbar-top {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

/* キャンセルボタン */
.bulk-cancel-btn {
  background: rgba(255, 255, 255, 0.15);
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: white;
  padding: 0;
  transition: all 0.2s ease;
  flex-shrink: 0;
}

.bulk-cancel-btn:hover {
  background: rgba(255, 255, 255, 0.25);
  transform: scale(1.1);
}

.bulk-cancel-btn:active {
  transform: scale(0.95);
}

.bulk-cancel-btn svg {
  width: 16px;
  height: 16px;
}

/* 選択数表示 */
.bulk-selection-count {
  color: white;
  font-size: 14px;
  font-weight: 500;
  flex: 1;
  text-align: center;
}

/* 全選択リンク */
.btn-link {
  background: none;
  border: none;
  color: white;
  font-size: 13px;
  cursor: pointer;
  text-decoration: underline;
  padding: 4px 8px;
  transition: opacity 0.2s ease;
  white-space: nowrap;
  flex-shrink: 0;
}

.btn-link:hover {
  opacity: 0.8;
}

/* 下段: アクションボタン群 */
.bulk-toolbar-actions {
  display: flex;
  gap: 6px;
  justify-content: space-between;
}

/* ラベル付きアクションボタン */
.bulk-action-btn-with-label {
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 8px;
  padding: 8px 10px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 4px;
  cursor: pointer;
  color: white;
  transition: all 0.2s ease;
  flex: 1;
  min-width: 0;
  font-size: 11px;
  font-weight: 500;
}

.bulk-action-btn-with-label:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: translateY(-2px);
}

.bulk-action-btn-with-label:active {
  transform: translateY(0);
}

.bulk-action-btn-with-label svg {
  width: 18px;
  height: 18px;
  flex-shrink: 0;
}

.bulk-action-btn-with-label span {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
}

/* 削除ボタン（赤色） */
.bulk-delete-btn {
  background: rgba(244, 67, 54, 0.3);
  border-color: rgba(244, 67, 54, 0.5);
}

.bulk-delete-btn:hover {
  background: rgba(244, 67, 54, 0.4);
}

/* 選択モード中のUIの調整 */
.selection-mode .quick-add {
  display: none;
}

.selection-mode .fab {
  display: none;
}

.selection-mode .task-actions {
  opacity: 0.3;
  pointer-events: none;
}

/* ========================================
   フェーズ 6.5: 入力体験の改善
   ======================================== */

/* オートコンプリート UI */
.input-autocomplete-container {
  position: absolute;
  bottom: 100%;
  left: 0;
  right: 0;
  background: white;
  border: 1px solid #e0e0e0;
  border-radius: 8px 8px 0 0;
  max-height: 200px;
  overflow-y: auto;
  z-index: 50;
  display: none;
  box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
}

.autocomplete-item {
  padding: 12px 16px;
  border-bottom: 1px solid #f5f5f5;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: background-color 0.2s ease;
}

.autocomplete-item:hover {
  background-color: #f5f5f5;
}

.autocomplete-item strong {
  font-weight: 500;
  color: #212121;
}

.autocomplete-item .duration {
  font-size: 12px;
  color: #9e9e9e;
  background: #f5f5f5;
  padding: 2px 8px;
  border-radius: 4px;
}

/* 絵文字ピッカー */
.emoji-picker-container {
  position: fixed;
  bottom: 100px;
  right: 16px;
  background: white;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  z-index: 100;
  max-width: 300px;
  display: none;
}

.emoji-picker-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid #e0e0e0;
  font-size: 14px;
  font-weight: 500;
}

.emoji-picker-close {
  background: none;
  border: none;
```

### style-24-responsive-05.css

```css
  font-size: 20px;
  cursor: pointer;
  padding: 0;
  color: #9e9e9e;
  transition: color 0.2s ease;
}

.emoji-picker-close:hover {
  color: #212121;
}

.emoji-picker-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 8px;
  padding: 12px 16px;
}

.emoji-item {
  background: none;
  border: 1px solid #f5f5f5;
  border-radius: 8px;
  padding: 8px;
  cursor: pointer;
  font-size: 24px;
  transition: all 0.2s ease;
  aspect-ratio: 1 / 1;
  display: flex;
  align-items: center;
  justify-content: center;
}

.emoji-item:hover {
  background-color: #f5f5f5;
  transform: scale(1.1);
}

.emoji-item:active {
  transform: scale(0.95);
}

/* 入力フォーカス時の調整 */
.quick-add input:focus {
  outline: none;
  border-color: #000000;
}

/* キーボード表示時の対応（大きな画面では非表示） */
@media (max-height: 600px) {
  .quick-add {
    position: static;
  }
}

@media (max-width: 600px) {
  .bulk-actions-toolbar {
    padding: 8px 10px;
    gap: 6px;
  }

  .bulk-cancel-btn {
    width: 28px;
    height: 28px;
  }
}

/* ========================================
   フェーズ 6.8: トースト通知
   ======================================== */

.toast-container {
  position: fixed;
  bottom: 80px;
  left: 16px;
  right: 16px;
  z-index: 1000;
  display: flex;
  flex-direction: column;
  gap: 12px;
  pointer-events: none;
}

.toast {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  border-radius: 8px;
  background: #fff;
  border: 1px solid #e0e0e0;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
  font-size: 14px;
  animation: slideUp 0.3s ease;
  pointer-events: auto;
  opacity: 0;
  transform: translateY(20px);
}

.toast.show {
  opacity: 1;
  transform: translateY(0);
}

.toast.fade-out {
  animation: slideDown 0.3s ease forwards;
}

.toast-success {
  border-left: 4px solid #4CAF50;
}

.toast-error {
  border-left: 4px solid #F44336;
}

.toast-warning {
  border-left: 4px solid #FFC107;
}

.toast-info {
  border-left: 4px solid #2196F3;
}

.toast-icon {
  font-size: 20px;
  min-width: 20px;
}

.toast-message {
  flex: 1;
  color: #212121;
}

.toast-close {
  background: none;
  border: none;
  color: #999;
  cursor: pointer;
  font-size: 18px;
  padding: 0;
  min-width: 24px;
}

.toast-undo {
  border-left: 4px solid #2196F3;
}

.toast-undo-btn {
  margin-left: 12px;
  padding: 4px 12px;
  background: #2196F3;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  font-weight: 500;
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideDown {
  from {
    opacity: 1;
    transform: translateY(0);
  }
  to {
    opacity: 0;
    transform: translateY(20px);
  }
}

/* ========================================
   フェーズ 6.8: ローディング画面
   ======================================== */

.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.loading-spinner {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
}

.spinner {
  width: 48px;
  height: 48px;
  border: 4px solid #f3f3f3;
  border-top: 4px solid #212121;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loading-message {
  font-size: 14px;
  color: #616161;
}

.timeout-message {
  font-size: 14px;
  color: #F44336;
  margin-bottom: 16px;
}

.retry-btn {
  margin-top: 12px;
}

.loading-overlay.fade-out {
  animation: fadeOut 0.3s ease forwards;
}

@keyframes fadeOut {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}

/* ========================================
   フェーズ 6.8: スケルトンスクリーン
   ======================================== */

.skeleton-screen {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.skeleton-item {
  padding: 12px;
  border-radius: 8px;
  background: #f5f5f5;
}

.skeleton-line {
  height: 12px;
  background: linear-gradient(90deg, #f5f5f5 25%, #e0e0e0 50%, #f5f5f5 75%);
  background-size: 200% 100%;
  border-radius: 4px;
  animation: shimmer 2s infinite;
}

.skeleton-title {
  height: 16px;
  margin-bottom: 8px;
}

.skeleton-text {
  height: 12px;
  margin-bottom: 6px;
}

.skeleton-text.short {
  width: 70%;
}

@keyframes shimmer {
  0% {
    background-position: 200% 0;
  }
  100% {
    background-position: -200% 0;
  }
}

/* ========================================
   フェーズ 6.8: オフラインバナー
   ======================================== */

.offline-banner {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: #F44336;
  color: white;
  padding: 12px;
  text-align: center;
  z-index: 999;
  animation: slideDown 0.3s ease;
}

.offline-banner.fade-out {
  animation: slideUp 0.3s ease forwards;
}

.offline-banner-content {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.offline-icon {
  font-size: 16px;
}

.offline-text {
  font-size: 14px;
  font-weight: 500;
}

/* ========================================
   フェーズ 6.8: 同期インジケーター
   ======================================== */

.sync-indicator {
  position: fixed;
  bottom: 80px;
  right: 16px;
  display: none;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  background: #2196F3;
  color: white;
  border-radius: 20px;
  font-size: 12px;
  z-index: 900;
}

.sync-indicator.show {
  display: flex;
}

.sync-spinner {
  width: 12px;
  height: 12px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top-color: white;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

/* ========================================
   フェーズ 6.8: 入力フィールドエラー
   ======================================== */
```

### style-25-responsive-06.css

```css

.input-error {
  border-color: #F44336 !important;
}

.input-error-message {
  color: #F44336;
  font-size: 12px;
  margin-top: 4px;
  display: flex;
  align-items: center;
  gap: 4px;
}

.input-error-message::before {
  content: '⚠️';
}

/* ========================================
   フェーズ 6.9: チュートリアル
   ======================================== */

.tutorial-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  z-index: 1500;
  pointer-events: none;
}

.tutorial-highlight {
  position: relative;
  z-index: 1501;
  box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.7);
  border-radius: 8px;
  pointer-events: auto;
}

.tutorial-tooltip {
  position: fixed;
  background: white;
  border-radius: 8px;
  padding: 16px;
  max-width: 280px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  z-index: 1502;
  animation: popIn 0.3s ease;
}

@keyframes popIn {
  from {
    opacity: 0;
    transform: scale(0.8);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.tutorial-tooltip-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.tutorial-tooltip-title {
  font-size: 16px;
  font-weight: 600;
  margin: 0;
  color: #212121;
}

.tutorial-step-counter {
  font-size: 12px;
  color: #999;
  background: #f5f5f5;
  padding: 4px 8px;
  border-radius: 4px;
}

.tutorial-tooltip-description {
  font-size: 14px;
  color: #616161;
  margin: 0 0 16px 0;
  line-height: 1.5;
}

.tutorial-tooltip-buttons {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}

.tutorial-tooltip-buttons button {
  padding: 8px 16px;
  font-size: 12px;
}

/* ========================================
   フェーズ 6.9: ショートカットガイド
   ======================================== */

.shortcuts-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  border-radius: 12px;
  padding: 24px;
  max-width: 500px;
  max-height: 80vh;
  overflow-y: auto;
  z-index: 2000;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
}

.shortcuts-title {
  font-size: 18px;
  font-weight: 600;
  margin: 0 0 16px 0;
  color: #212121;
}

.shortcuts-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 12px;
  margin-bottom: 20px;
}

.shortcut-card {
  padding: 12px;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  text-align: center;
  background: #f9f9f9;
}

.shortcut-icon {
  font-size: 24px;
  display: block;
  margin-bottom: 8px;
}

.shortcut-gesture {
  font-size: 12px;
  font-weight: 600;
  color: #212121;
  margin-bottom: 4px;
}

.shortcut-action {
  font-size: 11px;
  color: #616161;
}

.shortcuts-modal-footer {
  display: flex;
  justify-content: center;
  gap: 12px;
  margin-top: 20px;
  padding-top: 20px;
  border-top: 1px solid #e0e0e0;
}

/* ========================================
   フェーズ 6.9: FAQ
   ======================================== */

.faq-container {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: white;
  z-index: 2000;
  overflow-y: auto;
  padding: 20px;
}

.faq-title {
  font-size: 20px;
  font-weight: 600;
  margin: 0 0 16px 0;
  color: #212121;
}

.faq-search {
  margin-bottom: 20px;
}

.faq-search input {
  width: 100%;
  padding: 12px;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  font-size: 14px;
}

.faq-items {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.faq-item {
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  overflow: hidden;
}

.faq-question {
  width: 100%;
  padding: 12px;
  background: #f9f9f9;
  border: none;
  text-align: left;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  color: #212121;
  display: flex;
  gap: 8px;
  align-items: center;
  transition: background 0.2s;
}

.faq-question:hover {
  background: #f0f0f0;
}

.faq-q-icon {
  color: #2196F3;
  font-weight: 600;
  min-width: 20px;
}

.faq-answer {
  padding: 12px;
  background: white;
  font-size: 13px;
  color: #616161;
  line-height: 1.6;
  display: none;
}

.faq-answer.show {
  display: block;
}

.faq-a-icon {
  color: #4CAF50;
  font-weight: 600;
  margin-right: 4px;
}

/* ========================================
   フェーズ 6.9: ツールチップ
   ======================================== */

.has-tooltip[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  background: #333;
  color: white;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  margin-bottom: 8px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s;
  z-index: 1000;
}

.has-tooltip[data-tooltip]::before {
  content: '';
  position: absolute;
  bottom: calc(100% - 4px);
  left: 50%;
  transform: translateX(-50%);
  border: 4px solid transparent;
  border-top-color: #333;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s;
  z-index: 1000;
}

.has-tooltip:hover::after,
.has-tooltip:hover::before {
  opacity: 1;
}

/* ========================================
   フェーズ 6.7: ハイコントラストモード
   ======================================== */

@media (prefers-contrast: more) {
  :root {
    --contrast-text: #000;
    --contrast-bg: #fff;
    --contrast-border: #000;
  }

  body {
    color: var(--contrast-text);
  }

  button {
    border: 2px solid var(--contrast-border);
  }

  .toast {
    border: 2px solid var(--contrast-border);
  }

  input, textarea, select {
    border: 2px solid var(--contrast-border) !important;
  }
}

/* ========================================
   フェーズ 6.8: 確認ダイアログ
   ======================================== */

.confirm-dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.confirm-dialog {
  background: white;
  border-radius: 12px;
  padding: 24px;
  max-width: 400px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
}

.confirm-dialog-title {
  font-size: 18px;
  font-weight: 600;
  margin: 0 0 12px 0;
  color: #212121;
}

.confirm-dialog-message {
```

### style-26-responsive-07.css

```css
  font-size: 14px;
  color: #616161;
  margin: 0 0 20px 0;
  line-height: 1.5;
}

.confirm-dialog-buttons {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
}

/* スクリーンリーダー向け非表示要素 */
#sr-live-region {
  position: absolute;
  left: -10000px;
  width: 1px;
  height: 1px;
  overflow: hidden;
}

/* ========================================
   フェーズ 6.7.3: 文字サイズとタップ領域
   ======================================== */

/* 全ボタンの最小サイズ確保（48×48px） */
button, a[role="button"], [role="button"] {
  min-width: 48px;
  min-height: 48px;
  padding: 12px 16px;
  font-size: 14px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

/* アイコンボタンの最小サイズ */
.icon-btn,
.select-mode-icon-btn,
.login-icon-btn,
.share-icon-btn,
.settings-icon-btn,
.analytics-icon-btn,
.calendar-icon-btn,
.quick-action-btn,
.search-clear-btn,
.close-btn,
.filter-btn,
.filter-btn-clear {
  width: 48px;
  height: 48px;
  padding: 12px;
  font-size: 16px;
  min-width: 48px;
  min-height: 48px;
}

/* 入力フィールドの最小サイズ */
input[type="text"],
input[type="email"],
input[type="password"],
input[type="date"],
input[type="time"],
input[type="search"],
textarea,
select {
  min-height: 48px;
  padding: 12px;
  font-size: 14px;
}

input[type="checkbox"],
input[type="radio"] {
  width: 24px;
  height: 24px;
  min-width: 24px;
  min-height: 24px;
  margin: 12px;
}

/* タスク項目のタップ領域 */
.task-item,
.completed-item {
  min-height: 56px;
  padding: 12px;
  display: flex;
  align-items: center;
  cursor: pointer;
}

/* リンクのタップ領域 */
a {
  min-height: 44px;
  padding: 8px;
  display: inline-flex;
  align-items: center;
}

/* FAB（フローティングアクションボタン）のサイズ */
.fab {
  width: 56px;
  height: 56px;
  min-width: 56px;
  min-height: 56px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* ラベルと関連入力のための余白 */
label {
  display: block;
  margin-bottom: 8px;
  font-size: 14px;
  font-weight: 500;
}

.form-group {
  margin-bottom: 20px;
  display: flex;
  flex-direction: column;
}

/* セレクト要素の最小サイズ */
.form-group select {
  min-height: 48px;
  padding: 12px;
  font-size: 14px;
}

/* モーダルボタンのサイズ */
.modal-footer button,
.confirm-dialog-buttons button {
  min-width: 48px;
  min-height: 48px;
  padding: 12px 16px;
  font-size: 14px;
  margin: 8px;
}

/* バッチ操作ボタン */
.bulk-action-btn-with-label {
  min-width: 48px;
  min-height: 48px;
  padding: 12px 8px;
  font-size: 12px;
}

/* フォーム要素周辺の余白 */
.form-group input,
.form-group textarea,
.form-group select {
  margin: 8px 0;
}

/* チェックボックスとラジオボタンのサイズ */
input[type="checkbox"] + label,
input[type="radio"] + label {
  display: inline-flex;
  align-items: center;
  min-height: 48px;
  padding: 8px 12px;
  margin: 0;
  cursor: pointer;
}

/* 最小フォントサイズの強制（14px以上） */
body,
p,
span,
div,
a,
button {
  font-size: 14px;
}

/* 見出しのフォントサイズ */
h1 {
  font-size: 24px;
  min-height: 48px;
  line-height: 1.5;
}

h2 {
  font-size: 20px;
  min-height: 48px;
  line-height: 1.5;
}

h3 {
  font-size: 18px;
  min-height: 40px;
  line-height: 1.4;
}

h4, h5, h6 {
  font-size: 16px;
  min-height: 40px;
  line-height: 1.4;
}

/* テキストコンテンツの最小サイズ確保 */
.task-title,
.task-item-text,
.notification-text,
.error-message,
.success-message {
  font-size: 14px;
  min-height: 20px;
  line-height: 1.4;
}

/* 小さいテキストのサイズ制限 */
.small-text,
.meta-text,
.timestamp,
.subtitle {
  font-size: 12px;
  min-height: 18px;
}

/* 説明テキスト */
.description,
.helper-text,
.form-description {
  font-size: 13px;
  line-height: 1.5;
  margin-top: 4px;
  margin-bottom: 12px;
}

/* 画面サイズによる調整（小画面デバイス用） */
@media (max-width: 480px) {
  /* 小画面では若干緩和 */
  button, a[role="button"], [role="button"] {
    min-width: 44px;
    min-height: 44px;
  }

  .icon-btn,
  .quick-action-btn {
    width: 44px;
    height: 44px;
    min-width: 44px;
    min-height: 44px;
  }

  input[type="text"],
  input[type="email"],
  input[type="password"],
  input[type="date"],
  input[type="time"],
  textarea,
  select {
    min-height: 44px;
  }

  .task-item,
  .completed-item {
    min-height: 52px;
  }
}

/* 大画面デバイス用（タブレット） */
@media (min-width: 768px) {
  button, a[role="button"], [role="button"] {
    min-width: 52px;
    min-height: 52px;
    padding: 14px 20px;
  }

  .icon-btn,
  .quick-action-btn {
    width: 52px;
    height: 52px;
  }

  .fab {
    width: 64px;
    height: 64px;
  }
}

/* ========================================
   フェーズ 6.7.2: アイコン視認性向上
   ======================================== */

/* アイコンのサイズと視認性 */
svg {
  stroke-width: 2px;
  min-width: 20px;
  min-height: 20px;
}

button svg,
a svg,
[role="button"] svg {
  width: 20px;
  height: 20px;
  stroke: currentColor;
  stroke-width: 2;
  fill: none;
}

/* ボタン内のアイコン調整 */
button:hover svg,
a:hover svg {
  stroke-width: 2.5px;
  opacity: 0.8;
}

button:active svg,
a:active svg {
  stroke-width: 2.5px;
  opacity: 0.6;
}

/* アイコンボタンのホバー効果 */
.icon-btn:hover,
.quick-action-btn:hover {
  background-color: #f5f5f5;
  border-radius: 8px;
  transition: background-color 0.2s;
}

.icon-btn:active,
.quick-action-btn:active {
  background-color: #e8e8e8;
}

/* 重要なアイコン（警告など）の強調 */
.warning-icon,
.error-icon,
.success-icon,
.info-icon {
  stroke-width: 3;
}

/* テンプレートアイコン */
.template-icon,
.history-icon,
.search-icon,
.emoji-icon {
  min-width: 18px;
  min-height: 18px;
}

/* SVG アイコンの濃度向上（コントラスト強化） */
.icon-btn svg {
  stroke: #212121;
}

.icon-btn:hover svg {
  stroke: #000000;
}

/* 選択状態のアイコン視認性 */
.selected .icon-btn svg,
[aria-selected="true"] svg {
  stroke: #1976D2;
  stroke-width: 2.5;
}

/* ダークモード時のアイコン視認性（将来対応） */
@media (prefers-color-scheme: dark) {
  .icon-btn svg {
```

### style-27-responsive-08.css

```css
    stroke: #e0e0e0;
  }

  .icon-btn:hover svg {
    stroke: #ffffff;
  }
}

/* ハイコントラストモード時のアイコン */
@media (prefers-contrast: more) {
  svg {
    stroke-width: 3px;
  }

  button svg,
  a svg,
  [role="button"] svg {
    stroke-width: 3;
  }

  .icon-btn {
    border: 2px solid #000000;
    border-radius: 8px;
  }

  .icon-btn:hover {
    background-color: #000000;
  }

  .icon-btn:hover svg {
    stroke: #ffffff;
  }
}

  .bulk-cancel-btn svg {
    width: 14px;
    height: 14px;
  }

  .bulk-selection-count {
    font-size: 13px;
  }

  .btn-link {
    font-size: 12px;
    padding: 4px 6px;
  }

  .bulk-toolbar-actions {
    gap: 4px;
  }

  .bulk-action-btn-with-label {
    padding: 6px 8px;
    font-size: 10px;
    gap: 2px;
  }

  .bulk-action-btn-with-label svg {
    width: 16px;
    height: 16px;
  }
}

/* ========================================
   検索・フィルター・ソート機能
   ======================================== */

/* 検索バー */
.search-container {
  position: relative;
}

.search-input-wrapper {
  position: relative;
  display: flex;
  align-items: center;
  background: #ffffff;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  padding: 10px 12px;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

.search-input-wrapper:focus-within {
  border-color: #000000;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
}

.search-icon {
  color: #9e9e9e;
  margin-right: 8px;
  flex-shrink: 0;
}

#search-input {
  flex: 1;
  border: none;
  outline: none;
  font-size: 14px;
  color: #212121;
  background: transparent;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

#search-input::placeholder {
  color: #9e9e9e;
}

.search-clear-btn {
  background: none;
  border: none;
  color: #757575;
  font-size: 24px;
  cursor: pointer;
  padding: 0;
  margin-left: 8px;
  line-height: 1;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: background-color 0.2s ease, color 0.2s ease;
  flex-shrink: 0;
}

.search-clear-btn:hover {
  background-color: #f5f5f5;
  color: #212121;
}

.search-clear-btn:active {
  background-color: #e0e0e0;
}

/* 検索履歴 */
.search-history {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: #ffffff;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  margin-top: 4px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  z-index: 100;
  max-height: 200px;
  overflow-y: auto;
}

.search-history-item {
  padding: 10px 12px;
  font-size: 14px;
  color: #424242;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: background-color 0.2s ease;
}

.search-history-item:hover {
  background-color: #f5f5f5;
}

.search-history-item svg {
  color: #9e9e9e;
  flex-shrink: 0;
}

.search-history-item:not(:last-child) {
  border-bottom: 1px solid #f0f0f0;
}

/* 検索結果のハイライト */
.search-highlight {
  background-color: #ffeb3b;
  font-weight: 500;
  padding: 0 2px;
  border-radius: 2px;
}

/* フィルター・ソートコンテナ */
.filter-sort-container {
  background: #fafafa;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  padding: 16px;
}

.sort-select {
  padding: 8px 12px;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  font-size: 14px;
  color: #212121;
  background: #ffffff;
  cursor: pointer;
  outline: none;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
  flex: 1;
  max-width: 250px;
}

.sort-select:hover {
  border-color: #bdbdbd;
}

.sort-select:focus {
  border-color: #000000;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
}

/* フィルターグループ */
.filter-group {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* フィルターボタン */
.filter-btn {
  padding: 8px 16px;
  border: 2px solid #e0e0e0;
  border-radius: 20px;
  background: #ffffff;
  color: #616161;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
  outline: none;
}

.filter-btn:hover {
  border-color: #bdbdbd;
  background-color: #f5f5f5;
  transform: translateY(-1px);
}

.filter-btn:active {
  transform: translateY(0);
}

.filter-btn.active {
  border-color: #000000;
  background-color: #000000;
  color: #ffffff;
}

.filter-btn-clear {
  padding: 8px 16px;
  border: 2px solid #e57373;
  border-radius: 20px;
  background: #ffffff;
  color: #d32f2f;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
  outline: none;
}

.filter-btn-clear:hover {
  border-color: #d32f2f;
  background-color: #ffebee;
  transform: translateY(-1px);
}

.filter-btn-clear:active {
  transform: translateY(0);
  background-color: #ffcdd2;
}

/* レスポンシブデザイン */
@media (max-width: 600px) {
  .filter-sort-container {
    padding: 12px;
  }

  .filter-btn,
  .filter-btn-clear {
    padding: 6px 12px;
    font-size: 12px;
  }

  .sort-select {
    font-size: 13px;
    max-width: 100%;
  }

  .search-input-wrapper {
    padding: 8px 10px;
  }

  #search-input {
    font-size: 13px;
  }
}
/* ========================================
   複数選択ボタン（ゲージ下部）
   ======================================== */
.bulk-select-button-container {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 12px 16px;
  background: #ffffff;
  border-bottom: 1px solid #e0e0e0;
}

.bulk-select-toggle-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 10px 20px;
  background: #ffffff;
  border: 2px solid #000000;
  border-radius: 8px;
  color: #000000;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.bulk-select-toggle-btn:hover {
  background: #f5f5f5;
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.bulk-select-toggle-btn:active {
  transform: translateY(0);
  background: #eeeeee;
}

.bulk-select-toggle-btn.active {
  background: #000000;
  color: #ffffff;
}

.bulk-select-toggle-btn.active:hover {
  background: #333333;
}

/* レスポンシブ対応 */
@media (max-width: 600px) {
  .bulk-select-button-container {
    padding: 10px 12px;
  }

  .bulk-select-toggle-btn {
    padding: 8px 16px;
    font-size: 13px;
  }

  .bulk-select-toggle-btn svg {
    width: 16px;
    height: 16px;
    margin-right: 4px;
  }
}
```

### style-base.css

```css
/* ========================================
   CSS変数定義（新デザインシステム）
   ======================================== */
:root {
  /* カラーパレット */
  --color-primary: #000000;
  --color-bg: #ffffff;
  --color-bg-secondary: #f5f5f5;
  --color-text: #000000;
  --color-text-secondary: #666666;
  --color-text-tertiary: #999999;
  --color-border: #e0e0e0;
  --color-border-dark: #d0d0d0;

  /* 機能色 */
  --color-priority-high: #ff6b6b;
  --color-priority-medium: #ffa500;
  --color-priority-low: #4dabf7;
  --color-urgent: #d63031;
  --color-error: #f44336;

  /* スペーシング */
  --space-xs: 4px;
  --space-sm: 8px;
  --space-md: 12px;
  --space-lg: 16px;
  --space-xl: 20px;
  --space-xxl: 24px;

  /* タイポグラフィ */
  --text-xxl: 18px;
  --text-xl: 16px;
  --text-lg: 14px;
  --text-md: 12px;
  --text-sm: 11px;
  --text-xs: 10px;

  /* 角丸 */
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 12px;

  /* 影 */
  --shadow-sm: 0 2px 4px rgba(0,0,0,0.08);
  --shadow-md: 0 2px 8px rgba(0,0,0,0.08);
  --shadow-lg: 0 4px 12px rgba(0,0,0,0.15);

  /* トランジション */
  --transition-fast: 0.15s ease;
  --transition-base: 0.2s ease;
  --transition-slow: 0.3s ease;
}

/* ========================================
   リセット & 基本設定
   ======================================== */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f5f5f5;
  color: #333;
  line-height: 1.6;
}

/* ========================================
   ヘッダー
   ======================================== */
.header {
  background-color: #000000;
  color: white;
  padding: 16px 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  position: sticky;
  top: 0;
  z-index: 100;
}

.header-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.app-title {
  font-size: 24px;
  font-weight: 500;
  letter-spacing: 0.5px;
  margin: 0;
}

.header-actions {
  display: flex;
  gap: 8px;
}

.trash-icon-btn,
.settings-icon-btn,
.share-icon-btn,
.analytics-icon-btn,
.calendar-icon-btn,
.login-icon-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: white;
  transition: all 0.2s ease;
}

.trash-icon-btn:hover,
.settings-icon-btn:hover,
.share-icon-btn:hover,
.analytics-icon-btn:hover,
.calendar-icon-btn:hover,
.login-icon-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: scale(1.05);
}

.trash-icon-btn:active,
.settings-icon-btn:active,
.share-icon-btn:active,
.analytics-icon-btn:active,
.calendar-icon-btn:active,
.login-icon-btn:active {
  transform: scale(0.95);
}

.quick-add {
  width: 100%;
  display: flex;
  gap: 8px;
  position: relative;
}

.quick-add #quick-add-input {
  flex: 1;
  padding: 10px 12px;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  outline: none;
  transition: box-shadow 0.2s ease;
}

.quick-add #quick-add-input:focus {
  box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
}

.quick-add #quick-add-input::placeholder {
  color: #999;
}

.quick-add-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.quick-date-btn {
  background: rgba(255, 255, 255, 0.9);
  border: none;
  border-radius: 4px;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #333333;
  transition: all 0.2s ease;
  padding: 0;
}

.quick-date-btn:hover {
  background: white;
  transform: scale(1.05);
}

.quick-date-btn:active {
  transform: scale(0.95);
}

.quick-date-btn.has-date {
  background: #333333;
  color: white;
}

.quick-date-input {
  position: absolute;
  top: 100%;
  right: 140px;
  margin-top: 8px;
  padding: 8px;
  border: 2px solid white;
  border-radius: 4px;
  font-size: 14px;
  background-color: white;
  color: #333;
  cursor: pointer;
  outline: none;
  z-index: 10;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.quick-date-input::-webkit-calendar-picker-indicator {
  cursor: pointer;
}

.duration-select {
  padding: 8px 10px;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  background-color: white;
  color: #333;
  cursor: pointer;
  outline: none;
  transition: box-shadow 0.2s ease;
  min-width: 120px;
}

.duration-select:focus {
  box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
}

/* タブナビゲーションのスタイルは廃止済み */

/* ========================================
   メインコンテンツ
   ======================================== */
.main-content {
  max-width: 900px;
  margin: 0 auto;
  padding: 24px 20px 100px;
}

.tab-content {
  display: none;
}

.tab-content.active {
  display: block;
}
```

### style-components.css

```css
/* ========================================
   24時間ゲージ - 確定仕様
   ======================================== */
.time-gauge {
  background: #ffffff;
  padding: 16px 20px;
  margin-bottom: 12px;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
  border: 1px solid #e0e0e0;
}

.time-gauge-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 14px;
  gap: 12px;
}

.gauge-nav-btn {
  background: #f5f5f5;
  border: 1px solid #d0d0d0;
  border-radius: 6px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 20px;
  color: #333;
  flex-shrink: 0;
  transition: all 0.2s ease;
  user-select: none;
}

.gauge-nav-btn:hover {
  background: #e8e8e8;
  border-color: #bdbdbd;
}

.gauge-nav-btn:active {
  transform: scale(0.95);
}

.gauge-header-center {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex: 1;
  gap: 8px;
}

.gauge-date-label {
  font-size: 14px;
  font-weight: 600;
  color: #000;
}

.current-time {
  font-size: 12px;
  color: #666;
  font-weight: 500;
}

.remaining-tasks {
  font-size: 12px;
  color: #666;
  white-space: nowrap;
}

.gauge-wrapper {
  margin-bottom: 8px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.gauge-bar {
  display: flex;
  gap: 2px;
  margin-bottom: 8px;
  position: relative;
  height: 32px;
  background: #e0e0e0;
  border-radius: 8px;
  overflow: hidden;
}

.time-gauge-elapsed,
.time-gauge-scheduled,
.time-gauge-free {
  position: absolute;
  top: 0;
  height: 100%;
}

.time-gauge-elapsed {
  background: #666;
  left: 0;
}

.time-gauge-scheduled {
  background: #000;
}

.time-gauge-free {
  background: #e0e0e0;
}

.time-marker {
  position: absolute;
  width: 3px;
  height: 100%;
  background: #f44336;
  top: 0;
  z-index: 10;
}

.time-marker::before {
  content: '';
  position: absolute;
  top: -4px;
  left: 50%;
  transform: translateX(-50%);
  width: 0;
  height: 0;
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: 6px solid #f44336;
}

.time-labels {
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  color: #999;
  margin-top: 8px;
  padding: 0 2px;
}

.time-label {
  text-align: center;
  font-size: 11px;
  font-weight: 500;
}

.task-time-block {
  position: absolute;
  top: 0;
  height: 100%;
  background: #000;
  cursor: pointer;
  transition: all 0.2s ease;
  z-index: 3;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: 700;
  color: #ffffff;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  overflow: hidden;
}

.task-time-block:hover {
  background: #333;
  transform: scaleY(1.05);
  z-index: 4;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

.task-time-block::before {
  content: attr(data-time-label);
  position: absolute;
  font-size: 9px;
  font-weight: 600;
  color: #ffffff;
  white-space: nowrap;
  opacity: 0;
  transition: opacity 0.2s ease;
  pointer-events: none;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
}

.task-time-block:hover::before {
  opacity: 1;
}

/* ========================================
   空状態
   ======================================== */
.empty-state {
  display: none;
  padding: 60px 20px;
  text-align: center;
  color: #9e9e9e;
  font-size: 18px;
  font-weight: 500;
}

.empty-state.show {
  display: block;
}

.empty-state p {
  margin-bottom: 12px;
}

.empty-state small {
  display: block;
  font-size: 14px;
  font-weight: 400;
  color: #bdbdbd;
  margin-top: 8px;
}

/* ========================================
   完了済みセクション
   ======================================== */
.completed-section {
  margin-top: 32px;
  border-top: 2px solid #e0e0e0;
  padding-top: 16px;
}

.completed-toggle {
  width: 100%;
  background: none;
  border: none;
  padding: 12px 0;
  font-size: 16px;
  font-weight: 500;
  color: #616161;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: color 0.2s ease;
}

.completed-toggle:hover {
  color: #000000;
}

.toggle-icon {
  transition: transform 0.2s ease;
  font-size: 14px;
}

.completed-toggle.open .toggle-icon {
  transform: rotate(90deg);
}

.completed-count {
  color: #9e9e9e;
  font-size: 14px;
}

.completed-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}

.completed-content.open {
  max-height: 5000px;
  margin-top: 16px;
}

/* ========================================
   FAB（新規作成ボタン）
   ======================================== */
.fab {
  position: fixed;
  bottom: 24px;
  right: 24px;
  width: 56px;
  height: 56px;
  background-color: #000000;
  border: none;
  border-radius: 50%;
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  z-index: 50;
}

.fab:hover {
  background-color: #333333;
  transform: scale(1.1);
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
}

.fab:active {
  transform: scale(0.95);
}

/* ========================================
   サブタスク折りたたみスタイル
   ======================================== */
.collapse-toggle {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 14px;
  margin-right: 8px;
  color: #616161;
  padding: 4px;
}

.collapse-toggle:hover {
  color: #000000;
}

/* 非表示にする際は高さとパディングを0にして滑らかに折りたたむ */
.subtask-hidden {
  display: block; /* ブロックは維持してトランジションのために max-height を操作 */
  max-height: 0 !important;
  overflow: hidden;
  opacity: 0;
  transition: max-height 0.25s ease, opacity 0.2s ease, padding 0.2s ease;
  padding-top: 0 !important;
  padding-bottom: 0 !important;
}

/* サブタスクのデフォルトは十分な max-height を与えておく */
.task-item.subtask {
  max-height: 200px;
  transition: max-height 0.25s ease, opacity 0.2s ease;
  opacity: 1;
}

/* 並び替えセレクトの簡易スタイル */
.sort-container select {
  padding: 6px 8px;
  border-radius: 6px;
  border: 1px solid #e0e0e0;
  background: white;
}

/* ========================================
   新ヘッダー（新デザインシステム）
   ======================================== */
/* 旧UIはデフォルトで非表示（新UIがデフォルト） */
#old-header {
  display: none !important;
}

#old-time-gauge-container {
  display: none !important;
}

#new-time-gauge-container {
  display: block !important;
}

#old-bulk-select-button-container {
  display: none !important;
}

#new-bulk-select-button-container {
  display: flex !important;
}

.new-header {
  background: var(--color-bg);
  padding: var(--space-md) var(--space-lg);
  border-bottom: 1px solid var(--color-border);
  position: sticky;
  top: 0;
  z-index: 100;
  display: flex !important;
  justify-content: space-between;
  align-items: center;
}

.new-header-content {
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.new-app-title {
  font-size: var(--text-xxl);
  font-weight: 600;
  color: var(--color-text);
  margin: 0;
  letter-spacing: 0.5px;
}

.new-header-actions {
  display: flex;
  gap: var(--space-sm);
}

.new-header-btn {
  width: 32px;
  height: 32px;
  border: 1px solid var(--color-border);
  border-radius: 6px;
  background: var(--color-bg);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background var(--transition-base);
  flex-shrink: 0;
}

.new-header-btn:hover {
  background: var(--color-bg-secondary);
}

.new-header-btn:active {
  transform: scale(0.95);
}

.new-header-btn svg {
  width: 20px;
  height: 20px;
  stroke: currentColor;
  fill: none;
  stroke-width: 2;
  color: var(--color-text);
}

/* ========================================
   新タスクカード（新デザインシステム）
   ======================================== */
.new-task-card {
  display: flex;
  gap: var(--space-md);
  align-items: flex-start;
  padding: var(--space-md);
  background: var(--color-bg);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  margin-bottom: var(--space-sm);
  transition: box-shadow var(--transition-base), background var(--transition-base);
  cursor: pointer;
}

.new-task-card:hover {
  box-shadow: var(--shadow-sm);
  background: #fafafa;
}

.new-task-card.completed {
  opacity: 0.6;
  background: #f5f5f5;
}

.new-task-card.completed .new-task-title {
  text-decoration: line-through;
  color: var(--color-text-tertiary);
}

/* 優先度による色分け */
.new-task-card.priority-high {
  border-left: 4px solid var(--color-priority-high);
  background: #fff5f5;
}

.new-task-card.priority-medium {
  border-left: 4px solid var(--color-priority-medium);
  background: #fffbf5;
}

.new-task-card.priority-low {
  border-left: 4px solid var(--color-priority-low);
  background: #f0f8ff;
}

.new-task-card.urgent {
  border-left: 4px solid var(--color-urgent);
  background: #ffe6e6;
}

.new-task-body {
  flex: 1;
  min-width: 0;
}

.new-task-title {
  font-size: var(--text-lg);
  font-weight: 500;
  color: var(--color-text);
  margin-bottom: var(--space-xs);
  word-wrap: break-word;
  line-height: 1.4;
}

.new-task-meta {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  font-size: var(--text-sm);
  color: var(--color-text-tertiary);
  flex-wrap: wrap;
}

.new-duration-badge {
  display: inline-flex;
  align-items: center;
  background: var(--color-bg-secondary);
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  font-size: var(--text-xs);
  color: var(--color-text-secondary);
}

.new-urgent-badge {
  display: inline-flex;
  align-items: center;
  background: #ffe6e6;
  color: var(--color-urgent);
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  font-size: var(--text-xs);
  font-weight: 600;
}

.new-task-actions {
  display: flex;
  gap: var(--space-xs);
  flex-shrink: 0;
  align-items: center;
}

.new-task-action-btn {
  width: 24px;
  height: 24px;
  border: 1px solid var(--color-border);
  background: var(--color-bg);
  color: var(--color-text-secondary);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-sm);
  transition: background var(--transition-base), color var(--transition-base), border-color var(--transition-base);
  flex-shrink: 0;
  font-size: 14px;
  font-weight: bold;
  line-height: 1;
}

.new-task-action-btn:hover {
  background: var(--color-bg-secondary);
  color: var(--color-primary);
  border-color: var(--color-primary);
}

.new-task-action-btn:active {
  transform: scale(0.95);
}

.new-task-menu-btn {
  width: 24px;
  height: 24px;
  border: none;
  background: transparent;
  color: var(--color-text-tertiary);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-sm);
  transition: background var(--transition-base), color var(--transition-base);
  flex-shrink: 0;
  font-size: 18px;
  line-height: 1;
}

.new-task-menu-btn:hover {
  background: var(--color-bg-secondary);
  color: var(--color-text);
}

.new-task-menu-btn:active {
  transform: scale(0.95);
}

.new-task-checkbox {
  width: 24px;
  height: 24px;
  min-width: 24px;
  min-height: 24px;
  border: 2px solid #ccc;
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all var(--transition-base);
  background: white;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.new-task-checkbox:hover {
  border-color: var(--color-primary);
}

.new-task-checkbox.checked {
  background: var(--color-primary);
  border-color: var(--color-primary);
}

.new-task-checkbox.checked::after {
  content: '✓';
  color: white;
  font-size: 16px;
  font-weight: bold;
  line-height: 1;
}

/* ========================================
   新セクションラベル（新デザインシステム）
   ======================================== */
.new-section-label {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: var(--color-primary);
  color: white;
  padding: var(--space-sm) var(--space-lg);
  font-size: var(--text-md);
  font-weight: 600;
  position: sticky;
  top: 57px;
  z-index: 90;
  border-radius: 0;
}

.new-section-title {
  flex: 1;
}

.new-section-add-btn {
  width: 24px;
  height: 24px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  background: rgba(255, 255, 255, 0.1);
  color: white;
  font-size: 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-sm);
  transition: all var(--transition-base);
}

.new-section-add-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  border-color: rgba(255, 255, 255, 0.5);
}

/* ========================================
   新24時間ゲージ（新デザインシステム）
   ======================================== */
.new-time-gauge {
  background: var(--color-bg);
  padding: var(--space-lg) var(--space-xl);
  margin-bottom: var(--space-md);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  border: 1px solid var(--color-border);
}

.new-gauge-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 14px;
  gap: var(--space-md);
}

.new-gauge-nav-btn {
  background: var(--color-bg-secondary);
  border: 1px solid var(--color-border-dark);
  border-radius: 6px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 20px;
  color: var(--color-text);
  transition: all var(--transition-base);
}

.new-gauge-nav-btn:hover {
  background: #e8e8e8;
  border-color: #bdbdbd;
}

.new-gauge-nav-btn:active {
  transform: scale(0.95);
}

.new-gauge-header-center {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex: 1;
  gap: var(--space-sm);
}

.new-gauge-date-label {
  font-size: var(--text-lg);
  font-weight: 600;
  color: var(--color-text);
}

.new-current-time {
  font-size: var(--text-md);
  color: var(--color-text-secondary);
  font-weight: 500;
}

.new-gauge-wrapper {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.new-gauge-bar {
  display: flex;
  gap: 2px;
  margin-bottom: var(--space-sm);
}

.new-gauge-step {
  flex: 1;
  height: 24px;
  background: var(--color-border);
  border-radius: var(--radius-sm);
  transition: background var(--transition-base);
}

.new-gauge-step.active {
  background: var(--color-primary);
}

.new-gauge-step.active.current-marker {
  background: #f5f5f7;
  border: 2px solid #5f6368;
}

.new-time-labels {
  display: flex;
  justify-content: space-between;
  font-size: var(--text-sm);
  color: var(--color-text-tertiary);
  margin-top: var(--space-sm);
  padding: 0 2px;
}

.new-time-label {
  text-align: center;
  font-weight: 500;
}

/* ========================================
   新クイック入力・完了済みセクション（新デザインシステム）
   ======================================== */

/* クイック入力バー */
.new-quick-add-bar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--color-primary);
  padding: var(--space-md) var(--space-lg);
  box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.15);
  z-index: 999;
  display: flex;
  gap: var(--space-sm);
  align-items: center;
}

.new-quick-history-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  border-radius: var(--radius-sm);
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: white;
  transition: background var(--transition-base);
  flex-shrink: 0;
}

.new-quick-history-btn:hover {
  background: rgba(255, 255, 255, 0.3);
}

.new-quick-input-wrapper {
  position: relative;
  display: flex;
  align-items: center;
  background: white;
  border-radius: var(--radius-sm);
  padding-right: 4px;
  flex: 1;
}

.new-quick-input {
  flex: 1;
  padding: 10px 80px 10px 14px;
  border: none;
  border-radius: var(--radius-sm);
  font-size: var(--text-lg);
  outline: none;
  background: transparent;
}

.new-quick-input-actions {
  position: absolute;
  right: 4px;
  display: flex;
  gap: 4px;
}

.new-quick-date-btn,
.new-quick-submit-btn {
  background: var(--color-text-secondary);
  border: none;
  border-radius: var(--radius-sm);
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: white;
  transition: background var(--transition-base);
}

.new-quick-date-btn:hover,
.new-quick-submit-btn:hover {
  background: #555;
}

.new-quick-submit-btn {
  background: var(--color-primary);
}

.new-quick-submit-btn:hover {
  background: #333;
}

/* 完了済みセクション */
.new-completed-section {
  margin-top: var(--space-xxl);
  padding: 0 var(--space-xl);
  margin-bottom: 80px;
}

.new-completed-toggle {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  width: 100%;
  padding: var(--space-md) var(--space-lg);
  background: var(--color-bg-secondary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  cursor: pointer;
  font-size: var(--text-lg);
  font-weight: 500;
  color: var(--color-text-secondary);
  transition: background var(--transition-base);
}

.new-completed-toggle:hover {
  background: #f0f0f0;
}

.new-toggle-icon {
  font-size: var(--text-md);
  color: var(--color-text-tertiary);
  transition: transform var(--transition-base);
  display: inline-block;
}

.new-toggle-icon.expanded {
  transform: rotate(90deg);
}

.new-completed-count {
  margin-left: auto;
  color: var(--color-text-tertiary);
  font-size: var(--text-md);
}

.new-completed-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height var(--transition-slow), opacity var(--transition-base);
  opacity: 0;
  margin-top: 0;
}

.new-completed-content.open {
  max-height: 5000px;
  opacity: 1;
  margin-top: var(--space-md);
}

/* ========================================
   新複数選択ボタン（新デザインシステム）
   ======================================== */
.new-bulk-select-button-container {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: var(--space-md) var(--space-lg);
  background: var(--color-bg);
  border-bottom: 1px solid var(--color-border);
  margin-bottom: var(--space-sm);
  position: sticky;
  top: 57px;
  z-index: 80;
}

.new-bulk-select-toggle-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-xs);
  padding: 10px 20px;
  background: var(--color-bg);
  border: 2px solid var(--color-primary);
  border-radius: var(--radius-md);
  color: var(--color-primary);
  font-size: var(--text-md);
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-base);
  outline: none;
}

.new-bulk-select-toggle-btn:hover {
  background: var(--color-bg-secondary);
  transform: translateY(-1px);
  box-shadow: var(--shadow-sm);
}

.new-bulk-select-toggle-btn:active {
  transform: translateY(0);
}

.new-bulk-select-toggle-btn.active {
  background: var(--color-primary);
  color: white;
}

.new-bulk-select-toggle-btn.active:hover {
  background: #333333;
}

.new-bulk-select-toggle-btn svg {
  width: 16px;
  height: 16px;
}

/* レスポンシブ対応 */
@media (max-width: 600px) {
  .new-bulk-select-button-container {
    padding: 10px 12px;
  }

  .new-bulk-select-toggle-btn {
    padding: 8px 16px;
    font-size: var(--text-sm);
  }

  .new-bulk-select-toggle-btn svg {
    width: 14px;
    height: 14px;
  }
}

/* ========================================
   新昨日以前のタスクセクション（新デザインシステム）
   ======================================== */
.new-past-tasks-section {
  margin-top: var(--space-lg);
  padding: 0 var(--space-lg);
}

.new-past-tasks-toggle {
  width: 100%;
  background: var(--color-bg-secondary);
  border: 1px solid var(--color-border);
  padding: var(--space-md) var(--space-lg);
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  cursor: pointer;
  font-size: var(--text-lg);
  font-weight: 500;
  color: var(--color-text-secondary);
  transition: background var(--transition-base), color var(--transition-base);
  border-radius: var(--radius-md);
  text-align: left;
  margin-bottom: var(--space-sm);
}

.new-past-tasks-toggle:hover {
  background: #f0f0f0;
  color: var(--color-text);
}

.new-past-tasks-toggle .toggle-icon {
  font-size: var(--text-md);
  transition: transform var(--transition-base);
  display: inline-block;
  color: var(--color-text-tertiary);
}

.new-past-tasks-toggle.open .toggle-icon {
  transform: rotate(90deg);
}

.new-past-tasks-toggle .toggle-text {
  flex: 1;
}

.new-past-tasks-count {
  color: var(--color-text-tertiary);
  font-size: var(--text-md);
  font-weight: 400;
  margin-left: auto;
}

.new-past-tasks-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height var(--transition-slow), opacity var(--transition-base);
  opacity: 0;
  margin-bottom: 0;
  padding-bottom: 0;
}

.new-past-tasks-content.open {
  max-height: 5000px;
  opacity: 1;
  margin-bottom: var(--space-md);
  padding-bottom: var(--space-md);
}
```

---

## JavaScript Modules

### accessibility.js

```javascript
// ========================================
// フェーズ 6.7: アクセシビリティの向上
// ========================================

/**
 * ARIA ラベルとロールの一元管理
 */
const ACCESSIBILITY_CONFIG = {
  buttons: {
    'create-task-btn': {
      label: '新規タスク作成',
      role: 'button'
    },
    'select-mode-icon-btn': {
      label: '複数選択モード',
      role: 'button'
    },
    'quick-date-btn': {
      label: '日付と時間を設定',
      role: 'button'
    },
    'quick-history-btn': {
      label: 'タスク履歴',
      role: 'button'
    },
    'bulk-select-all-btn': {
      label: 'すべて選択/解除',
      role: 'button'
    },
    'bulk-complete-btn': {
      label: '選択したタスクを完了',
      role: 'button'
    },
    'bulk-delete-btn': {
      label: '選択したタスクを削除',
      role: 'button'
    },
    'bulk-date-btn': {
      label: '選択したタスクの日付を変更',
      role: 'button'
    },
    'bulk-priority-btn': {
      label: '選択したタスクの優先度を変更',
      role: 'button'
    }
  },

  inputs: {
    'quick-add-input': {
      label: 'タスク名を入力してEnter',
      role: 'searchbox'
    },
    'search-input': {
      label: 'タスクを検索',
      role: 'searchbox'
    },
    'task-title': {
      label: 'タスク名',
      role: 'textbox'
    },
    'task-memo': {
      label: 'メモ',
      role: 'textbox'
    },
    'task-due-date': {
      label: '期限日を選択',
      role: 'application'
    },
    'task-start-time': {
      label: '開始時刻',
      role: 'textbox'
    },
    'task-end-time': {
      label: '終了時刻',
      role: 'textbox'
    },
    'task-duration': {
      label: '所要時間を選択',
      role: 'combobox'
    },
    'task-priority': {
      label: '優先度を選択',
      role: 'combobox'
    }
  },

  regions: {
    'tasks-tab': {
      role: 'region',
      label: 'タスクリスト'
    },
    'time-gauge-container': {
      role: 'region',
      label: '24時間タイムゲージ'
    },
    'bulk-actions-toolbar': {
      role: 'region',
      label: 'バッチ操作ツールバー'
    },
    'completed-section': {
      role: 'region',
      label: '完了済みタスク'
    }
  }
};

/**
 * ARIA ラベルを初期化
 */
function initializeAriaLabels() {
  // ボタンの ARIA ラベル設定
  Object.entries(ACCESSIBILITY_CONFIG.buttons).forEach(([id, config]) => {
    const element = document.getElementById(id);
    if (element) {
      element.setAttribute('aria-label', config.label);
      if (config.role) {
        element.setAttribute('role', config.role);
      }
    }
  });

  // 入力フィールドの ARIA ラベル設定
  Object.entries(ACCESSIBILITY_CONFIG.inputs).forEach(([id, config]) => {
    const element = document.getElementById(id);
    if (element) {
      element.setAttribute('aria-label', config.label);
      if (config.role) {
        element.setAttribute('role', config.role);
      }
      // label 要素と紐付け
      const labelElement = document.querySelector(`label[for="${id}"]`);
      if (labelElement) {
        element.setAttribute('aria-labelledby', labelElement.id || id);
      }
    }
  });

  // リージョンの ARIA ラベル設定
  Object.entries(ACCESSIBILITY_CONFIG.regions).forEach(([id, config]) => {
    const element = document.getElementById(id);
    if (element) {
      element.setAttribute('role', config.role);
      element.setAttribute('aria-label', config.label);
    }
  });
}

/**
 * タスク項目に ARIA 属性を設定
 */
function setTaskItemAriaAttributes(taskElement, task) {
  if (!taskElement || !task) return;

  // タスク項目全体の ARIA ラベル
  const ariaLabel = `${task.title}, 期限: ${formatDateForAria(task.dueDate)}, ` +
    `${task.isCompleted ? '完了' : '未完了'}`;
  taskElement.setAttribute('aria-label', ariaLabel);
  taskElement.setAttribute('role', 'listitem');

  // チェックボックスの ARIA 属性
  const checkbox = taskElement.querySelector('input[type="checkbox"]');
  if (checkbox) {
    checkbox.setAttribute('aria-label', `${task.title}を${task.isCompleted ? '未完了に' : '完了に'}変更`);
    checkbox.setAttribute('aria-checked', task.isCompleted);
  }

  // 時間情報の ARIA 属性
  if (task.startTime && task.endTime) {
    const timeElement = taskElement.querySelector('.task-time');
    if (timeElement) {
      timeElement.setAttribute('aria-label', `時間: ${task.startTime} から ${task.endTime}`);
    }
  }

  // 優先度の ARIA 属性
  if (task.priority) {
    const priorityElement = taskElement.querySelector('.task-priority');
    if (priorityElement) {
      priorityElement.setAttribute('aria-label', `優先度: ${task.priority}`);
    }
  }
}

/**
 * フォーカス管理の初期化
 */
function initializeFocusManagement() {
  // タスク削除後のフォーカス移動
  document.addEventListener('task:deleted', (e) => {
    const taskElement = e.detail.element;
    const nextElement = taskElement.nextElementSibling || taskElement.previousElementSibling;
    if (nextElement) {
      nextElement.focus();
    } else {
      document.getElementById('create-task-btn')?.focus();
    }
  });

  // モーダル表示時のフォーカストラップ
  document.addEventListener('modal:open', (e) => {
    const modal = e.detail.modal;
    setModalFocusTrap(modal);
  });

  // Escape キーでモーダルを閉じる
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      const openModal = document.querySelector('.modal:not([style*="display: none"])');
      if (openModal && typeof closeModal === 'function') {
        closeModal();
      }
    }
  });
}

/**
 * モーダルにフォーカストラップを設定
 */
function setModalFocusTrap(modal) {
  const focusableElements = modal.querySelectorAll(
    'a, button, input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );
  const firstFocusableElement = focusableElements[0];
  const lastFocusableElement = focusableElements[focusableElements.length - 1];

  firstFocusableElement?.focus();

  modal.addEventListener('keydown', (e) => {
    if (e.key !== 'Tab') return;

    if (e.shiftKey) {
      if (document.activeElement === firstFocusableElement) {
        lastFocusableElement?.focus();
        e.preventDefault();
      }
    } else {
      if (document.activeElement === lastFocusableElement) {
        firstFocusableElement?.focus();
        e.preventDefault();
      }
    }
  });
}

/**
 * スクリーンリーダー向けのライブリージョン通知
 */
function announceToScreenReader(message, priority = 'polite') {
  let liveRegion = document.getElementById('sr-live-region');

  if (!liveRegion) {
    liveRegion = document.createElement('div');
    liveRegion.id = 'sr-live-region';
    liveRegion.setAttribute('aria-live', priority);
    liveRegion.setAttribute('aria-atomic', 'true');
    liveRegion.style.position = 'absolute';
    liveRegion.style.left = '-10000px';
    liveRegion.style.width = '1px';
    liveRegion.style.height = '1px';
    liveRegion.style.overflow = 'hidden';
    document.body.appendChild(liveRegion);
  }

  liveRegion.setAttribute('aria-live', priority);
  liveRegion.textContent = message;

  // 内容をクリア（次の通知に備えて）
  setTimeout(() => {
    liveRegion.textContent = '';
  }, 3000);
}

/**
 * コントラスト比の改善状態をチェック
 */
function checkContrastRatio() {
  const style = window.getComputedStyle(document.body);
  const bgColor = style.backgroundColor;
  const textColor = style.color;

  // コントラスト比を計算（簡易版）
  const ratio = calculateContrast(bgColor, textColor);
  console.log(`Current contrast ratio: ${ratio.toFixed(2)}`);

  // WCAG AA 基準（4.5:1）をチェック
  if (ratio < 4.5) {
    console.warn('⚠️ コントラスト比が WCAG AA 基準を満たしていません');
  }
}

/**
 * RGB 色からコントラスト比を計算
 */
function calculateContrast(color1, color2) {
  const rgb1 = parseColor(color1);
  const rgb2 = parseColor(color2);

  const lum1 = getLuminance(rgb1);
  const lum2 = getLuminance(rgb2);

  const lighter = Math.max(lum1, lum2);
  const darker = Math.min(lum1, lum2);

  return (lighter + 0.05) / (darker + 0.05);
}

/**
 * 色をパース
 */
function parseColor(color) {
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = 1;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = color;
  ctx.fillRect(0, 0, 1, 1);
  const imageData = ctx.getImageData(0, 0, 1, 1);
  return imageData.data.slice(0, 3);
}

/**
 * 相対輝度を計算
 */
function getLuminance([r, g, b]) {
  const [rs, gs, bs] = [r, g, b].map(val => {
    val = val / 255;
    return val <= 0.03928
      ? val / 12.92
      : Math.pow((val + 0.055) / 1.055, 2.4);
  });

  return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
}

/**
 * ハイコントラストモードの対応チェック
 */
function checkHighContrastMode() {
  const isHighContrast = window.matchMedia('(prefers-contrast: more)').matches;
  if (isHighContrast) {
    document.documentElement.classList.add('high-contrast-mode');
    console.log('✅ ハイコントラストモード対応');
  }
}

/**
 * フォントサイズの最小値チェック
 */
function checkMinFontSize() {
  const minFontSize = 14; // px
  const elements = document.querySelectorAll('*');

  let violatingElements = 0;
  elements.forEach(el => {
    const fontSize = parseFloat(window.getComputedStyle(el).fontSize);
    if (fontSize < minFontSize && el.textContent.trim().length > 0) {
      violatingElements++;
      if (violatingElements <= 5) {
        console.warn(`フォントサイズが小さすぎます: ${fontSize}px`, el);
      }
    }
  });

  if (violatingElements > 0) {
    console.warn(`⚠️ 最小フォントサイズ未満の要素: ${violatingElements}個`);
  }
}

/**
 * タップ領域の最小サイズチェック
 */
function checkTapTargetSize() {
  const minSize = 44; // px
  const buttons = document.querySelectorAll('button, a, [role="button"]');

  let violatingButtons = 0;
  buttons.forEach(btn => {
    const rect = btn.getBoundingClientRect();
    if (rect.width < minSize || rect.height < minSize) {
      violatingButtons++;
    }
  });

  if (violatingButtons > 0) {
    console.warn(`⚠️ タップ領域が小さすぎるボタン: ${violatingButtons}個`);
  }
}

/**
 * 日付を ARIA 向けに整形
 */
function formatDateForAria(dateStr) {
  if (!dateStr) return '未設定';
  const date = new Date(dateStr);
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const dayName = ['日', '月', '火', '水', '木', '金', '土'][date.getDay()];
  return `${year}年${month}月${day}日（${dayName}）`;
}

/**
 * キーボードナビゲーションの初期化
 */
function initializeKeyboardNavigation() {
  // Tab キーでの移動をサポート
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Tab') {
      // 通常の tab 動作を続行
      // ここに特別なキーボード処理を追加可能
    }

    // Enter キーでのアクティベート
    if (e.key === 'Enter') {
      const activeElement = document.activeElement;
      if (activeElement?.tagName === 'DIV' && activeElement?.getAttribute('role') === 'button') {
        activeElement.click();
      }
    }

    // Space キーでのチェック/アンチェック
    if (e.key === ' ' && document.activeElement?.type === 'checkbox') {
      document.activeElement.click();
      e.preventDefault();
    }
  });
}

/**
 * 初期化関数
 */
function initAccessibility() {
  console.log('Initializing accessibility features...');

  initializeAriaLabels();
  initializeFocusManagement();
  checkHighContrastMode();
  initializeKeyboardNavigation();

  // デバッグモードでのチェック
  if (localStorage.getItem('debugMode') === 'true') {
    checkContrastRatio();
    checkMinFontSize();
    checkTapTargetSize();
  }

  console.log('✅ Accessibility features initialized');
}

// ページロード時に初期化
document.addEventListener('DOMContentLoaded', initAccessibility);

// 動的に追加された要素への対応
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initAccessibility);
} else {
  initAccessibility();
}

// 動的に追加されたタスク項目に ARIA 属性を設定
const originalRenderTasks = window.renderTasks;
if (typeof originalRenderTasks === 'function') {
  window.renderTasks = function(...args) {
    const result = originalRenderTasks.apply(this, args);

    // 新しく追加されたタスク項目に ARIA を適用
    document.querySelectorAll('.task-item:not([aria-label])').forEach(element => {
      const taskId = element.dataset.taskId;
      const tasks = getTasks?.();
      const task = tasks?.find(t => t.id === taskId);
      if (task) {
        setTaskItemAriaAttributes(element, task);
      }
    });

    return result;
  };
}
```

### analytics.js

```javascript
// ========================================
// データ分析機能
// ========================================

/**
 * タスクランキングを取得（完了したタスクをtotalTimeまたはdurationでソート）
 * @returns {Array} TOP5のタスクリスト
 */
function getTaskRanking() {
  const tasks = getTasks();

  // 完了したタスクのみを抽出し、totalTimeまたはdurationでソート
  const completedTasks = tasks
    .filter(task => {
      if (!task.isCompleted) return false;
      // ランキングから除外されているタスクは含めない
      if (task.excludeFromRanking) return false;
      // totalTimeまたはdurationがある場合のみ含める
      return (task.totalTime && task.totalTime > 0) || (task.duration && task.duration > 0);
    })
    .map(task => {
      // totalTimeを秒単位、durationを分単位から秒単位に変換
      const timeInSeconds = task.totalTime || (task.duration * 60) || 0;
      return { ...task, timeInSeconds };
    })
    .sort((a, b) => b.timeInSeconds - a.timeInSeconds)
    .slice(0, 5); // TOP5のみ

  return completedTasks;
}

/**
 * タスクランキングをHTMLに描画
 */
function renderTaskRanking() {
  const ranking = getTaskRanking();
  const container = document.getElementById('task-ranking-list');

  if (!container) return;

  // ランキングが空の場合
  if (!ranking || ranking.length === 0) {
    container.innerHTML = '<div class="empty-analytics">まだ完了したタスクがありません</div>';
    return;
  }

  // ランキングを描画
  container.innerHTML = ranking.map((task, index) => {
    const position = index + 1;
    let positionClass = '';
    let medal = '';

    if (position === 1) {
      positionClass = 'gold';
      medal = '🥇';
    } else if (position === 2) {
      positionClass = 'silver';
      medal = '🥈';
    } else if (position === 3) {
      positionClass = 'bronze';
      medal = '🥉';
    }

    // timeInSecondsを使用して時間を計算
    const hours = Math.floor(task.timeInSeconds / 3600);
    const minutes = Math.floor((task.timeInSeconds % 3600) / 60);
    const timeText = hours > 0 ? `${hours}時間${minutes}分` : `${minutes}分`;

    return `
      <div class="ranking-item">
        <div class="ranking-position ${positionClass}">${medal || position}</div>
        <div class="ranking-info">
          <div class="ranking-task-name">${escapeHtml(task.title)}</div>
        </div>
        <div class="ranking-time">${timeText}</div>
        <button class="ranking-exclude-btn" data-task-id="${task.id}" title="ランキングから除外">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
    `;
  }).join('');

  // 除外ボタンのイベントリスナーを追加
  const excludeBtns = container.querySelectorAll('.ranking-exclude-btn');
  excludeBtns.forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const taskId = btn.dataset.taskId;
      toggleTaskRankingExclusion(taskId);
      renderTaskRanking(); // ランキングを再描画
    });
  });
}

/**
 * 毎日の空き時間を記録
 * @param {number} freeMinutes - 空き時間（分）
 */
function recordDailyFreeTime(freeMinutes) {
  const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD形式

  // localStorageから既存のデータを取得
  const storedData = localStorage.getItem('nowtask_daily_free_time');
  const data = storedData ? JSON.parse(storedData) : {};

  // 今日のデータを更新
  data[today] = freeMinutes;

  // localStorageに保存
  localStorage.setItem('nowtask_daily_free_time', JSON.stringify(data));
}

/**
 * 指定期間の平均空き時間を計算
 * @param {number} days - 過去何日分を計算するか
 * @returns {number} 平均空き時間（分）
 */
function calculateAverageFreeTime(days) {
  const storedData = localStorage.getItem('nowtask_daily_free_time');
  if (!storedData) return 0;

  let data;
  try {
    data = JSON.parse(storedData);
  } catch (e) {
    console.warn('Failed to parse free time data in calculateAverageFreeTime:', e);
    return 0;
  }

  const dates = Object.keys(data).sort().reverse(); // 新しい順にソート

  if (dates.length === 0) return 0;

  // 指定日数分のデータを取得
  const targetDates = dates.slice(0, days);
  const sum = targetDates.reduce((acc, date) => acc + data[date], 0);

  return targetDates.length > 0 ? Math.round(sum / targetDates.length) : 0;
}

/**
 * 空き時間統計を描画
 */
function renderFreeTimeStats() {
  const container = document.getElementById('free-time-stats');
  if (!container) return;

  const storedData = localStorage.getItem('nowtask_daily_free_time');

  // データが存在しない場合
  if (!storedData) {
    container.innerHTML = '<div class="empty-analytics">まだ空き時間のデータがありません</div>';
    return;
  }

  let data;
  try {
    data = JSON.parse(storedData);
  } catch (e) {
    console.warn('Failed to parse free time data:', e);
    container.innerHTML = '<div class="empty-analytics">データの読み込みに失敗しました</div>';
    return;
  }
  const today = new Date().toISOString().split('T')[0];
  const todayFreeTime = data[today] || 0;

  const avg7Days = calculateAverageFreeTime(7);
  const avg30Days = calculateAverageFreeTime(30);
  const allDates = Object.keys(data);
  const avgAllTime = allDates.length > 0
    ? Math.round(Object.values(data).reduce((a, b) => a + b, 0) / allDates.length)
    : 0;

  // 時間と分に変換するヘルパー関数
  const formatTime = (minutes) => {
    const h = Math.floor(minutes / 60);
    const m = minutes % 60;
    return { hours: h, minutes: m };
  };

  const avg7Time = formatTime(avg7Days);
  const avg30Time = formatTime(avg30Days);
  const avgAllTimeFormatted = formatTime(avgAllTime);

  container.innerHTML = `
    <div class="stat-card">
      <div class="stat-label">7日間平均</div>
      <div>
        <span class="stat-value">${avg7Time.hours}</span>
        <span class="stat-unit">時間</span>
        <span class="stat-value">${avg7Time.minutes}</span>
        <span class="stat-unit">分</span>
      </div>
    </div>
    <div class="stat-card">
      <div class="stat-label">30日間平均</div>
      <div>
        <span class="stat-value">${avg30Time.hours}</span>
        <span class="stat-unit">時間</span>
        <span class="stat-value">${avg30Time.minutes}</span>
        <span class="stat-unit">分</span>
      </div>
    </div>
    <div class="stat-card">
      <div class="stat-label">全期間平均</div>
      <div>
        <span class="stat-value">${avgAllTimeFormatted.hours}</span>
        <span class="stat-unit">時間</span>
        <span class="stat-value">${avgAllTimeFormatted.minutes}</span>
        <span class="stat-unit">分</span>
      </div>
    </div>
  `;
}

/**
 * 月次空き時間データを計算
 * @returns {Object} { months: ['1月', '2月', ...], data: [平均分, ...], yearTotal: 年間総空き時間 }
 */
function calculateMonthlyFreeTime() {
  const storedData = localStorage.getItem('nowtask_daily_free_time');
  if (!storedData) return { months: [], data: [], yearTotal: 0 };

  let data;
  try {
    data = JSON.parse(storedData);
  } catch (e) {
    console.warn('Failed to parse daily free time data:', e);
    return { months: [], data: [], yearTotal: 0 };
  }
  const now = new Date();
  const currentYear = now.getFullYear();

  // 過去12ヶ月のデータを集計
  const monthlyData = {};
  const monthLabels = [];

  for (let i = 11; i >= 0; i--) {
    const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const key = `${year}-${month}`;
    const label = `${month}月`;

    monthLabels.push(label);
    monthlyData[key] = { sum: 0, count: 0, year, month };
  }

  // 日次データを月次に集計
  Object.keys(data).forEach(dateStr => {
    const [year, month, day] = dateStr.split('-').map(Number);
    const key = `${year}-${month}`;

    if (monthlyData[key]) {
      monthlyData[key].sum += data[dateStr];
      monthlyData[key].count += 1;
    }
  });

  // 月平均を計算
  const monthlyAverages = monthLabels.map((label, index) => {
    const date = new Date(now.getFullYear(), now.getMonth() - 11 + index, 1);
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const key = `${year}-${month}`;
    const monthData = monthlyData[key];

    if (monthData.count === 0) return 0;
    return Math.round(monthData.sum / monthData.count);
  });

  // 年間総空き時間を計算（今年のデータのみ）
  let yearTotal = 0;
  Object.keys(data).forEach(dateStr => {
    const [year] = dateStr.split('-').map(Number);
    if (year === currentYear) {
      yearTotal += data[dateStr];
    }
  });

  return {
    months: monthLabels,
    data: monthlyAverages,
    yearTotal: yearTotal
  };
}

/**
 * 年間空き時間分析を描画
 */
function renderYearlyFreeTime() {
  const container = document.getElementById('yearly-free-time');
  if (!container) return;

  const result = calculateMonthlyFreeTime();
  if (!result) {
    container.innerHTML = '<div class="empty-analytics">データの読み込みに失敗しました</div>';
    return;
  }

  const { months, data, yearTotal } = result;

  // データがない場合
  if (!data || data.length === 0 || data.every(v => v === 0)) {
    container.innerHTML = '<div class="empty-analytics">まだ年間データがありません</div>';
    return;
  }

  // 最大値を取得（グラフの高さ調整用）
  const maxValue = Math.max(...data, 1);

  // 年間統計
  const yearHours = Math.floor(yearTotal / 60);
  const yearMinutes = yearTotal % 60;
  const avgPerDay = data.reduce((a, b) => a + b, 0) / data.length;
  const avgDayHours = Math.floor(avgPerDay / 60);
  const avgDayMinutes = Math.round(avgPerDay % 60);

  // グラフとして描画
  const bars = months.map((month, index) => {
    const value = data[index];
    const height = maxValue > 0 ? (value / maxValue) * 100 : 0;
    const hours = Math.floor(value / 60);
    const minutes = value % 60;
    const timeText = hours > 0 ? `${hours}h${minutes}m` : `${minutes}m`;

    return `
      <div class="chart-bar-container">
        <div class="chart-bar-wrapper">
          <div class="chart-bar" style="height: ${height}%;" title="${month}: ${timeText}">
            <span class="chart-bar-label">${timeText}</span>
          </div>
        </div>
        <div class="chart-month-label">${month}</div>
      </div>
    `;
  }).join('');

  container.innerHTML = `
    <div class="yearly-stats">
      <div class="stat-card">
        <div class="stat-label">今年の総空き時間</div>
        <div>
          <span class="stat-value">${yearHours}</span>
          <span class="stat-unit">時間</span>
          <span class="stat-value">${yearMinutes}</span>
          <span class="stat-unit">分</span>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-label">1日平均</div>
        <div>
          <span class="stat-value">${avgDayHours}</span>
          <span class="stat-unit">時間</span>
          <span class="stat-value">${avgDayMinutes}</span>
          <span class="stat-unit">分</span>
        </div>
      </div>
    </div>
    <div class="chart-container">
      <div class="chart-title">月平均空き時間（過去12ヶ月）</div>
      <div class="chart-bars">
        ${bars}
      </div>
    </div>
  `;
}

/**
 * 分析モーダルを開く
 */
function openAnalyticsModal() {
  const modal = document.getElementById('analytics-modal');
  if (!modal) return;

  // データを描画
  renderTaskRanking();
  renderFreeTimeStats();
  renderYearlyFreeTime();

  // モーダルを表示
  modal.style.display = 'flex';
  modal.classList.add('show');
}

/**
 * 分析モーダルを閉じる
 */
function closeAnalyticsModal() {
  const modal = document.getElementById('analytics-modal');
  if (!modal) return;

  modal.style.display = 'none';
  modal.classList.remove('show');
}

/**
 * HTMLエスケープ
 */
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

/**
 * タスクのランキング除外状態を切り替え
 * @param {string} taskId - タスクID
 */
function toggleTaskRankingExclusion(taskId) {
  const tasks = getTasks();
  const task = tasks.find(t => t.id === taskId);

  if (!task) return;

  // 除外フラグを切り替え（未設定の場合はfalseとして扱う）
  task.excludeFromRanking = !task.excludeFromRanking;

  // 更新日時を設定
  task.updatedAt = new Date().toISOString();

  // タスクを保存
  saveTasks(tasks);
}
```

### animations.js

```javascript
// ========================================
// アニメーションとビジュアルフィードバック
// ========================================

/**
 * モーダルアニメーションの初期化
 */
function initModalAnimations() {
  // 全てのモーダルにフェードイン/アウトアニメーションを適用
  const modals = document.querySelectorAll('.modal');

  modals.forEach(modal => {
    // モーダルが表示されるときのアニメーション
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'style') {
          const display = window.getComputedStyle(modal).display;

          if (display === 'flex' && !modal.classList.contains('modal-show')) {
            // フェードイン開始
            modal.classList.add('modal-show');
            const content = modal.querySelector('.modal-content');
            if (content) {
              content.classList.add('modal-slide-up');
            }
          } else if (display === 'none' && modal.classList.contains('modal-show')) {
            // フェードアウト完了後にクラスを削除
            modal.classList.remove('modal-show');
            const content = modal.querySelector('.modal-content');
            if (content) {
              content.classList.remove('modal-slide-up');
            }
          }
        }
      });
    });

    observer.observe(modal, { attributes: true, attributeFilter: ['style'] });
  });
}

/**
 * モーダルを滑らかに開く
 */
function openModalWithAnimation(modalId) {
  const modal = document.getElementById(modalId);
  if (!modal) return;

  modal.style.display = 'flex';
  // 次のフレームでアニメーションを開始（リフロー強制）
  requestAnimationFrame(() => {
    modal.classList.add('modal-show');
    const content = modal.querySelector('.modal-content');
    if (content) {
      content.classList.add('modal-slide-up');
    }
  });
}

/**
 * モーダルを滑らかに閉じる
 */
function closeModalWithAnimation(modalId, callback) {
  const modal = document.getElementById(modalId);
  if (!modal) return;

  modal.classList.remove('modal-show');
  const content = modal.querySelector('.modal-content');
  if (content) {
    content.classList.remove('modal-slide-up');
  }

  // アニメーション完了後に非表示
  setTimeout(() => {
    modal.style.display = 'none';
    if (callback) callback();
  }, 200);
}

/**
 * タスク追加時のアニメーション
 */
function animateTaskAdd(taskElement) {
  if (!taskElement) return;

  // 初期状態を設定
  taskElement.style.opacity = '0';
  taskElement.style.transform = 'translateY(-20px)';

  // 次のフレームでアニメーション開始
  requestAnimationFrame(() => {
    taskElement.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
    taskElement.style.opacity = '1';
    taskElement.style.transform = 'translateY(0)';
  });

  // アニメーション完了後にスタイルをクリア
  setTimeout(() => {
    taskElement.style.transition = '';
    taskElement.style.opacity = '';
    taskElement.style.transform = '';
  }, 300);
}

/**
 * タスク削除時のアニメーション
 */
function animateTaskRemove(taskElement, callback) {
  if (!taskElement) {
    if (callback) callback();
    return;
  }

  // フェードアウト + スライドアウト
  taskElement.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, max-height 0.3s ease-out';
  taskElement.style.opacity = '0';
  taskElement.style.transform = 'translateX(-20px)';
  taskElement.style.maxHeight = '0';
  taskElement.style.marginBottom = '0';
  taskElement.style.overflow = 'hidden';

  setTimeout(() => {
    if (callback) callback();
  }, 300);
}

/**
 * チェックボックスのアニメーション
 */
function animateCheckbox(checkbox) {
  if (!checkbox) return;

  // チェック時のバウンス効果
  checkbox.style.transition = 'transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
  checkbox.style.transform = 'scale(1.2)';

  setTimeout(() => {
    checkbox.style.transform = 'scale(1)';
  }, 200);

  // バイブレーションフィードバック
  if (navigator.vibrate) {
    navigator.vibrate(10);
  }
}

/**
 * 完了タスクの打ち消し線アニメーション
 */
function animateTaskComplete(taskElement, isCompleted) {
  if (!taskElement) return;

  const title = taskElement.querySelector('.task-title');
  if (!title) return;

  if (isCompleted) {
    // 打ち消し線を徐々に表示
    title.style.transition = 'opacity 0.3s ease-out';
    title.style.opacity = '0.6';

    // バイブレーションフィードバック
    if (navigator.vibrate) {
      navigator.vibrate(20);
    }
  } else {
    // 打ち消し線を除去
    title.style.transition = 'opacity 0.3s ease-out';
    title.style.opacity = '1';
  }
}

/**
 * FABボタンのアニメーション
 */
function animateFAB() {
  const fab = document.getElementById('create-task-btn');
  if (!fab) return;

  // タップ時の拡大効果
  fab.addEventListener('click', () => {
    fab.style.transition = 'transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
    fab.style.transform = 'scale(0.9) rotate(90deg)';

    setTimeout(() => {
      fab.style.transform = 'scale(1) rotate(0deg)';
    }, 200);
  });

  // ホバー時の浮き上がり効果（PC用）
  fab.addEventListener('mouseenter', () => {
    fab.style.transition = 'transform 0.2s ease-out, box-shadow 0.2s ease-out';
    fab.style.transform = 'translateY(-4px)';
    fab.style.boxShadow = '0 8px 16px rgba(0, 0, 0, 0.3)';
  });

  fab.addEventListener('mouseleave', () => {
    fab.style.transform = 'translateY(0)';
    fab.style.boxShadow = '';
  });
}

/**
 * リップルエフェクトの追加
 */
function addRippleEffect(element, event) {
  const ripple = document.createElement('span');
  ripple.className = 'ripple';

  const rect = element.getBoundingClientRect();
  const size = Math.max(rect.width, rect.height);
  const x = event.clientX - rect.left - size / 2;
  const y = event.clientY - rect.top - size / 2;

  ripple.style.width = ripple.style.height = size + 'px';
  ripple.style.left = x + 'px';
  ripple.style.top = y + 'px';

  element.appendChild(ripple);

  setTimeout(() => {
    ripple.remove();
  }, 600);
}

/**
 * ボタンにリップルエフェクトを適用
 */
function initRippleEffects() {
  // 全てのボタンにリップルエフェクトを追加
  const buttons = document.querySelectorAll('.btn, .fab, .task-menu-btn, .bulk-action-btn-with-label');

  buttons.forEach(button => {
    button.style.position = 'relative';
    button.style.overflow = 'hidden';

    button.addEventListener('click', (e) => {
      addRippleEffect(button, e);
    });
  });
}

/**
 * 24時間ゲージのアニメーション初期化
 */
function initGaugeAnimations() {
  const gaugeElapsed = document.getElementById('time-gauge-elapsed');
  const gaugeScheduled = document.getElementById('time-gauge-scheduled');
  const gaugeFree = document.getElementById('time-gauge-free');
  const timeMarker = document.getElementById('time-marker');

  // スムーズなトランジションを追加
  if (gaugeElapsed) {
    gaugeElapsed.style.transition = 'width 0.5s ease-out, background-color 0.3s ease-out';
  }
  if (gaugeScheduled) {
    gaugeScheduled.style.transition = 'width 0.5s ease-out, left 0.5s ease-out, background-color 0.3s ease-out';
  }
  if (gaugeFree) {
    gaugeFree.style.transition = 'width 0.5s ease-out, left 0.5s ease-out, background-color 0.3s ease-out';
  }
  if (timeMarker) {
    timeMarker.style.transition = 'left 1s ease-out';
  }
}

/**
 * ゲージ更新時のアニメーション
 */
function animateGaugeUpdate() {
  const gaugeElapsed = document.getElementById('time-gauge-elapsed');
  const gaugeScheduled = document.getElementById('time-gauge-scheduled');
  const gaugeFree = document.getElementById('time-gauge-free');

  // 短いパルスアニメーション
  [gaugeElapsed, gaugeScheduled, gaugeFree].forEach(element => {
    if (!element) return;

    element.style.transition = 'transform 0.2s ease-out';
    element.style.transform = 'scaleY(1.05)';

    setTimeout(() => {
      element.style.transform = 'scaleY(1)';
    }, 200);
  });
}

/**
 * トースト通知の表示
 */
function showToast(message, duration = 3000, type = 'info') {
  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;
  toast.textContent = message;

  document.body.appendChild(toast);

  // 次のフレームで表示アニメーション
  requestAnimationFrame(() => {
    toast.classList.add('toast-show');
  });

  // 指定時間後に非表示
  setTimeout(() => {
    toast.classList.remove('toast-show');
    setTimeout(() => {
      toast.remove();
    }, 300);
  }, duration);
}

/**
 * ローディングスピナーの表示
 */
function showLoadingSpinner(message = '読み込み中...') {
  const spinner = document.createElement('div');
  spinner.id = 'loading-spinner';
  spinner.className = 'loading-spinner';
  spinner.innerHTML = `
    <div class="spinner-container">
      <div class="spinner"></div>
      <p>${message}</p>
    </div>
  `;

  document.body.appendChild(spinner);

  requestAnimationFrame(() => {
    spinner.classList.add('spinner-show');
  });
}

/**
 * ローディングスピナーの非表示
 */
function hideLoadingSpinner() {
  const spinner = document.getElementById('loading-spinner');
  if (!spinner) return;

  spinner.classList.remove('spinner-show');
  setTimeout(() => {
    spinner.remove();
  }, 300);
}

/**
 * アニメーション機能の初期化
 */
function initAnimations() {
  console.log('Initializing animations...');

  // 各種アニメーションの初期化
  initModalAnimations();
  animateFAB();
  initRippleEffects();
  initGaugeAnimations();

  console.log('Animations initialized');
}

// DOMロード後に初期化
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initAnimations);
} else {
  initAnimations();
}
```

### auth.js

```javascript
/**
 * ========================================
 * 認証関連のUIロジック
 * ========================================
 */

// DOM要素
const loginModal = document.getElementById('login-modal');
const mainContent = document.querySelector('.main-content');
const fab = document.getElementById('create-task-btn');
const googleLoginBtn = document.getElementById('google-login-btn');
const twitterLoginBtn = document.getElementById('twitter-login-btn');
const headerLoginBtn = document.getElementById('login-icon-btn');

/**
 * 認証状態をチェックしてUIを切り替える
 */
async function checkLoginState() {
    if (typeof FirestoreBridge === 'undefined' || typeof AndroidAuth === 'undefined') {
        console.log("Waiting for Android bridges to be available...");
        setTimeout(checkLoginState, 200);
        return;
    }

    try {
        const userId = FirestoreBridge.getUserId();

        if (userId && userId !== 'anonymous') {
            // ログイン済み: データを読み込んでからアプリを起動
            console.log("User is logged in (Google account). Loading initial data...");
            loadInitialData(startApp);
        } else {
            // 匿名ユーザー: アプリを起動（ログインは任意）
            console.log("User is anonymous. Starting app anyway...");
            loadInitialData(startApp);
        }
    } catch (e) {
        console.error("Error checking login state:", e);
        // エラーが発生してもアプリを起動
        loadInitialData(startApp);
    }
}

/**
 * ログイン画面を表示
 */
function showLogin() {
    console.log("=== showLogin called ===");
    if (!loginModal) {
        console.error("loginModal element not found!");
        return;
    }

    // ログイン状態に応じてモーダルの内容を切り替え
    updateLoginModal();

    loginModal.style.display = 'flex';
    if (mainContent) mainContent.style.display = 'none';
    if (fab) fab.style.display = 'none';
    console.log("Login modal displayed, main content hidden");
}

/**
 * ログインモーダルの内容を更新
 */
function updateLoginModal() {
    console.log("updateLoginModal called");
    if (typeof FirestoreBridge === 'undefined') {
        console.log("FirestoreBridge is undefined, skipping modal update");
        return;
    }

    const isAnon = FirestoreBridge.isAnonymous();
    console.log("User is anonymous:", isAnon);

    const loginFormSection = document.getElementById('login-form-section');
    const accountInfoSection = document.getElementById('account-info-section');
    const modalTitle = document.getElementById('login-modal-title');

    console.log("Modal elements found:", {
        loginFormSection: !!loginFormSection,
        accountInfoSection: !!accountInfoSection,
        modalTitle: !!modalTitle
    });

    if (isAnon) {
        // 匿名ユーザー: ログインフォームを表示
        console.log("Showing login form for anonymous user");
        if (loginFormSection) loginFormSection.style.display = 'block';
        if (accountInfoSection) accountInfoSection.style.display = 'none';
        if (modalTitle) modalTitle.textContent = 'ログイン';
    } else {
        // ログイン済みユーザー: アカウント情報を表示
        console.log("Showing account info for logged-in user");
        if (loginFormSection) loginFormSection.style.display = 'none';
        if (accountInfoSection) accountInfoSection.style.display = 'block';
        if (modalTitle) modalTitle.textContent = 'アカウント';

        // アカウント情報を取得して表示
        const displayName = FirestoreBridge.getUserDisplayName();
        const email = FirestoreBridge.getUserEmail();
        console.log("Account info:", { displayName, email });

        const displayNameEl = document.getElementById('account-display-name');
        const emailEl = document.getElementById('account-email');
        const statusEl = document.getElementById('account-status');

        console.log("Account info elements found:", {
            displayNameEl: !!displayNameEl,
            emailEl: !!emailEl,
            statusEl: !!statusEl
        });

        if (displayNameEl) displayNameEl.textContent = displayName;
        if (emailEl) emailEl.textContent = email || 'メールアドレス未設定';
        if (statusEl) statusEl.textContent = 'Googleアカウントでログイン済み';
    }
}

/**
 * メインアプリ画面を表示
 */
function showMainApp() {
    console.log("=== showMainApp called ===");
    console.log("loginModal:", loginModal, "mainContent:", mainContent, "fab:", fab);

    if (loginModal) {
        loginModal.style.display = 'none';
        console.log("Login modal hidden");
    }
    if (mainContent) {
        mainContent.style.display = 'block';
        console.log("Main content displayed");
    }
    if (fab) {
        fab.style.display = 'flex';
        console.log("FAB displayed");
    }
    console.log("=== showMainApp completed ===");
}

// イベントリスナーが既に初期化されたかのフラグ
let authListenersInitialized = false;

/**
 * 認証関連のイベントリスナーを初期化
 */
function initAuthEventListeners() {
    // 既に初期化済みなら何もしない
    if (authListenersInitialized) {
        console.log("Auth event listeners already initialized, skipping");
        return;
    }

    console.log("Initializing auth event listeners");
    authListenersInitialized = true;

    if (googleLoginBtn) {
        googleLoginBtn.addEventListener('click', () => {
            if (googleLoginBtn.disabled) {
                console.log("Google login already in progress, ignoring click");
                return;
            }

            googleLoginBtn.disabled = true;
            console.log("Google login button clicked, calling AndroidAuth.signInWithGoogle()");

            if (typeof AndroidAuth !== 'undefined') {
                AndroidAuth.signInWithGoogle();
            }

            // ボタンを5秒後に再有効化（認証が失敗した場合のため）
            setTimeout(() => {
                googleLoginBtn.disabled = false;
                console.log("Google login button re-enabled");
            }, 5000);
        });
    }

    if (twitterLoginBtn) {
        twitterLoginBtn.addEventListener('click', () => {
            if (twitterLoginBtn.disabled) return;

            twitterLoginBtn.disabled = true;

            if (typeof AndroidAuth !== 'undefined') {
                AndroidAuth.signInWithTwitter();
            }

            setTimeout(() => {
                twitterLoginBtn.disabled = false;
            }, 5000);
        });
    }

    if (headerLoginBtn) {
        headerLoginBtn.addEventListener('click', () => {
            console.log("Login icon button clicked");
            // ログイン状態に関わらず、モーダルを表示
            // モーダル内で匿名ユーザーならログインフォーム、ログイン済みならアカウント情報を表示
            showLogin();
        });
    }

    // ログインモーダルの閉じるボタン
    const closeLoginBtn = document.getElementById('close-login-btn');
    if (closeLoginBtn) {
        closeLoginBtn.addEventListener('click', () => {
            showMainApp();
        });
    }

    // 匿名のまま使い続けるボタン
    const continueAnonymousBtn = document.getElementById('continue-anonymous-btn');
    if (continueAnonymousBtn) {
        continueAnonymousBtn.addEventListener('click', () => {
            showMainApp();
        });
    }

    // ログアウトボタン
    const logoutBtn = document.getElementById('logout-btn');
    if (logoutBtn) {
        logoutBtn.addEventListener('click', () => {
            // ログインモーダルを先に閉じる
            if (loginModal) loginModal.style.display = 'none';

            // 確認ダイアログを表示
            confirmAction('ログアウトしますか？\n\n匿名モードに戻ります。\nログアウト後もデータはクラウドに保存されており、次回ログイン時に復元できます。', () => {
                if (typeof AndroidAuth !== 'undefined') {
                    AndroidAuth.signOut();
                }
            });
        });
    }
}

/**
 * 認証機能の初期化
 */
function initAuth() {
    initAuthEventListeners();
    checkLoginState();
}

// グローバルスコープに関数を公開（ネイティブからのコールバック用）
window.onAuthSuccess = function() {
    console.log("=== onAuthSuccess called ===");

    // ログインボタンを再有効化
    if (googleLoginBtn) googleLoginBtn.disabled = false;
    if (twitterLoginBtn) twitterLoginBtn.disabled = false;

    try {
        console.log("Starting loadInitialData...");
        // データを再読み込み
        loadInitialData(() => {
            console.log("Data reloaded after authentication.");
            console.log("appData.nowtask_tasks:", window.appData['nowtask_tasks']);
            console.log("Number of tasks:", window.appData['nowtask_tasks'] ? window.appData['nowtask_tasks'].length : 0);

            console.log("Calling renderTasks()...");
            renderTasks();
            console.log("renderTasks() completed.");

            // モーダルを閉じてメインアプリを表示
            console.log("Calling showMainApp()...");
            showMainApp();
            console.log("showMainApp() completed.");

            console.log("=== UI updated successfully after authentication ===");
        });
    } catch (e) {
        console.error("Error in onAuthSuccess:", e);
        // エラーが発生してもアプリは使えるようにする
        showMainApp();
    }
}

window.onAuthCanceled = function() {
    console.log("Authentication was canceled or failed, re-enabling login buttons.");

    // ログインボタンを再有効化
    if (googleLoginBtn) googleLoginBtn.disabled = false;
    if (twitterLoginBtn) twitterLoginBtn.disabled = false;
}

window.onAuthSignOut = function() {
    console.log("=== onAuthSignOut called ===");

    try {
        console.log("Starting loadInitialData for anonymous user...");
        // データを再読み込み（匿名ユーザーのデータを読み込む）
        loadInitialData(() => {
            console.log("Data reloaded after sign out.");
            console.log("appData.nowtask_tasks:", window.appData['nowtask_tasks']);
            console.log("Number of tasks:", window.appData['nowtask_tasks'] ? window.appData['nowtask_tasks'].length : 0);

            console.log("Calling renderTasks()...");
            renderTasks();
            console.log("renderTasks() completed.");

            // モーダルを閉じてメインアプリを表示
            console.log("Calling showMainApp()...");
            showMainApp();
            console.log("showMainApp() completed.");

            console.log("=== UI updated successfully after sign out ===");
        });
    } catch (e) {
        console.error("Error in onAuthSignOut:", e);
        // エラーが発生してもアプリは使えるようにする
        showMainApp();
    }
}
```

### calendar.js

```javascript
// ========================================
// カレンダー機能
// ========================================

let currentCalendarYear = new Date().getFullYear();
let currentCalendarMonth = new Date().getMonth(); // 0-11

/**
 * カレンダーモーダルを開く
 */
function openCalendarModal() {
  const modal = document.getElementById('calendar-modal');
  if (!modal) return;

  // 現在の年月に設定
  const today = new Date();
  currentCalendarYear = today.getFullYear();
  currentCalendarMonth = today.getMonth();

  // カレンダーを描画
  renderCalendar();

  // モーダルを表示
  modal.style.display = 'flex';
  modal.classList.add('show');
}

/**
 * カレンダーモーダルを閉じる
 */
function closeCalendarModal() {
  const modal = document.getElementById('calendar-modal');
  if (!modal) return;

  modal.style.display = 'none';
  modal.classList.remove('show');
}

/**
 * 月次の空き時間統計を計算
 */
function calculateMonthlyFreeTime(year, month) {
  const tasks = getTasks();
  const daysInMonth = new Date(year, month + 1, 0).getDate();

  let totalScheduledMinutes = 0;
  let totalFreeMinutes = 0;
  let daysWithTasks = 0;

  // 各日の空き時間を計算
  for (let day = 1; day <= daysInMonth; day++) {
    const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
    const dateTasks = tasks.filter(task => {
      if (!task.dueDate) return false;
      const taskDate = new Date(task.dueDate);
      const taskDateStr = `${taskDate.getFullYear()}-${String(taskDate.getMonth() + 1).padStart(2, '0')}-${String(taskDate.getDate()).padStart(2, '0')}`;
      return taskDateStr === dateStr;
    });

    if (dateTasks.length > 0) {
      daysWithTasks++;
    }

    // その日のスケジュール時間を計算（重複を考慮）
    const dayTimeSlots = [];
    dateTasks.forEach(task => {
      if (task.startTime && task.endTime) {
        const [startHour, startMin] = task.startTime.split(':').map(Number);
        const [endHour, endMin] = task.endTime.split(':').map(Number);
        const startMinutes = startHour * 60 + startMin;
        let endMinutes = endHour * 60 + endMin;

        // 日をまたぐ場合は24時までとして計算
        if (endMinutes < startMinutes) {
          endMinutes = 24 * 60;
        }

        dayTimeSlots.push({ start: startMinutes, end: endMinutes });
      }
    });

    // タイムスロットを統合（重複を排除）
    let dayScheduledMinutes = 0;
    if (dayTimeSlots.length > 0) {
      dayTimeSlots.sort((a, b) => a.start - b.start);

      const mergedSlots = [dayTimeSlots[0]];
      for (let i = 1; i < dayTimeSlots.length; i++) {
        const current = dayTimeSlots[i];
        const last = mergedSlots[mergedSlots.length - 1];

        if (current.start <= last.end) {
          last.end = Math.max(last.end, current.end);
        } else {
          mergedSlots.push(current);
        }
      }

      dayScheduledMinutes = mergedSlots.reduce((sum, slot) => {
        return sum + (slot.end - slot.start);
      }, 0);
    }

    totalScheduledMinutes += dayScheduledMinutes;
    // 1日24時間から予定時間を引く
    totalFreeMinutes += (24 * 60 - dayScheduledMinutes);
  }

  return {
    totalScheduledMinutes,
    totalFreeMinutes,
    totalScheduledHours: Math.floor(totalScheduledMinutes / 60),
    totalFreeHours: Math.floor(totalFreeMinutes / 60),
    averageFreeHoursPerDay: Math.floor(totalFreeMinutes / daysInMonth / 60),
    daysWithTasks,
    daysInMonth
  };
}

/**
 * カレンダーを描画
 */
function renderCalendar() {
  // 年月表示を更新
  const monthLabel = document.getElementById('calendar-current-month');
  if (monthLabel) {
    monthLabel.textContent = `${currentCalendarYear}年${currentCalendarMonth + 1}月`;
  }

  // カレンダーグリッドを取得
  const grid = document.getElementById('calendar-grid');
  if (!grid) return;

  // 既存の日付セルを削除（曜日ヘッダーは残す）
  const dayCells = grid.querySelectorAll('.calendar-day');
  dayCells.forEach(cell => cell.remove());

  // 月の最初の日と最後の日を取得
  const firstDay = new Date(currentCalendarYear, currentCalendarMonth, 1);
  const lastDay = new Date(currentCalendarYear, currentCalendarMonth + 1, 0);

  // 月の最初の日の曜日（0: 日曜日）
  const firstDayOfWeek = firstDay.getDay();

  // 月の日数
  const daysInMonth = lastDay.getDate();

  // 今日の日付
  const today = new Date();
  const isCurrentMonth = today.getFullYear() === currentCalendarYear && today.getMonth() === currentCalendarMonth;
  const todayDate = today.getDate();

  // タスクデータを取得
  const tasks = getTasks();

  // 前月の空白セルを追加
  for (let i = 0; i < firstDayOfWeek; i++) {
    const emptyCell = document.createElement('div');
    emptyCell.className = 'calendar-day empty';
    grid.appendChild(emptyCell);
  }

  // 日付セルを生成
  for (let day = 1; day <= daysInMonth; day++) {
    const dateCell = document.createElement('div');
    dateCell.className = 'calendar-day';

    // 今日の日付にクラスを追加
    if (isCurrentMonth && day === todayDate) {
      dateCell.classList.add('today');
    }

    // 日付番号
    const dayNumber = document.createElement('div');
    dayNumber.className = 'calendar-day-number';
    dayNumber.textContent = day;
    dateCell.appendChild(dayNumber);

    // その日のタスク数を計算
    const dateStr = `${currentCalendarYear}-${String(currentCalendarMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
    const dateTasks = tasks.filter(task => {
      if (!task.dueDate) return false;
      const taskDate = new Date(task.dueDate);
      const taskDateStr = `${taskDate.getFullYear()}-${String(taskDate.getMonth() + 1).padStart(2, '0')}-${String(taskDate.getDate()).padStart(2, '0')}`;
      return taskDateStr === dateStr;
    });

    // タスク数表示
    if (dateTasks.length > 0) {
      const taskCount = document.createElement('div');
      taskCount.className = 'calendar-task-count';
      taskCount.textContent = `${dateTasks.length}件`;
      dateCell.appendChild(taskCount);

      // 完了・未完了の状態を表示
      const completedCount = dateTasks.filter(t => t.isCompleted).length;
      const incompleteCount = dateTasks.length - completedCount;

      const taskStatus = document.createElement('div');
      taskStatus.className = 'calendar-task-status';
      if (incompleteCount > 0) {
        taskStatus.innerHTML = `<span class="incomplete-dot"></span>${incompleteCount}`;
      }
      if (completedCount > 0) {
        taskStatus.innerHTML += ` <span class="complete-dot"></span>${completedCount}`;
      }
      dateCell.appendChild(taskStatus);
    }

    // クリックイベント: タスクがあればスクロール、なければ新規作成
    const handleDateClick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeCalendarModal();

      // モーダルが完全に閉じるのを待ってから次の処理
      setTimeout(() => {
        if (dateTasks.length > 0) {
          // タスクがある場合はスクロール
          scrollToDate(dateStr);
        } else {
          // タスクがない場合は新規作成モーダルを開く
          if (typeof openCreateModal === 'function') {
            openCreateModal();
            // モーダルが開いた後に日付を設定
            setTimeout(() => {
              const dateInput = document.getElementById('task-due-date');
              if (dateInput) {
                dateInput.value = dateStr;
              }
            }, 100);
          }
        }
      }, 100);
    };

    dateCell.addEventListener('click', handleDateClick);
    dateCell.addEventListener('touchend', handleDateClick);

    grid.appendChild(dateCell);
  }

  // 月次統計を表示
  renderMonthlyStats();
}

/**
 * 月次統計を表示
 */
function renderMonthlyStats() {
  const statsContainer = document.getElementById('calendar-monthly-stats');
  if (!statsContainer) return;

  const stats = calculateMonthlyFreeTime(currentCalendarYear, currentCalendarMonth);

  statsContainer.innerHTML = `
    <div class="monthly-stats-title">📊 ${currentCalendarYear}年${currentCalendarMonth + 1}月の統計</div>
    <div class="monthly-stats-grid">
      <div class="monthly-stat-card">
        <div class="stat-label">予定時間</div>
        <div class="stat-value">${stats.totalScheduledHours}<span class="stat-unit">時間</span></div>
      </div>
      <div class="monthly-stat-card">
        <div class="stat-label">空き時間</div>
        <div class="stat-value">${stats.totalFreeHours}<span class="stat-unit">時間</span></div>
      </div>
      <div class="monthly-stat-card">
        <div class="stat-label">1日平均空き時間</div>
        <div class="stat-value">${stats.averageFreeHoursPerDay}<span class="stat-unit">時間</span></div>
      </div>
      <div class="monthly-stat-card">
        <div class="stat-label">予定がある日</div>
        <div class="stat-value">${stats.daysWithTasks}<span class="stat-unit">/${stats.daysInMonth}日</span></div>
      </div>
    </div>
  `;
}

/**
 * 指定日付のタスクにスクロール
 */
function scrollToDate(dateStr) {
  // date-separatorを探す
  const separators = document.querySelectorAll('.date-separator');
  let targetSeparator = null;

  separators.forEach(sep => {
    if (sep.dataset.date === dateStr) {
      targetSeparator = sep;
    }
  });

  if (targetSeparator) {
    // スムーズスクロール
    targetSeparator.scrollIntoView({ behavior: 'smooth', block: 'start' });
  } else {
    // その日のタスクがない場合はメッセージ
    alert('この日のタスクはありません');
  }
}

/**
 * 前月に移動
 */
function goToPreviousMonth() {
  currentCalendarMonth--;
  if (currentCalendarMonth < 0) {
    currentCalendarMonth = 11;
    currentCalendarYear--;
  }
  renderCalendar();
}

/**
 * 次月に移動
 */
function goToNextMonth() {
  currentCalendarMonth++;
  if (currentCalendarMonth > 11) {
    currentCalendarMonth = 0;
    currentCalendarYear++;
  }
  renderCalendar();
}
```

### core.js

```javascript
// ========================================
// 定数定義
// ========================================
const STORAGE_KEYS = {
  TASKS: 'nowtask_tasks',
  TRASH: 'nowtask_trash',
  SHELVED: 'nowtask_shelved',
  SORT_PREFERENCE: 'nowtask_sort_pref',
  SETTINGS: 'nowtask_settings',
  ROUTINES: 'nowtask_routines'
  // 履歴用キー（最新20件を保存）
  ,TASK_HISTORY: 'nowtask_task_history',
  TEMPLATES: 'nowtask_templates'
};

const TRASH_RETENTION_DAYS = 30;

// ========================================
// グローバル変数
// ========================================
let currentTab = 'tasks';
let editingTaskId = null;
// ========================================
// 履歴管理（クイック入力で使う過去のタスク情報）
// ========================================
// 履歴を取得（配列、最新が先頭）
function getTaskHistory(limit = 20) {
  return loadFromStorage(STORAGE_KEYS.TASK_HISTORY, []).slice(0, limit);
}

// 履歴を丸ごと保存
function saveTaskHistory(list) {
  // 最新が先頭であることを期待する
  const toSave = Array.isArray(list) ? list.slice(0, 20) : [];
  return saveToStorage(STORAGE_KEYS.TASK_HISTORY, toSave);
}

// タスク情報を履歴に追加（重複は削除、最新を先頭に、最大 limit 件）
function addToTaskHistory(title, startTime = null, endTime = null, limit = 20) {
  if (!title || typeof title !== 'string') return false;
  const trimmed = title.trim();
  if (trimmed.length === 0) return false;

  const history = loadFromStorage(STORAGE_KEYS.TASK_HISTORY, []);

  // 既存の同一タイトルエントリを取り除く（大文字小文字を区別しない）
  const normalized = history.filter(item => {
    const itemTitle = typeof item === 'string' ? item : (item.title || '');
    return itemTitle.toLowerCase() !== trimmed.toLowerCase();
  });

  // 新しい履歴エントリ（タイトルと時間情報）
  const newEntry = {
    title: trimmed,
    startTime: startTime || null,
    endTime: endTime || null
  };

  // 先頭に追加
  normalized.unshift(newEntry);

  // 上限を超えたら切り詰め
  const limited = normalized.slice(0, limit);
  return saveToStorage(STORAGE_KEYS.TASK_HISTORY, limited);
}
let timerInterval = null;
let editingSubtasks = [];

// ========================================
// ユーティリティ関数
// ========================================

// UUID生成
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// データキャッシュ（メモリ上に保持）
let dataCache = {};

// Firestore保存（FirestoreBridgeを使用、キャッシュも更新）
function saveToStorage(key, data) {
  try {
    // メモリキャッシュに保存
    dataCache[key] = data;

    // Firestoreに保存（Androidの場合）
    if (typeof FirestoreBridge !== 'undefined') {
      FirestoreBridge.saveData(key, JSON.stringify(data));
    } else {
      console.warn('FirestoreBridge is not available');
    }

    return true;
  } catch (e) {
    console.error('保存エラー:', e);
    return false;
  }
}

// Firestore読み込み（キャッシュ経由、非同期でFirestoreから更新）
function loadFromStorage(key, defaultValue = []) {
  try {
    // キャッシュにデータがあればそれを返す
    if (dataCache.hasOwnProperty(key)) {
      return dataCache[key];
    }

    // Firestoreから読み込み（Androidの場合）
    if (typeof FirestoreBridge !== 'undefined') {
      // 非同期で読み込み、コールバックで更新
      const callbackName = `handleFirestoreData_${key.replace(/[^a-zA-Z0-9]/g, '_')}`;
      FirestoreBridge.loadData(key, callbackName);
    }

    // 初回はデフォルト値を返す
    dataCache[key] = defaultValue;
    return defaultValue;
  } catch (e) {
    console.error('読み込みエラー:', e);
    return defaultValue;
  }
}

// Firestoreからのデータを受け取る汎用コールバック関数
function handleFirestoreCallback(key, data) {
  if (data) {
    try {
      const parsedData = JSON.parse(data);
      dataCache[key] = parsedData;

      // データが更新されたら画面を再描画
      if (typeof renderTasks === 'function') {
        renderTasks();
      }
      if (typeof updateTimeGauge === 'function' && key === STORAGE_KEYS.TASKS) {
        updateTimeGauge(currentGaugeDate || formatDateISO(new Date()));
      }
    } catch (e) {
      console.error('Firestoreデータのパースエラー:', key, e);
    }
  }
}

// 全てのSTORAGE_KEYSに対応するコールバック関数を生成
Object.keys(STORAGE_KEYS).forEach(keyName => {
  const key = STORAGE_KEYS[keyName];
  const callbackName = `handleFirestoreData_${key.replace(/[^a-zA-Z0-9]/g, '_')}`;
  window[callbackName] = function(data) {
    handleFirestoreCallback(key, data);
  };
});

// 日時フォーマット
function formatDateTime(isoString) {
  if (!isoString) return '';
  const date = new Date(isoString);
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  return `${month}/${day} ${hours}:${minutes}`;
}

// 期限切れチェック
function isOverdue(dueDate) {
  if (!dueDate) return false;
  return new Date(dueDate) < new Date();
}

// 時間フォーマット（秒 → HH:MM:SS）
function formatTime(seconds) {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = seconds % 60;
  return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
}
```

### customization.js

```javascript
// ========================================
// カスタマイズ機能
// ========================================

/**
 * カスタマイズ設定のデフォルト値
 */
const DEFAULT_CUSTOMIZATION = {
  // 表示設定
  display: {
    taskDensity: 'normal',        // タスクリストの密度: 'compact' | 'normal' | 'spacious'
    weekStartDay: 0,              // 週の開始曜日: 0 = 日曜日, 1 = 月曜日
    showCompletedTasks: true,     // 完了済みタスクの表示
    taskSortOrder: 'priority'     // タスクの並び順: 'priority' | 'time' | 'manual'
  },

  // 通知設定
  notifications: {
    enabled: true,                // 通知の有効/無効
    defaultReminderTime: 30,      // デフォルトのリマインダー時間（分前）
    reminderRepeat: false,        // リマインダーの繰り返し
    repeatInterval: 5,            // 繰り返し間隔（分）
    soundEnabled: true,           // 通知音の有効/無効
    vibrationEnabled: true        // バイブレーションの有効/無効
  },

  // ゲージ設定
  gauge: {
    visible: true,                // ゲージの表示/非表示
    densityThreshold: 80,         // 密度閾値（%）
    showDensityWarning: true,     // 密度警告の表示
    colorScheme: 'default',       // カラースキーム: 'default' | 'grayscale' | 'custom'
    customColors: {
      elapsed: '#666666',         // 経過時間の色
      scheduled: '#000000',       // 予定時間の色
      free: '#e0e0e0'            // 空き時間の色
    }
  }
};

/**
 * カスタマイズ設定を読み込む
 */
function loadCustomization() {
  try {
    const saved = localStorage.getItem('customization');
    if (saved) {
      const parsed = JSON.parse(saved);
      // デフォルト値とマージ（新しい設定項目に対応）
      return {
        display: { ...DEFAULT_CUSTOMIZATION.display, ...(parsed.display || {}) },
        notifications: { ...DEFAULT_CUSTOMIZATION.notifications, ...(parsed.notifications || {}) },
        gauge: { ...DEFAULT_CUSTOMIZATION.gauge, ...(parsed.gauge || {}) }
      };
    }
  } catch (error) {
    console.error('Failed to load customization:', error);
  }
  return JSON.parse(JSON.stringify(DEFAULT_CUSTOMIZATION));
}

/**
 * カスタマイズ設定を保存する
 */
function saveCustomization(customization) {
  try {
    localStorage.setItem('customization', JSON.stringify(customization));
    console.log('Customization saved:', customization);
    return true;
  } catch (error) {
    console.error('Failed to save customization:', error);
    return false;
  }
}

/**
 * タスク密度の適用
 */
function applyTaskDensity(density) {
  const taskList = document.getElementById('task-list');
  if (!taskList) return;

  // 既存のクラスを削除
  taskList.classList.remove('density-compact', 'density-normal', 'density-spacious');

  // 新しいクラスを追加
  if (density !== 'normal') {
    taskList.classList.add(`density-${density}`);
  }
}

/**
 * 週の開始曜日を適用
 */
function applyWeekStartDay(startDay) {
  // この設定は主にカレンダー表示やレポート機能で使用
  // 現時点ではローカルストレージに保存するのみ
  console.log('Week start day set to:', startDay === 0 ? 'Sunday' : 'Monday');
}

/**
 * 完了済みタスクの表示/非表示を適用
 */
function applyShowCompletedTasks(show) {
  const taskItems = document.querySelectorAll('.task-item.completed');
  taskItems.forEach(item => {
    item.style.display = show ? '' : 'none';
  });
}

/**
 * タスクの並び順を適用
 */
function applyTaskSortOrder(order) {
  // この設定はタスクレンダリング時に使用
  console.log('Task sort order set to:', order);
  // render.js の renderTaskList 関数で使用される
}

/**
 * ゲージの表示/非表示を適用
 */
function applyGaugeVisibility(visible) {
  const gaugeContainer = document.getElementById('time-gauge-container');
  if (gaugeContainer) {
    gaugeContainer.style.display = visible ? '' : 'none';
  }
}

/**
 * ゲージの密度閾値を適用
 */
function applyGaugeDensityThreshold(threshold) {
  // この設定は gauge.js の updateTimeGauge 関数で使用される
  console.log('Gauge density threshold set to:', threshold + '%');
}

/**
 * ゲージのカラースキームを適用
 */
function applyGaugeColorScheme(scheme, customColors) {
  const elapsedBar = document.getElementById('time-gauge-elapsed');
  const scheduledBar = document.getElementById('time-gauge-scheduled');
  const freeBar = document.getElementById('time-gauge-free');

  if (!elapsedBar || !scheduledBar || !freeBar) return;

  if (scheme === 'default') {
    // デフォルトカラー
    elapsedBar.style.backgroundColor = '#666666';
    scheduledBar.style.backgroundColor = '#000000';
    freeBar.style.backgroundColor = '#e0e0e0';
  } else if (scheme === 'grayscale') {
    // グレースケール
    elapsedBar.style.backgroundColor = '#888888';
    scheduledBar.style.backgroundColor = '#444444';
    freeBar.style.backgroundColor = '#cccccc';
  } else if (scheme === 'custom' && customColors) {
    // カスタムカラー
    elapsedBar.style.backgroundColor = customColors.elapsed;
    scheduledBar.style.backgroundColor = customColors.scheduled;
    freeBar.style.backgroundColor = customColors.free;
  }
}

/**
 * 通知設定を適用
 */
function applyNotificationSettings(notifications) {
  // Android側の通知設定を更新
  if (typeof Android !== 'undefined' && Android.updateNotificationSettings) {
    try {
      Android.updateNotificationSettings(JSON.stringify(notifications));
    } catch (error) {
      console.error('Failed to update Android notification settings:', error);
    }
  }
  console.log('Notification settings applied:', notifications);
}

/**
 * 全てのカスタマイズ設定を適用
 */
function applyAllCustomization(customization) {
  console.log('Applying all customization:', customization);

  // 表示設定
  applyTaskDensity(customization.display.taskDensity);
  applyWeekStartDay(customization.display.weekStartDay);
  applyShowCompletedTasks(customization.display.showCompletedTasks);
  applyTaskSortOrder(customization.display.taskSortOrder);

  // ゲージ設定
  applyGaugeVisibility(customization.gauge.visible);
  applyGaugeDensityThreshold(customization.gauge.densityThreshold);
  applyGaugeColorScheme(customization.gauge.colorScheme, customization.gauge.customColors);

  // 通知設定
  applyNotificationSettings(customization.notifications);
}

/**
 * カスタマイズ設定UIの初期化
 */
function initCustomizationUI() {
  const customization = loadCustomization();

  // 表示設定
  const taskDensitySelect = document.getElementById('task-density');
  const weekStartDaySelect = document.getElementById('week-start-day');
  const showCompletedCheckbox = document.getElementById('show-completed-tasks');
  const taskSortOrderSelect = document.getElementById('task-sort-order');

  if (taskDensitySelect) {
    taskDensitySelect.value = customization.display.taskDensity;
    taskDensitySelect.addEventListener('change', (e) => {
      customization.display.taskDensity = e.target.value;
      applyTaskDensity(e.target.value);
      saveCustomization(customization);
    });
  }

  if (weekStartDaySelect) {
    weekStartDaySelect.value = customization.display.weekStartDay;
    weekStartDaySelect.addEventListener('change', (e) => {
      customization.display.weekStartDay = parseInt(e.target.value);
      applyWeekStartDay(parseInt(e.target.value));
      saveCustomization(customization);
    });
  }

  if (showCompletedCheckbox) {
    showCompletedCheckbox.checked = customization.display.showCompletedTasks;
    showCompletedCheckbox.addEventListener('change', (e) => {
      customization.display.showCompletedTasks = e.target.checked;
      applyShowCompletedTasks(e.target.checked);
      saveCustomization(customization);
    });
  }

  if (taskSortOrderSelect) {
    taskSortOrderSelect.value = customization.display.taskSortOrder;
    taskSortOrderSelect.addEventListener('change', (e) => {
      customization.display.taskSortOrder = e.target.value;
      applyTaskSortOrder(e.target.value);
      saveCustomization(customization);
      // タスクリストを再描画
      if (typeof renderTaskList === 'function') {
        renderTaskList();
      }
    });
  }

  // 通知設定
  const notificationsEnabledCheckbox = document.getElementById('notifications-enabled');
  const defaultReminderTimeInput = document.getElementById('default-reminder-time');
  const reminderRepeatCheckbox = document.getElementById('reminder-repeat');
  const repeatIntervalInput = document.getElementById('repeat-interval');
  const soundEnabledCheckbox = document.getElementById('sound-enabled');
  const vibrationEnabledCheckbox = document.getElementById('vibration-enabled');

  if (notificationsEnabledCheckbox) {
    notificationsEnabledCheckbox.checked = customization.notifications.enabled;
    notificationsEnabledCheckbox.addEventListener('change', (e) => {
      customization.notifications.enabled = e.target.checked;
      saveCustomization(customization);
      applyNotificationSettings(customization.notifications);
    });
  }

  if (defaultReminderTimeInput) {
    defaultReminderTimeInput.value = customization.notifications.defaultReminderTime;
    defaultReminderTimeInput.addEventListener('change', (e) => {
      customization.notifications.defaultReminderTime = parseInt(e.target.value);
      saveCustomization(customization);
    });
  }

  if (reminderRepeatCheckbox) {
    reminderRepeatCheckbox.checked = customization.notifications.reminderRepeat;
    reminderRepeatCheckbox.addEventListener('change', (e) => {
      customization.notifications.reminderRepeat = e.target.checked;
      saveCustomization(customization);
      applyNotificationSettings(customization.notifications);
    });
  }

  if (repeatIntervalInput) {
    repeatIntervalInput.value = customization.notifications.repeatInterval;
    repeatIntervalInput.addEventListener('change', (e) => {
      customization.notifications.repeatInterval = parseInt(e.target.value);
      saveCustomization(customization);
    });
  }

  if (soundEnabledCheckbox) {
    soundEnabledCheckbox.checked = customization.notifications.soundEnabled;
    soundEnabledCheckbox.addEventListener('change', (e) => {
      customization.notifications.soundEnabled = e.target.checked;
      saveCustomization(customization);
      applyNotificationSettings(customization.notifications);
    });
  }

  if (vibrationEnabledCheckbox) {
    vibrationEnabledCheckbox.checked = customization.notifications.vibrationEnabled;
    vibrationEnabledCheckbox.addEventListener('change', (e) => {
      customization.notifications.vibrationEnabled = e.target.checked;
      saveCustomization(customization);
      applyNotificationSettings(customization.notifications);
    });
  }

  // ゲージ設定
  const gaugeVisibleCheckbox = document.getElementById('gauge-visible');
  const densityThresholdInput = document.getElementById('density-threshold');
  const showDensityWarningCheckbox = document.getElementById('show-density-warning');
  const colorSchemeSelect = document.getElementById('color-scheme');

  if (gaugeVisibleCheckbox) {
    gaugeVisibleCheckbox.checked = customization.gauge.visible;
    gaugeVisibleCheckbox.addEventListener('change', (e) => {
      customization.gauge.visible = e.target.checked;
      applyGaugeVisibility(e.target.checked);
      saveCustomization(customization);
    });
  }

  if (densityThresholdInput) {
    densityThresholdInput.value = customization.gauge.densityThreshold;
    densityThresholdInput.addEventListener('change', (e) => {
      customization.gauge.densityThreshold = parseInt(e.target.value);
      applyGaugeDensityThreshold(parseInt(e.target.value));
      saveCustomization(customization);
    });
  }

  if (showDensityWarningCheckbox) {
    showDensityWarningCheckbox.checked = customization.gauge.showDensityWarning;
    showDensityWarningCheckbox.addEventListener('change', (e) => {
      customization.gauge.showDensityWarning = e.target.checked;
      saveCustomization(customization);
    });
  }

  if (colorSchemeSelect) {
    colorSchemeSelect.value = customization.gauge.colorScheme;
    colorSchemeSelect.addEventListener('change', (e) => {
      customization.gauge.colorScheme = e.target.value;
      applyGaugeColorScheme(e.target.value, customization.gauge.customColors);
      saveCustomization(customization);
    });
  }

  // カスタムカラーピッカー
  const elapsedColorInput = document.getElementById('elapsed-color');
  const scheduledColorInput = document.getElementById('scheduled-color');
  const freeColorInput = document.getElementById('free-color');

  if (elapsedColorInput) {
    elapsedColorInput.value = customization.gauge.customColors.elapsed;
    elapsedColorInput.addEventListener('change', (e) => {
      customization.gauge.customColors.elapsed = e.target.value;
      if (customization.gauge.colorScheme === 'custom') {
        applyGaugeColorScheme('custom', customization.gauge.customColors);
      }
      saveCustomization(customization);
    });
  }

  if (scheduledColorInput) {
    scheduledColorInput.value = customization.gauge.customColors.scheduled;
    scheduledColorInput.addEventListener('change', (e) => {
      customization.gauge.customColors.scheduled = e.target.value;
      if (customization.gauge.colorScheme === 'custom') {
        applyGaugeColorScheme('custom', customization.gauge.customColors);
      }
      saveCustomization(customization);
    });
  }

  if (freeColorInput) {
    freeColorInput.value = customization.gauge.customColors.free;
    freeColorInput.addEventListener('change', (e) => {
      customization.gauge.customColors.free = e.target.value;
      if (customization.gauge.colorScheme === 'custom') {
        applyGaugeColorScheme('custom', customization.gauge.customColors);
      }
      saveCustomization(customization);
    });
  }

  console.log('Customization UI initialized');
}

/**
 * カスタマイズ機能の初期化
 */
function initCustomization() {
  console.log('Initializing customization...');

  // 設定を読み込んで適用
  const customization = loadCustomization();
  applyAllCustomization(customization);

  // UIの初期化
  initCustomizationUI();

  console.log('Customization initialized');
}

// DOMロード後に初期化
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initCustomization);
} else {
  initCustomization();
}
```

### events.js

```javascript
// ========================================
// イベントリスナー設定
// ========================================

// イベントリスナーの初期化フラグ
let eventListenersInitialized = false;

function initEventListeners() {
  // 既に初期化済みの場合はスキップ
  if (eventListenersInitialized) {
    console.log('[EVENTS] Event listeners already initialized, skipping...');
    return;
  }

  console.log('[EVENTS] Initializing event listeners...');
  eventListenersInitialized = true;

  // ログインアイコン
  const loginIconBtn = document.getElementById('login-icon-btn');
  if (loginIconBtn) {
    loginIconBtn.addEventListener('click', () => {
      console.log('[EVENTS] login-icon-btn clicked');
      try {
        if (typeof window.openLoginModal === 'function') {
          window.openLoginModal();
        } else {
          console.error('[EVENTS] window.openLoginModal is not a function');
        }
      } catch (error) {
        console.error('[EVENTS] Error calling openLoginModal:', error);
      }
    });
  }

  // ログインモーダルを閉じる
  const closeLoginBtn = document.getElementById('close-login-btn');
  if (closeLoginBtn) {
    closeLoginBtn.addEventListener('click', () => {
      closeLoginModal();
    });
  }

  // ログインモーダル外クリックで閉じる
  const loginModal = document.getElementById('login-modal');
  if (loginModal) {
    loginModal.addEventListener('click', (e) => {
      if (e.target.id === 'login-modal') {
        closeLoginModal();
      }
    });
  }

  // Googleログインボタン
  const googleLoginBtn = document.getElementById('google-login-btn');
  if (googleLoginBtn) {
    googleLoginBtn.addEventListener('click', () => {
      if (typeof AndroidAuth !== 'undefined') {
        AndroidAuth.signInWithGoogle();
      } else {
        alert('Google認証はAndroidアプリでのみ利用可能です');
      }
    });
  }

  // Twitterログインボタン
  const twitterLoginBtn = document.getElementById('twitter-login-btn');
  if (twitterLoginBtn) {
    twitterLoginBtn.addEventListener('click', () => {
      if (typeof AndroidAuth !== 'undefined') {
        AndroidAuth.signInWithTwitter();
      } else {
        alert('X (Twitter)認証はAndroidアプリでのみ利用可能です');
      }
    });
  }

  // ヘッダーメニューボタン（その他メニュー）
  const headerMenuBtn = document.getElementById('header-menu-btn');
  if (headerMenuBtn) {
    headerMenuBtn.addEventListener('click', (e) => {
      showHeaderMenu(e);
    });
  }

  // ========================================
  // 新ヘッダーボタン（新デザインシステム）
  // 既存のボタンにデリゲーション
  // ========================================
  const newCalendarBtn = document.getElementById('new-calendar-btn');
  if (newCalendarBtn) {
    newCalendarBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof openCalendarModal === 'function') {
        openCalendarModal();
      }
    });
  }

  const newAccountBtn = document.getElementById('new-account-btn');
  if (newAccountBtn) {
    console.log('[EVENTS] new-account-btn element found, adding click listener');
    newAccountBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('[EVENTS] new-account-btn clicked');

      try {
        if (typeof window.openLoginModal === 'function') {
          console.log('[EVENTS] Calling window.openLoginModal');
          window.openLoginModal();
        } else {
          console.error('[EVENTS] window.openLoginModal is not a function:', typeof window.openLoginModal);
        }
      } catch (error) {
        console.error('[EVENTS] Error calling openLoginModal:', error);
      }
    });
  } else {
    console.error('[EVENTS] new-account-btn NOT FOUND');
  }

  const newSettingsBtn = document.getElementById('new-settings-btn');
  console.log('[EVENTS] new-settings-btn element:', newSettingsBtn);
  if (newSettingsBtn) {
    console.log('[EVENTS] Adding click listener to new-settings-btn');
    newSettingsBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('[EVENTS] new-settings-btn clicked!');

      try {
        if (typeof window.openSettingsModal === 'function') {
          console.log('[EVENTS] Calling window.openSettingsModal');
          window.openSettingsModal();
        } else {
          console.error('[EVENTS] window.openSettingsModal is not a function:', typeof window.openSettingsModal);
        }
      } catch (error) {
        console.error('[EVENTS] Error calling openSettingsModal:', error);
      }
    });
  } else {
    console.error('[EVENTS] new-settings-btn NOT FOUND!');
  }

  const newMenuBtn = document.getElementById('new-menu-btn');
  if (newMenuBtn) {
    newMenuBtn.addEventListener('click', (e) => {
      showHeaderMenu(e);
    });
  }

  // 設定アイコン
  const settingsIconBtn = document.getElementById('settings-icon-btn');
  if (settingsIconBtn) {
    settingsIconBtn.addEventListener('click', () => {
      console.log('[EVENTS] settings-icon-btn clicked');
      try {
        if (typeof window.openSettingsModal === 'function') {
          window.openSettingsModal();
        } else {
          console.error('[EVENTS] window.openSettingsModal is not a function');
        }
      } catch (error) {
        console.error('[EVENTS] Error calling openSettingsModal:', error);
      }
    });
  }

  // 設定モーダルを閉じる
  const closeSettingsBtn = document.getElementById('close-settings-btn');
  if (closeSettingsBtn) {
    closeSettingsBtn.addEventListener('click', () => {
      closeSettingsModal();
    });
  }

  // 分析アイコン
  const analyticsIconBtn = document.getElementById('analytics-icon-btn');
  if (analyticsIconBtn) {
    analyticsIconBtn.addEventListener('click', () => {
      if (typeof openAnalyticsModal === 'function') {
        openAnalyticsModal();
      }
    });
  }

  // 分析モーダルを閉じる
  const closeAnalyticsBtn = document.getElementById('close-analytics-btn');
  if (closeAnalyticsBtn) {
    closeAnalyticsBtn.addEventListener('click', () => {
      if (typeof closeAnalyticsModal === 'function') {
        closeAnalyticsModal();
      }
    });
  }

  // 分析モーダル外クリックで閉じる
  const analyticsModal = document.getElementById('analytics-modal');
  if (analyticsModal) {
    analyticsModal.addEventListener('click', (e) => {
      if (e.target.id === 'analytics-modal') {
        if (typeof closeAnalyticsModal === 'function') {
          closeAnalyticsModal();
        }
      }
    });
  }

  // テンプレート選択ボタン
  const templateSelectBtn = document.getElementById('template-select-btn');
  if (templateSelectBtn) {
    const handleTemplateOpen = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof openTemplateModal === 'function') {
        openTemplateModal();
      }
    };
    templateSelectBtn.addEventListener('click', handleTemplateOpen);
    templateSelectBtn.addEventListener('touchend', handleTemplateOpen);
  }

  // テンプレートモーダルを閉じる
  const closeTemplateBtn = document.getElementById('close-template-btn');
  const templateCloseBtn = document.getElementById('template-close-btn');
  if (closeTemplateBtn) {
    closeTemplateBtn.addEventListener('click', () => {
      if (typeof closeTemplateModal === 'function') {
        closeTemplateModal();
      }
    });
  }
  if (templateCloseBtn) {
    templateCloseBtn.addEventListener('click', () => {
      if (typeof closeTemplateModal === 'function') {
        closeTemplateModal();
      }
    });
  }

  // テンプレートモーダル外クリックで閉じる
  const templateModal = document.getElementById('template-modal');
  if (templateModal) {
    templateModal.addEventListener('click', (e) => {
      if (e.target.id === 'template-modal') {
        if (typeof closeTemplateModal === 'function') {
          closeTemplateModal();
        }
      }
    });
  }

  // テンプレート追加ボタン（フォーム表示）
  const addTemplateBtn = document.getElementById('add-template-btn');
  if (addTemplateBtn) {
    const handleAddTemplate = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof showTemplateInputForm === 'function') {
        showTemplateInputForm();
      }
    };
    addTemplateBtn.addEventListener('click', handleAddTemplate);
    addTemplateBtn.addEventListener('touchend', handleAddTemplate);
  }

  // テンプレートフォーム保存ボタン
  const templateSaveBtn = document.getElementById('template-save-btn');
  if (templateSaveBtn) {
    const handleTemplateSave = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof saveTemplateFromForm === 'function') {
        saveTemplateFromForm();
      }
    };
    templateSaveBtn.addEventListener('click', handleTemplateSave);
    templateSaveBtn.addEventListener('touchend', handleTemplateSave);
  }

  // テンプレートフォームキャンセルボタン
  const templateCancelBtn = document.getElementById('template-cancel-btn');
  if (templateCancelBtn) {
    const handleTemplateCancel = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof hideTemplateInputForm === 'function') {
        hideTemplateInputForm();
      }
    };
    templateCancelBtn.addEventListener('click', handleTemplateCancel);
    templateCancelBtn.addEventListener('touchend', handleTemplateCancel);
  }

  // カレンダーアイコン
  const calendarIconBtn = document.getElementById('calendar-icon-btn');
  if (calendarIconBtn) {
    calendarIconBtn.addEventListener('click', () => {
      if (typeof openCalendarModal === 'function') {
        openCalendarModal();
      }
    });
  }

  // カレンダーモーダルを閉じる
  const closeCalendarBtn = document.getElementById('close-calendar-btn');
  if (closeCalendarBtn) {
    closeCalendarBtn.addEventListener('click', () => {
      if (typeof closeCalendarModal === 'function') {
        closeCalendarModal();
      }
    });
  }

  // カレンダーモーダル外クリックで閉じる
  const calendarModal = document.getElementById('calendar-modal');
  if (calendarModal) {
    calendarModal.addEventListener('click', (e) => {
      if (e.target.id === 'calendar-modal') {
        if (typeof closeCalendarModal === 'function') {
          closeCalendarModal();
        }
      }
    });
  }

  // カレンダーナビゲーション
  const calendarPrevBtn = document.getElementById('calendar-prev-btn');
  const calendarNextBtn = document.getElementById('calendar-next-btn');
  if (calendarPrevBtn) {
    calendarPrevBtn.addEventListener('click', () => {
      if (typeof goToPreviousMonth === 'function') {
        goToPreviousMonth();
      }
    });
  }
  if (calendarNextBtn) {
    calendarNextBtn.addEventListener('click', () => {
      if (typeof goToNextMonth === 'function') {
        goToNextMonth();
      }
    });
  }

  // 設定保存
  const saveSettingsBtn = document.getElementById('save-settings-btn');
  if (saveSettingsBtn) {
    saveSettingsBtn.addEventListener('click', () => {
      saveSettings();
    });
  }

  // ルーティン追加
  const addRoutineBtn = document.getElementById('add-routine-btn');
  if (addRoutineBtn) {
    addRoutineBtn.addEventListener('click', () => {
      addRoutine();
    });
  }

  // 完了済み折りたたみ
  const completedToggle = document.getElementById('completed-toggle');
  const completedContent = document.getElementById('completed-content');
  if (completedToggle && completedContent) {
    completedToggle.addEventListener('click', () => {
      completedToggle.classList.toggle('open');
      completedContent.classList.toggle('open');
    });
  }

  // FAB（新規作成）
  const createTaskBtn = document.getElementById('create-task-btn');
  if (createTaskBtn) {
    createTaskBtn.addEventListener('click', () => {
      openCreateModal();
    });
  }

  // モーダル閉じる
  const closeModalBtn = document.getElementById('close-modal-btn');
  if (closeModalBtn) {
    closeModalBtn.addEventListener('click', () => {
      closeModal();
    });
  }

  const cancelBtn = document.getElementById('cancel-btn');
  if (cancelBtn) {
    cancelBtn.addEventListener('click', () => {
      closeModal();
    });
  }

  // モーダル外クリックで閉じる
  const taskModal = document.getElementById('task-modal');
  if (taskModal) {
    taskModal.addEventListener('click', (e) => {
      if (e.target.id === 'task-modal') {
        closeModal();
      }
    });
  }

  const settingsModal = document.getElementById('settings-modal');
  if (settingsModal) {
    settingsModal.addEventListener('click', (e) => {
      if (e.target.id === 'settings-modal') {
        closeSettingsModal();
      }
    });
  }

  // 保存ボタン
  const saveBtnElement = document.getElementById('save-btn');
  if (saveBtnElement) {
    const handleSaveTask = (e) => {
      e.preventDefault();
      e.stopPropagation();
      saveTask();
    };
    saveBtnElement.addEventListener('click', handleSaveTask);
    saveBtnElement.addEventListener('touchend', handleSaveTask);
  }

  // 削除ボタン
  const deleteBtn = document.getElementById('delete-btn');
  if (deleteBtn) {
    deleteBtn.addEventListener('click', () => {
      deleteCurrentTask();
    });
  }

  // タイトル入力時の文字数カウント
  const titleInput = document.getElementById('task-title');
  if (titleInput) {
    titleInput.addEventListener('input', () => {
      const count = titleInput.value.length;
      const charCount = document.getElementById('title-char-count');
      const saveBtn = document.getElementById('save-btn');
      if (charCount) charCount.textContent = count;
      if (saveBtn) saveBtn.disabled = count === 0;
    });

    // Enterキーで保存（タイトル入力時）
    titleInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && titleInput.value.trim()) {
        saveTask();
      }
    });
  }

  // タイマーボタン
  const timerToggleBtn = document.getElementById('timer-toggle-btn');
  if (timerToggleBtn) {
    timerToggleBtn.addEventListener('click', (e) => {
      e.preventDefault();
      if (!editingTaskId) return;

      const task = getTaskById(editingTaskId);
      if (!task) return;

      if (task.isTimerRunning) {
        stopTimer(editingTaskId);
      } else {
        startTimer(editingTaskId);
      }

      updateTimerDisplay(editingTaskId);
    });
  }

  // クイック入力
  const quickInput = document.getElementById('quick-add-input');
  const quickAddForm = document.getElementById('quick-add-form');
  const quickDateBtn = document.getElementById('quick-date-btn');
  const quickDatetimePanel = document.getElementById('quick-datetime-panel');
  const quickDateInput = document.getElementById('quick-add-date');
  const quickDuration = document.getElementById('quick-add-duration');
  const quickDatetimeClose = document.getElementById('quick-datetime-close');
  const quickHistoryBtn = document.getElementById('quick-history-btn');
  const quickHistoryTags = document.getElementById('quick-history-tags');

  // カレンダーボタンのクリック
  if (quickDateBtn && quickDatetimePanel) {
    quickDateBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      if (quickDatetimePanel.style.display === 'none') {
        quickDatetimePanel.style.display = 'block';
      } else {
        quickDatetimePanel.style.display = 'none';
      }
    });
  }

  // 日時パネルを閉じる
  if (quickDatetimeClose && quickDatetimePanel) {
    quickDatetimeClose.addEventListener('click', (e) => {
      e.preventDefault();
      quickDatetimePanel.style.display = 'none';
    });
  }

  // 日時選択時
  if (quickDateInput && quickDateBtn) {
    quickDateInput.addEventListener('change', () => {
      if (quickDateInput.value) {
        quickDateBtn.classList.add('has-date');
      } else {
        quickDateBtn.classList.remove('has-date');
      }
    });
  }

  // パネルの外側クリックで閉じる
  document.addEventListener('click', (e) => {
    if (quickDatetimePanel && !quickDatetimePanel.contains(e.target) && quickDateBtn && !quickDateBtn.contains(e.target)) {
      quickDatetimePanel.style.display = 'none';
    }
  });

  if (quickAddForm && quickInput) {
    quickAddForm.addEventListener('submit', (e) => {
    e.preventDefault();
    if (quickInput.value.trim()) {
      const title = quickInput.value.trim();
      const durationValue = quickDuration ? quickDuration.value : '';
      const duration = durationValue ? parseInt(durationValue) : null;

      // 期限日のみ（時刻なし）
      let dueDate = null;
      let startTime = null;

      // 自然言語入力から解析されたデータを取得
      const naturalLangResult = typeof processNaturalInput === 'function' ? processNaturalInput(title) : null;

      if (naturalLangResult && naturalLangResult.hasDatetime) {
        // 自然言語入力から日付が解析された場合
        dueDate = naturalLangResult.dueDate;
        startTime = naturalLangResult.startTime;
      } else if (quickDateInput.value) {
        // ユーザーが手動で日付を指定した場合
        dueDate = new Date(quickDateInput.value + 'T00:00:00').toISOString();
      } else {
        // 日付未指定の場合は今日の日付を設定
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        dueDate = new Date(`${year}-${month}-${day}T00:00:00`).toISOString();
      }

      // 自然言語入力から日時が抽出された場合、タスク名から日付部分を削除
      const finalTitle = naturalLangResult && naturalLangResult.hasDatetime ? naturalLangResult.taskTitle : title;

      // 新規タスク作成
      const tasks = getTasks();
      const now = new Date().toISOString();
      const task = {
        id: generateUUID(),
        title: finalTitle,
        memo: '',
        dueDate: dueDate,
        isCompleted: false,
        createdAt: now,
        updatedAt: now,
        parentId: null,
        isTutorial: false,
        totalTime: 0,
        isTimerRunning: false,
        timerStartTime: null,
        duration: duration,
        startTime: startTime,
        endTime: null,
        urgent: false,
        priority: ''
      };
      tasks.unshift(task);
      saveTasks(tasks);

      // 履歴に追加
      if (typeof addToTaskHistory === 'function') {
        addToTaskHistory(finalTitle, startTime, null, 20);
        try {
          document.dispatchEvent(new CustomEvent('task:history:updated'));
        } catch (e) {
          console.warn('CustomEvent dispatch failed', e);
        }
      }

      quickInput.value = '';
      if (quickDateInput) quickDateInput.value = '';
      if (quickDuration) quickDuration.value = '';
      if (quickDatetimePanel) quickDatetimePanel.style.display = 'none';
      if (quickDateBtn) quickDateBtn.classList.remove('has-date');
      renderTasks();
    }
    });
  }

  // ---- 履歴タグの初期化とイベント ----
  function renderHistoryTags() {
    if (!quickHistoryTags) return;
    quickHistoryTags.innerHTML = '';

    const history = typeof getTaskHistory === 'function' ? getTaskHistory(10) : [];
    history.forEach((item) => {
      const itemTitle = typeof item === 'string' ? item : (item.title || '');
      const itemStartTime = typeof item === 'object' ? item.startTime : null;
      const itemEndTime = typeof item === 'object' ? item.endTime : null;

      const tag = document.createElement('button');
      tag.type = 'button';
      tag.className = 'quick-history-tag';
      tag.textContent = itemTitle;
      tag.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();

        // タスクを即座に作成
        const tasks = getTasks();
        const now = new Date().toISOString();

        // 今日の日付を設定
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        const todayDate = new Date(`${year}-${month}-${day}T00:00:00`).toISOString();

        // 履歴からのタスク作成の場合、保存された時刻情報を使用
        let finalTitle = itemTitle;
        let finalStartTime = itemStartTime;
        let finalDueDate = todayDate;

        const task = {
          id: generateUUID(),
          title: finalTitle,
          memo: '',
          dueDate: finalDueDate,
          isCompleted: false,
          createdAt: now,
          updatedAt: now,
          parentId: null,
          isTutorial: false,
          totalTime: 0,
          isTimerRunning: false,
          timerStartTime: null,
          duration: null,
          startTime: finalStartTime,
          endTime: itemEndTime,
          urgent: false,
          priority: ''
        };
        tasks.unshift(task);
        saveTasks(tasks);

        // 履歴を更新
        if (typeof addToTaskHistory === 'function') {
          addToTaskHistory(task.title, task.startTime, task.endTime, 20);
          try {
            document.dispatchEvent(new CustomEvent('task:history:updated'));
          } catch (e) {
            console.warn('CustomEvent dispatch failed', e);
          }
        }

        renderTasks();
      });

      quickHistoryTags.appendChild(tag);
    });
  }

  // 履歴ボタンのクリック（履歴タグの表示/非表示を切り替え）
  if (quickHistoryBtn && quickHistoryTags) {
    quickHistoryBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      const isVisible = quickHistoryTags.style.display === 'flex';
      if (isVisible) {
        quickHistoryTags.style.display = 'none';
      } else {
        renderHistoryTags();
        quickHistoryTags.style.display = 'flex';
      }
    });
  }

  // 初期描画（最初は非表示）
  if (quickHistoryTags) {
    quickHistoryTags.style.display = 'none';
  }

  // 履歴更新時に再描画
  document.addEventListener('task:history:updated', () => {
    renderHistoryTags();
  });

  // 絞り込みボタン
  const filterUrgentBtn = document.getElementById('filter-urgent');
  const filterHighPriorityBtn = document.getElementById('filter-high-priority');
  const filterClearBtn = document.getElementById('filter-clear');

  if (filterUrgentBtn && filterHighPriorityBtn) {
    filterUrgentBtn.addEventListener('click', () => {
      currentFilter = currentFilter === 'urgent' ? null : 'urgent';
      filterUrgentBtn.classList.toggle('active');
      filterHighPriorityBtn.classList.remove('active');
      renderTasks();
    });
  }

  if (filterHighPriorityBtn && filterUrgentBtn) {
    filterHighPriorityBtn.addEventListener('click', () => {
      currentFilter = currentFilter === 'high-priority' ? null : 'high-priority';
      filterHighPriorityBtn.classList.toggle('active');
      filterUrgentBtn.classList.remove('active');
      renderTasks();
    });
  }

  if (filterClearBtn && filterUrgentBtn && filterHighPriorityBtn) {
    filterClearBtn.addEventListener('click', () => {
      currentFilter = null;
      filterUrgentBtn.classList.remove('active');
      filterHighPriorityBtn.classList.remove('active');
      renderTasks();
    });
  }

  // サブタスク追加ボタン
  const addSubtaskBtn = document.getElementById('add-subtask-btn');
  if (addSubtaskBtn) {
    addSubtaskBtn.addEventListener('click', () => {
      addSubtask();
    });
  }

  // 時間オーバー警告モーダルのイベント
  const closeOverloadBtn = document.getElementById('close-overload-btn');
  const overloadCancelBtn = document.getElementById('overload-cancel-btn');
  const overloadAdjustBtn = document.getElementById('overload-adjust-btn');
  const timeOverloadModal = document.getElementById('time-overload-modal');

  if (closeOverloadBtn) {
    closeOverloadBtn.addEventListener('click', () => {
      if (typeof closeTimeOverloadModal === 'function') {
        closeTimeOverloadModal();
      }
    });
  }

  if (overloadCancelBtn) {
    overloadCancelBtn.addEventListener('click', () => {
      if (typeof closeTimeOverloadModal === 'function') {
        closeTimeOverloadModal();
      }
    });
  }

  if (overloadAdjustBtn) {
    overloadAdjustBtn.addEventListener('click', () => {
      // 調整ボタンは現在モーダルを閉じるだけ（タスク一覧で個別に調整）
      if (typeof closeTimeOverloadModal === 'function') {
        closeTimeOverloadModal();
      }
    });
  }

  if (timeOverloadModal) {
    timeOverloadModal.addEventListener('click', (e) => {
      if (e.target.id === 'time-overload-modal') {
        if (typeof closeTimeOverloadModal === 'function') {
          closeTimeOverloadModal();
        }
      }
    });
  }

  // スクロール連動で24時間ゲージを更新（スロットリング）
  const tasksListContainer = document.querySelector('.main-content');
  if (tasksListContainer) {
    let lastCall = 0;
    const throttleMs = 150;
    let scrollTimeout = null;
    let isScrolling = false;

    tasksListContainer.addEventListener('scroll', () => {
      const now = Date.now();
      if (now - lastCall < throttleMs) return;
      lastCall = now;

      // 画面上部に見える最初の date-separator を探す
      const separators = document.querySelectorAll('.date-separator');
      let topMostDate = null;
      let topMostOffset = Infinity;
      separators.forEach(sep => {
        const rect = sep.getBoundingClientRect();
        // ビューポート上部付近（ヘッダーなどを考慮して 80px 下）にあるものを検出
        const offset = Math.abs(rect.top - 80);
        if (rect.top <= 120 && offset < topMostOffset) {
          topMostOffset = offset;
          topMostDate = sep.dataset.date || null;
        }
      });

      // 見つかった日付を渡してゲージを更新
      if (topMostDate !== null) {
        updateTimeGauge(topMostDate || undefined);
      }

      // クイック入力のスクロール時の表示/非表示制御
      if (quickAddForm) {
        // スクロール中はクイック入力を非表示
        if (!isScrolling) {
          isScrolling = true;
          quickAddForm.classList.add('hidden');
        }

        // 既存のタイムアウトをクリア
        if (scrollTimeout) {
          clearTimeout(scrollTimeout);
        }

        // スクロール停止後3秒で再表示
        scrollTimeout = setTimeout(() => {
          isScrolling = false;
          quickAddForm.classList.remove('hidden');
        }, 3000);
      }
    });
  }

  // ========================================
  // 複数選択モード関連
  // ========================================

  // 複数選択トグルボタン（ゲージ下部のボタン - 旧UI）
  const bulkSelectToggleBtn = document.getElementById('bulk-select-toggle-btn');
  if (bulkSelectToggleBtn) {
    bulkSelectToggleBtn.addEventListener('click', () => {
      if (typeof toggleSelectionMode === 'function') {
        toggleSelectionMode();
      }
    });
  }

  // 複数選択トグルボタン（新UI）
  const newBulkSelectToggleBtn = document.getElementById('new-bulk-select-toggle-btn');
  if (newBulkSelectToggleBtn) {
    newBulkSelectToggleBtn.addEventListener('click', () => {
      if (typeof toggleSelectionMode === 'function') {
        toggleSelectionMode();
      }
    });
  }

  // 選択モードボタン（新しいツールバーのボタン）
  const toolbarSelectModeBtn = document.getElementById('toolbar-select-mode-btn');
  if (toolbarSelectModeBtn) {
    toolbarSelectModeBtn.addEventListener('click', () => {
      if (typeof toggleSelectionMode === 'function') {
        toggleSelectionMode();
      }
    });
  }

  // 一括完了ボタン
  const bulkCompleteBtn = document.getElementById('bulk-complete-btn');
  if (bulkCompleteBtn) {
    bulkCompleteBtn.addEventListener('click', () => {
      if (typeof bulkCompleteActions === 'function') {
        bulkCompleteActions();
      }
    });
  }

  // 一括削除ボタン
  const bulkDeleteBtn = document.getElementById('bulk-delete-btn');
  if (bulkDeleteBtn) {
    bulkDeleteBtn.addEventListener('click', () => {
      if (typeof bulkDeleteTasks === 'function') {
        bulkDeleteTasks();
      }
    });
  }

  // 選択キャンセルボタン
  const bulkCancelBtn = document.getElementById('bulk-cancel-btn');
  if (bulkCancelBtn) {
    bulkCancelBtn.addEventListener('click', () => {
      if (typeof toggleSelectionMode === 'function') {
        toggleSelectionMode();
      }
    });
  }

  // 全選択/全解除ボタン
  const bulkSelectAllBtn = document.getElementById('bulk-select-all-btn');
  if (bulkSelectAllBtn) {
    bulkSelectAllBtn.addEventListener('click', () => {
      if (typeof bulkSelectAll === 'function') {
        bulkSelectAll();
      }
    });
  }

  // 日付変更ボタン
  const bulkDateBtn = document.getElementById('bulk-date-btn');
  if (bulkDateBtn) {
    bulkDateBtn.addEventListener('click', (e) => {
      if (typeof bulkChangeDateTasks === 'function') {
        bulkChangeDateTasks(e);
      }
    });
  }

  // 優先度変更ボタン
  const bulkPriorityBtn = document.getElementById('bulk-priority-btn');
  if (bulkPriorityBtn) {
    bulkPriorityBtn.addEventListener('click', (e) => {
      if (typeof bulkChangePriorityTasks === 'function') {
        bulkChangePriorityTasks(e);
      }
    });
  }

  // ========================================
  // クイックアクション関連
  // ========================================

  // 今日のタスクを一括完了
  const quickCompleteTodayBtn = document.getElementById('quick-complete-today-btn');
  if (quickCompleteTodayBtn) {
    quickCompleteTodayBtn.addEventListener('click', () => {
      if (typeof quickCompleteToday === 'function') {
        quickCompleteToday();
      }
    });
  }

  // 期限切れタスクを明日に移動
  const quickMoveOverdueBtn = document.getElementById('quick-move-overdue-btn');
  if (quickMoveOverdueBtn) {
    quickMoveOverdueBtn.addEventListener('click', () => {
      if (typeof quickMoveOverdueToTomorrow === 'function') {
        quickMoveOverdueToTomorrow();
      }
    });
  }

  // 完了タスクをアーカイブ
  const quickArchiveCompletedBtn = document.getElementById('quick-archive-completed-btn');
  if (quickArchiveCompletedBtn) {
    quickArchiveCompletedBtn.addEventListener('click', () => {
      if (typeof quickArchiveCompleted === 'function') {
        quickArchiveCompleted();
      }
    });
  }

  // 今日の未完了タスクを明日にコピー
  const quickCopyTodayBtn = document.getElementById('quick-copy-today-btn');
  if (quickCopyTodayBtn) {
    quickCopyTodayBtn.addEventListener('click', () => {
      if (typeof quickCopyTodayToTomorrow === 'function') {
        quickCopyTodayToTomorrow();
      }
    });
  }

  // ========================================
  // セクション追加ボタン（新UIの+ボタン）
  // ========================================
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('new-section-add-btn')) {
      const dateKey = e.target.dataset.date;
      if (dateKey !== undefined) {
        // タスク作成モーダルを開く
        if (typeof openCreateModal === 'function') {
          openCreateModal();

          // モーダルが開いた後に期限日を設定
          setTimeout(() => {
            const dueDateInput = document.getElementById('task-due-date');
            if (dueDateInput && dateKey) {
              // dateKeyを「YYYY-MM-DD」形式の日付に変換
              // dateKeyは 'today', 'tomorrow', 'future_...' などの形式
              const dateObj = new Date(dateKey);
              const year = dateObj.getFullYear();
              const month = String(dateObj.getMonth() + 1).padStart(2, '0');
              const day = String(dateObj.getDate()).padStart(2, '0');
              dueDateInput.value = `${year}-${month}-${day}`;
            }
          }, 100);
        }
      }
    }
  });

  // ========================================
  // 新ゲージナビゲーションボタン（新UIのゲージ日付切り替え）
  // ========================================
  const newGaugePrevBtn = document.getElementById('new-gauge-prev');
  const newGaugeNextBtn = document.getElementById('new-gauge-next');

  if (newGaugePrevBtn) {
    newGaugePrevBtn.addEventListener('click', () => {
      if (typeof changeGaugeDate === 'function') {
        changeGaugeDate(-1);
        // 新UIゲージを再レンダリング
        if (typeof renderNewGauge === 'function') {
          renderNewGauge(currentGaugeDate);
        }
      }
    });
  }

  if (newGaugeNextBtn) {
    newGaugeNextBtn.addEventListener('click', () => {
      if (typeof changeGaugeDate === 'function') {
        changeGaugeDate(1);
        // 新UIゲージを再レンダリング
        if (typeof renderNewGauge === 'function') {
          renderNewGauge(currentGaugeDate);
        }
      }
    });
  }

  // ========================================
  // 新UI: クイック入力＆完了済みセクション初期化
  // ========================================
  if (typeof initQuickInput === 'function') {
    initQuickInput();
  }
  if (typeof initCompletedToggle === 'function') {
    initCompletedToggle();
  }
}

// タブUIは廃止しました。表示切替は showTasks/showTrash を使用します。
```

### events-01-auth-header.js

```javascript
// ========================================
// イベントリスナー設定
// ========================================

function initEventListeners() {

  // ログインアイコン
  const loginIconBtn = document.getElementById('login-icon-btn');
  if (loginIconBtn) {
    loginIconBtn.addEventListener('click', () => {
      openLoginModal();
    });
  }

  // ログインモーダルを閉じる
  const closeLoginBtn = document.getElementById('close-login-btn');
  if (closeLoginBtn) {
    closeLoginBtn.addEventListener('click', () => {
      closeLoginModal();
    });
  }

  // ログインモーダル外クリックで閉じる
  const loginModal = document.getElementById('login-modal');
  if (loginModal) {
    loginModal.addEventListener('click', (e) => {
      if (e.target.id === 'login-modal') {
        closeLoginModal();
      }
    });
  }

  // Googleログインボタン
  const googleLoginBtn = document.getElementById('google-login-btn');
  if (googleLoginBtn) {
    googleLoginBtn.addEventListener('click', () => {
      if (typeof AndroidAuth !== 'undefined') {
        AndroidAuth.signInWithGoogle();
      } else {
        alert('Google認証はAndroidアプリでのみ利用可能です');
      }
    });
  }

  // Twitterログインボタン
  const twitterLoginBtn = document.getElementById('twitter-login-btn');
  if (twitterLoginBtn) {
    twitterLoginBtn.addEventListener('click', () => {
      if (typeof AndroidAuth !== 'undefined') {
        AndroidAuth.signInWithTwitter();
      } else {
        alert('X (Twitter)認証はAndroidアプリでのみ利用可能です');
      }
    });
  }

  // ヘッダーメニューボタン（その他メニュー）
  const headerMenuBtn = document.getElementById('header-menu-btn');
  if (headerMenuBtn) {
    headerMenuBtn.addEventListener('click', (e) => {
      showHeaderMenu(e);
    });
  }

  // ========================================
  // 新ヘッダーボタン（新デザインシステム）
  // 既存のボタンにデリゲーション
  // ========================================
  const newCalendarBtn = document.getElementById('new-calendar-btn');
  if (newCalendarBtn) {
    newCalendarBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof openCalendarModal === 'function') {
        openCalendarModal();
      }
    });
  }

  const newAccountBtn = document.getElementById('new-account-btn');
  if (newAccountBtn) {
    newAccountBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      openLoginModal();
    });
  }

  const newSettingsBtn = document.getElementById('new-settings-btn');
  console.log('[EVENTS] new-settings-btn element:', newSettingsBtn);
  if (newSettingsBtn) {
    console.log('[EVENTS] Adding click listener to new-settings-btn');
    newSettingsBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('[EVENTS] new-settings-btn clicked!');
      openSettingsModal();
    });
  } else {
    console.error('[EVENTS] new-settings-btn NOT FOUND!');
  }

  const newMenuBtn = document.getElementById('new-menu-btn');
  if (newMenuBtn) {
    newMenuBtn.addEventListener('click', (e) => {
      showHeaderMenu(e);
    });
  }

  // 設定アイコン
  const settingsIconBtn = document.getElementById('settings-icon-btn');
  if (settingsIconBtn) {
    settingsIconBtn.addEventListener('click', () => {
      openSettingsModal();
    });
  }

  // 設定モーダルを閉じる
  const closeSettingsBtn = document.getElementById('close-settings-btn');
  if (closeSettingsBtn) {
    closeSettingsBtn.addEventListener('click', () => {
      closeSettingsModal();
    });
  }

  // 分析アイコン
  const analyticsIconBtn = document.getElementById('analytics-icon-btn');
  if (analyticsIconBtn) {
    analyticsIconBtn.addEventListener('click', () => {
      if (typeof openAnalyticsModal === 'function') {
        openAnalyticsModal();
      }
    });
  }

  // 分析モーダルを閉じる
  const closeAnalyticsBtn = document.getElementById('close-analytics-btn');
  if (closeAnalyticsBtn) {
    closeAnalyticsBtn.addEventListener('click', () => {
      if (typeof closeAnalyticsModal === 'function') {
        closeAnalyticsModal();
      }
    });
  }

  // 分析モーダル外クリックで閉じる
  const analyticsModal = document.getElementById('analytics-modal');
  if (analyticsModal) {
    analyticsModal.addEventListener('click', (e) => {
      if (e.target.id === 'analytics-modal') {
        if (typeof closeAnalyticsModal === 'function') {
          closeAnalyticsModal();
        }
      }
    });
  }

  // テンプレート選択ボタン
  const templateSelectBtn = document.getElementById('template-select-btn');
  if (templateSelectBtn) {
    const handleTemplateOpen = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof openTemplateModal === 'function') {
        openTemplateModal();
      }
    };
    templateSelectBtn.addEventListener('click', handleTemplateOpen);
    templateSelectBtn.addEventListener('touchend', handleTemplateOpen);
  }

  // テンプレートモーダルを閉じる
  const closeTemplateBtn = document.getElementById('close-template-btn');
  const templateCloseBtn = document.getElementById('template-close-btn');
  if (closeTemplateBtn) {
    closeTemplateBtn.addEventListener('click', () => {
      if (typeof closeTemplateModal === 'function') {
        closeTemplateModal();
      }
    });
  }
  if (templateCloseBtn) {
    templateCloseBtn.addEventListener('click', () => {
      if (typeof closeTemplateModal === 'function') {
        closeTemplateModal();
      }
    });
  }

  // テンプレートモーダル外クリックで閉じる
  const templateModal = document.getElementById('template-modal');
  if (templateModal) {
    templateModal.addEventListener('click', (e) => {
      if (e.target.id === 'template-modal') {
        if (typeof closeTemplateModal === 'function') {
          closeTemplateModal();
        }
      }
    });
  }

  // テンプレート追加ボタン（フォーム表示）
  const addTemplateBtn = document.getElementById('add-template-btn');
  if (addTemplateBtn) {
    const handleAddTemplate = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof showTemplateInputForm === 'function') {
        showTemplateInputForm();
      }
    };
    addTemplateBtn.addEventListener('click', handleAddTemplate);
    addTemplateBtn.addEventListener('touchend', handleAddTemplate);
  }

  // テンプレートフォーム保存ボタン
  const templateSaveBtn = document.getElementById('template-save-btn');
  if (templateSaveBtn) {
    const handleTemplateSave = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof saveTemplateFromForm === 'function') {
        saveTemplateFromForm();
      }
    };
    templateSaveBtn.addEventListener('click', handleTemplateSave);
    templateSaveBtn.addEventListener('touchend', handleTemplateSave);
  }

  // テンプレートフォームキャンセルボタン
  const templateCancelBtn = document.getElementById('template-cancel-btn');
  if (templateCancelBtn) {
    const handleTemplateCancel = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof hideTemplateInputForm === 'function') {
        hideTemplateInputForm();
      }
    };
    templateCancelBtn.addEventListener('click', handleTemplateCancel);
    templateCancelBtn.addEventListener('touchend', handleTemplateCancel);
  }

  // カレンダーアイコン
  const calendarIconBtn = document.getElementById('calendar-icon-btn');
  if (calendarIconBtn) {
    calendarIconBtn.addEventListener('click', () => {
      if (typeof openCalendarModal === 'function') {
        openCalendarModal();
      }
    });
  }

  // カレンダーモーダルを閉じる
  const closeCalendarBtn = document.getElementById('close-calendar-btn');
  if (closeCalendarBtn) {
    closeCalendarBtn.addEventListener('click', () => {
      if (typeof closeCalendarModal === 'function') {
        closeCalendarModal();
      }
    });
  }

  // カレンダーモーダル外クリックで閉じる
  const calendarModal = document.getElementById('calendar-modal');
  if (calendarModal) {
    calendarModal.addEventListener('click', (e) => {
      if (e.target.id === 'calendar-modal') {
        if (typeof closeCalendarModal === 'function') {
          closeCalendarModal();
        }
      }
    });
  }

  // カレンダーナビゲーション
  const calendarPrevBtn = document.getElementById('calendar-prev-btn');
  const calendarNextBtn = document.getElementById('calendar-next-btn');
  if (calendarPrevBtn) {
    calendarPrevBtn.addEventListener('click', () => {
      if (typeof goToPreviousMonth === 'function') {
        goToPreviousMonth();
      }
    });
  }
  if (calendarNextBtn) {
    calendarNextBtn.addEventListener('click', () => {
      if (typeof goToNextMonth === 'function') {
        goToNextMonth();
      }
    });
  }

  // 設定保存
  const saveSettingsBtn = document.getElementById('save-settings-btn');
  if (saveSettingsBtn) {
    saveSettingsBtn.addEventListener('click', () => {
      saveSettings();
    });
  }

  // ルーティン追加
  const addRoutineBtn = document.getElementById('add-routine-btn');
  if (addRoutineBtn) {
    addRoutineBtn.addEventListener('click', () => {
      addRoutine();
    });
  }

  // 完了済み折りたたみ
  const completedToggle = document.getElementById('completed-toggle');
  const completedContent = document.getElementById('completed-content');
  if (completedToggle && completedContent) {
    completedToggle.addEventListener('click', () => {
      completedToggle.classList.toggle('open');
      completedContent.classList.toggle('open');
    });
  }

  // FAB（新規作成）
  const createTaskBtn = document.getElementById('create-task-btn');
  if (createTaskBtn) {
    createTaskBtn.addEventListener('click', () => {
      openCreateModal();
    });
  }

  // モーダル閉じる
  const closeModalBtn = document.getElementById('close-modal-btn');
  if (closeModalBtn) {
```

### events-02-modals.js

```javascript
    closeModalBtn.addEventListener('click', () => {
      closeModal();
    });
  }

  const cancelBtn = document.getElementById('cancel-btn');
  if (cancelBtn) {
    cancelBtn.addEventListener('click', () => {
      closeModal();
    });
  }

  // モーダル外クリックで閉じる
  const taskModal = document.getElementById('task-modal');
  if (taskModal) {
    taskModal.addEventListener('click', (e) => {
      if (e.target.id === 'task-modal') {
        closeModal();
      }
    });
  }

  const settingsModal = document.getElementById('settings-modal');
  if (settingsModal) {
    settingsModal.addEventListener('click', (e) => {
      if (e.target.id === 'settings-modal') {
        closeSettingsModal();
      }
    });
  }

  // 保存ボタン
  const saveBtnElement = document.getElementById('save-btn');
  if (saveBtnElement) {
    const handleSaveTask = (e) => {
      e.preventDefault();
      e.stopPropagation();
      saveTask();
    };
    saveBtnElement.addEventListener('click', handleSaveTask);
    saveBtnElement.addEventListener('touchend', handleSaveTask);
  }

  // 削除ボタン
  const deleteBtn = document.getElementById('delete-btn');
  if (deleteBtn) {
    deleteBtn.addEventListener('click', () => {
      deleteCurrentTask();
    });
  }

  // タイトル入力時の文字数カウント
  const titleInput = document.getElementById('task-title');
  if (titleInput) {
    titleInput.addEventListener('input', () => {
      const count = titleInput.value.length;
      const charCount = document.getElementById('title-char-count');
      const saveBtn = document.getElementById('save-btn');
      if (charCount) charCount.textContent = count;
      if (saveBtn) saveBtn.disabled = count === 0;
    });

    // Enterキーで保存（タイトル入力時）
    titleInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && titleInput.value.trim()) {
        saveTask();
      }
    });
  }

  // タイマーボタン
  const timerToggleBtn = document.getElementById('timer-toggle-btn');
  if (timerToggleBtn) {
    timerToggleBtn.addEventListener('click', (e) => {
      e.preventDefault();
      if (!editingTaskId) return;

      const task = getTaskById(editingTaskId);
      if (!task) return;

      if (task.isTimerRunning) {
        stopTimer(editingTaskId);
      } else {
        startTimer(editingTaskId);
      }

      updateTimerDisplay(editingTaskId);
    });
  }

  // クイック入力
  const quickInput = document.getElementById('quick-add-input');
  const quickAddForm = document.getElementById('quick-add-form');
  const quickDateBtn = document.getElementById('quick-date-btn');
  const quickDatetimePanel = document.getElementById('quick-datetime-panel');
  const quickDateInput = document.getElementById('quick-add-date');
  const quickDuration = document.getElementById('quick-add-duration');
  const quickDatetimeClose = document.getElementById('quick-datetime-close');
  const quickHistoryBtn = document.getElementById('quick-history-btn');
  const quickHistoryTags = document.getElementById('quick-history-tags');

  // カレンダーボタンのクリック
  if (quickDateBtn && quickDatetimePanel) {
    quickDateBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      if (quickDatetimePanel.style.display === 'none') {
        quickDatetimePanel.style.display = 'block';
      } else {
        quickDatetimePanel.style.display = 'none';
      }
    });
  }

  // 日時パネルを閉じる
  if (quickDatetimeClose && quickDatetimePanel) {
    quickDatetimeClose.addEventListener('click', (e) => {
      e.preventDefault();
      quickDatetimePanel.style.display = 'none';
    });
  }

  // 日時選択時
  if (quickDateInput && quickDateBtn) {
    quickDateInput.addEventListener('change', () => {
      if (quickDateInput.value) {
        quickDateBtn.classList.add('has-date');
      } else {
        quickDateBtn.classList.remove('has-date');
      }
    });
  }

  // パネルの外側クリックで閉じる
  document.addEventListener('click', (e) => {
    if (quickDatetimePanel && !quickDatetimePanel.contains(e.target) && quickDateBtn && !quickDateBtn.contains(e.target)) {
      quickDatetimePanel.style.display = 'none';
    }
  });

  if (quickAddForm && quickInput) {
    quickAddForm.addEventListener('submit', (e) => {
    e.preventDefault();
    if (quickInput.value.trim()) {
      const title = quickInput.value.trim();
      const durationValue = quickDuration ? quickDuration.value : '';
      const duration = durationValue ? parseInt(durationValue) : null;

      // 期限日のみ（時刻なし）
      let dueDate = null;
      let startTime = null;

      // 自然言語入力から解析されたデータを取得
      const naturalLangResult = typeof processNaturalInput === 'function' ? processNaturalInput(title) : null;

      if (naturalLangResult && naturalLangResult.hasDatetime) {
        // 自然言語入力から日付が解析された場合
        dueDate = naturalLangResult.dueDate;
        startTime = naturalLangResult.startTime;
      } else if (quickDateInput.value) {
        // ユーザーが手動で日付を指定した場合
        dueDate = new Date(quickDateInput.value + 'T00:00:00').toISOString();
      } else {
        // 日付未指定の場合は今日の日付を設定
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        dueDate = new Date(`${year}-${month}-${day}T00:00:00`).toISOString();
      }

      // 自然言語入力から日時が抽出された場合、タスク名から日付部分を削除
      const finalTitle = naturalLangResult && naturalLangResult.hasDatetime ? naturalLangResult.taskTitle : title;

      // 新規タスク作成
      const tasks = getTasks();
      const now = new Date().toISOString();
      const task = {
        id: generateUUID(),
        title: finalTitle,
        memo: '',
        dueDate: dueDate,
        isCompleted: false,
        createdAt: now,
        updatedAt: now,
        parentId: null,
        isTutorial: false,
        totalTime: 0,
        isTimerRunning: false,
        timerStartTime: null,
        duration: duration,
        startTime: startTime,
        endTime: null,
        urgent: false,
        priority: ''
      };
      tasks.unshift(task);
      saveTasks(tasks);

      // 履歴に追加
      if (typeof addToTaskHistory === 'function') {
        addToTaskHistory(finalTitle, startTime, null, 20);
        try {
          document.dispatchEvent(new CustomEvent('task:history:updated'));
        } catch (e) {
          console.warn('CustomEvent dispatch failed', e);
        }
      }

      quickInput.value = '';
      if (quickDateInput) quickDateInput.value = '';
      if (quickDuration) quickDuration.value = '';
      if (quickDatetimePanel) quickDatetimePanel.style.display = 'none';
      if (quickDateBtn) quickDateBtn.classList.remove('has-date');
      renderTasks();
    }
    });
  }

  // ---- 履歴タグの初期化とイベント ----
  function renderHistoryTags() {
    if (!quickHistoryTags) return;
    quickHistoryTags.innerHTML = '';

    const history = typeof getTaskHistory === 'function' ? getTaskHistory(10) : [];
    history.forEach((item) => {
      const itemTitle = typeof item === 'string' ? item : (item.title || '');
      const itemStartTime = typeof item === 'object' ? item.startTime : null;
      const itemEndTime = typeof item === 'object' ? item.endTime : null;

      const tag = document.createElement('button');
      tag.type = 'button';
      tag.className = 'quick-history-tag';
      tag.textContent = itemTitle;
      tag.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();

        // タスクを即座に作成
        const tasks = getTasks();
        const now = new Date().toISOString();

        // 今日の日付を設定
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        const todayDate = new Date(`${year}-${month}-${day}T00:00:00`).toISOString();

        // 履歴からのタスク作成の場合、保存された時刻情報を使用
        let finalTitle = itemTitle;
        let finalStartTime = itemStartTime;
        let finalDueDate = todayDate;

        const task = {
          id: generateUUID(),
          title: finalTitle,
          memo: '',
          dueDate: finalDueDate,
          isCompleted: false,
          createdAt: now,
          updatedAt: now,
          parentId: null,
          isTutorial: false,
          totalTime: 0,
          isTimerRunning: false,
          timerStartTime: null,
          duration: null,
          startTime: finalStartTime,
          endTime: itemEndTime,
          urgent: false,
          priority: ''
        };
        tasks.unshift(task);
        saveTasks(tasks);

        // 履歴を更新
        if (typeof addToTaskHistory === 'function') {
          addToTaskHistory(task.title, task.startTime, task.endTime, 20);
          try {
            document.dispatchEvent(new CustomEvent('task:history:updated'));
          } catch (e) {
            console.warn('CustomEvent dispatch failed', e);
          }
        }

        renderTasks();
      });

      quickHistoryTags.appendChild(tag);
    });
  }

  // 履歴ボタンのクリック（履歴タグの表示/非表示を切り替え）
  if (quickHistoryBtn && quickHistoryTags) {
    quickHistoryBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      const isVisible = quickHistoryTags.style.display === 'flex';
      if (isVisible) {
        quickHistoryTags.style.display = 'none';
      } else {
        renderHistoryTags();
        quickHistoryTags.style.display = 'flex';
      }
    });
  }

  // 初期描画（最初は非表示）
  if (quickHistoryTags) {
    quickHistoryTags.style.display = 'none';
  }

  // 履歴更新時に再描画
  document.addEventListener('task:history:updated', () => {
    renderHistoryTags();
  });

  // 絞り込みボタン
  const filterUrgentBtn = document.getElementById('filter-urgent');
  const filterHighPriorityBtn = document.getElementById('filter-high-priority');
  const filterClearBtn = document.getElementById('filter-clear');

  if (filterUrgentBtn && filterHighPriorityBtn) {
    filterUrgentBtn.addEventListener('click', () => {
      currentFilter = currentFilter === 'urgent' ? null : 'urgent';
      filterUrgentBtn.classList.toggle('active');
      filterHighPriorityBtn.classList.remove('active');
      renderTasks();
    });
```

### events-03-task-input.js

```javascript
    });
  }

  if (filterHighPriorityBtn && filterUrgentBtn) {
    filterHighPriorityBtn.addEventListener('click', () => {
      currentFilter = currentFilter === 'high-priority' ? null : 'high-priority';
      filterHighPriorityBtn.classList.toggle('active');
      filterUrgentBtn.classList.remove('active');
      renderTasks();
    });
  }

  if (filterClearBtn && filterUrgentBtn && filterHighPriorityBtn) {
    filterClearBtn.addEventListener('click', () => {
      currentFilter = null;
      filterUrgentBtn.classList.remove('active');
      filterHighPriorityBtn.classList.remove('active');
      renderTasks();
    });
  }

  // サブタスク追加ボタン
  const addSubtaskBtn = document.getElementById('add-subtask-btn');
  if (addSubtaskBtn) {
    addSubtaskBtn.addEventListener('click', () => {
      addSubtask();
    });
  }

  // 時間オーバー警告モーダルのイベント
  const closeOverloadBtn = document.getElementById('close-overload-btn');
  const overloadCancelBtn = document.getElementById('overload-cancel-btn');
  const overloadAdjustBtn = document.getElementById('overload-adjust-btn');
  const timeOverloadModal = document.getElementById('time-overload-modal');

  if (closeOverloadBtn) {
    closeOverloadBtn.addEventListener('click', () => {
      if (typeof closeTimeOverloadModal === 'function') {
        closeTimeOverloadModal();
      }
    });
  }

  if (overloadCancelBtn) {
    overloadCancelBtn.addEventListener('click', () => {
      if (typeof closeTimeOverloadModal === 'function') {
        closeTimeOverloadModal();
      }
    });
  }

  if (overloadAdjustBtn) {
    overloadAdjustBtn.addEventListener('click', () => {
      // 調整ボタンは現在モーダルを閉じるだけ（タスク一覧で個別に調整）
      if (typeof closeTimeOverloadModal === 'function') {
        closeTimeOverloadModal();
      }
    });
  }

  if (timeOverloadModal) {
    timeOverloadModal.addEventListener('click', (e) => {
      if (e.target.id === 'time-overload-modal') {
        if (typeof closeTimeOverloadModal === 'function') {
          closeTimeOverloadModal();
        }
      }
    });
  }

  // スクロール連動で24時間ゲージを更新（スロットリング）
  const tasksListContainer = document.querySelector('.main-content');
  if (tasksListContainer) {
    let lastCall = 0;
    const throttleMs = 150;
    let scrollTimeout = null;
    let isScrolling = false;

    tasksListContainer.addEventListener('scroll', () => {
      const now = Date.now();
      if (now - lastCall < throttleMs) return;
      lastCall = now;

      // 画面上部に見える最初の date-separator を探す
      const separators = document.querySelectorAll('.date-separator');
      let topMostDate = null;
      let topMostOffset = Infinity;
      separators.forEach(sep => {
        const rect = sep.getBoundingClientRect();
        // ビューポート上部付近（ヘッダーなどを考慮して 80px 下）にあるものを検出
        const offset = Math.abs(rect.top - 80);
        if (rect.top <= 120 && offset < topMostOffset) {
          topMostOffset = offset;
          topMostDate = sep.dataset.date || null;
        }
      });

      // 見つかった日付を渡してゲージを更新
      if (topMostDate !== null) {
        updateTimeGauge(topMostDate || undefined);
      }

      // クイック入力のスクロール時の表示/非表示制御
      if (quickAddForm) {
        // スクロール中はクイック入力を非表示
        if (!isScrolling) {
          isScrolling = true;
          quickAddForm.classList.add('hidden');
        }

        // 既存のタイムアウトをクリア
        if (scrollTimeout) {
          clearTimeout(scrollTimeout);
        }

        // スクロール停止後3秒で再表示
        scrollTimeout = setTimeout(() => {
          isScrolling = false;
          quickAddForm.classList.remove('hidden');
        }, 3000);
      }
    });
  }

  // ========================================
  // 複数選択モード関連
  // ========================================

  // 複数選択トグルボタン（ゲージ下部のボタン - 旧UI）
  const bulkSelectToggleBtn = document.getElementById('bulk-select-toggle-btn');
  if (bulkSelectToggleBtn) {
    bulkSelectToggleBtn.addEventListener('click', () => {
      if (typeof toggleSelectionMode === 'function') {
        toggleSelectionMode();
      }
    });
  }

  // 複数選択トグルボタン（新UI）
  const newBulkSelectToggleBtn = document.getElementById('new-bulk-select-toggle-btn');
  if (newBulkSelectToggleBtn) {
    newBulkSelectToggleBtn.addEventListener('click', () => {
      if (typeof toggleSelectionMode === 'function') {
        toggleSelectionMode();
      }
    });
  }

  // 選択モードボタン（新しいツールバーのボタン）
  const toolbarSelectModeBtn = document.getElementById('toolbar-select-mode-btn');
  if (toolbarSelectModeBtn) {
    toolbarSelectModeBtn.addEventListener('click', () => {
      if (typeof toggleSelectionMode === 'function') {
        toggleSelectionMode();
      }
    });
  }

  // 一括完了ボタン
  const bulkCompleteBtn = document.getElementById('bulk-complete-btn');
  if (bulkCompleteBtn) {
    bulkCompleteBtn.addEventListener('click', () => {
      if (typeof bulkCompleteActions === 'function') {
        bulkCompleteActions();
      }
    });
  }

  // 一括削除ボタン
  const bulkDeleteBtn = document.getElementById('bulk-delete-btn');
  if (bulkDeleteBtn) {
    bulkDeleteBtn.addEventListener('click', () => {
      if (typeof bulkDeleteTasks === 'function') {
        bulkDeleteTasks();
      }
    });
  }

  // 選択キャンセルボタン
  const bulkCancelBtn = document.getElementById('bulk-cancel-btn');
  if (bulkCancelBtn) {
    bulkCancelBtn.addEventListener('click', () => {
      if (typeof toggleSelectionMode === 'function') {
        toggleSelectionMode();
      }
    });
  }

  // 全選択/全解除ボタン
  const bulkSelectAllBtn = document.getElementById('bulk-select-all-btn');
  if (bulkSelectAllBtn) {
    bulkSelectAllBtn.addEventListener('click', () => {
      if (typeof bulkSelectAll === 'function') {
        bulkSelectAll();
      }
    });
  }

  // 日付変更ボタン
  const bulkDateBtn = document.getElementById('bulk-date-btn');
  if (bulkDateBtn) {
    bulkDateBtn.addEventListener('click', (e) => {
      if (typeof bulkChangeDateTasks === 'function') {
        bulkChangeDateTasks(e);
      }
    });
  }

  // 優先度変更ボタン
  const bulkPriorityBtn = document.getElementById('bulk-priority-btn');
  if (bulkPriorityBtn) {
    bulkPriorityBtn.addEventListener('click', (e) => {
      if (typeof bulkChangePriorityTasks === 'function') {
        bulkChangePriorityTasks(e);
      }
    });
  }

  // ========================================
  // クイックアクション関連
  // ========================================

  // 今日のタスクを一括完了
  const quickCompleteTodayBtn = document.getElementById('quick-complete-today-btn');
  if (quickCompleteTodayBtn) {
    quickCompleteTodayBtn.addEventListener('click', () => {
      if (typeof quickCompleteToday === 'function') {
        quickCompleteToday();
      }
    });
  }

  // 期限切れタスクを明日に移動
  const quickMoveOverdueBtn = document.getElementById('quick-move-overdue-btn');
  if (quickMoveOverdueBtn) {
    quickMoveOverdueBtn.addEventListener('click', () => {
      if (typeof quickMoveOverdueToTomorrow === 'function') {
        quickMoveOverdueToTomorrow();
      }
    });
  }

  // 完了タスクをアーカイブ
  const quickArchiveCompletedBtn = document.getElementById('quick-archive-completed-btn');
  if (quickArchiveCompletedBtn) {
    quickArchiveCompletedBtn.addEventListener('click', () => {
      if (typeof quickArchiveCompleted === 'function') {
        quickArchiveCompleted();
      }
    });
  }

  // 今日の未完了タスクを明日にコピー
  const quickCopyTodayBtn = document.getElementById('quick-copy-today-btn');
  if (quickCopyTodayBtn) {
    quickCopyTodayBtn.addEventListener('click', () => {
      if (typeof quickCopyTodayToTomorrow === 'function') {
        quickCopyTodayToTomorrow();
      }
    });
  }

  // ========================================
  // セクション追加ボタン（新UIの+ボタン）
  // ========================================
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('new-section-add-btn')) {
      const dateKey = e.target.dataset.date;
      if (dateKey !== undefined) {
        // タスク作成モーダルを開く
        if (typeof openCreateModal === 'function') {
          openCreateModal();

          // モーダルが開いた後に期限日を設定
          setTimeout(() => {
            const dueDateInput = document.getElementById('task-due-date');
            if (dueDateInput && dateKey) {
              // dateKeyを「YYYY-MM-DD」形式の日付に変換
              // dateKeyは 'today', 'tomorrow', 'future_...' などの形式
              const dateObj = new Date(dateKey);
              const year = dateObj.getFullYear();
              const month = String(dateObj.getMonth() + 1).padStart(2, '0');
              const day = String(dateObj.getDate()).padStart(2, '0');
              dueDateInput.value = `${year}-${month}-${day}`;
            }
          }, 100);
        }
      }
    }
  });

  // ========================================
  // 新ゲージナビゲーションボタン（新UIのゲージ日付切り替え）
  // ========================================
  const newGaugePrevBtn = document.getElementById('new-gauge-prev');
  const newGaugeNextBtn = document.getElementById('new-gauge-next');

  if (newGaugePrevBtn) {
    newGaugePrevBtn.addEventListener('click', () => {
      if (typeof changeGaugeDate === 'function') {
        changeGaugeDate(-1);
        // 新UIゲージを再レンダリング
        if (typeof renderNewGauge === 'function') {
          renderNewGauge(currentGaugeDate);
        }
      }
    });
  }

  if (newGaugeNextBtn) {
    newGaugeNextBtn.addEventListener('click', () => {
      if (typeof changeGaugeDate === 'function') {
        changeGaugeDate(1);
        // 新UIゲージを再レンダリング
        if (typeof renderNewGauge === 'function') {
          renderNewGauge(currentGaugeDate);
        }
      }
    });
  }

  // ========================================
  // 新UI: クイック入力＆完了済みセクション初期化
  // ========================================
  if (typeof initQuickInput === 'function') {
    initQuickInput();
  }
  if (typeof initCompletedToggle === 'function') {
    initCompletedToggle();
  }
}

// タブUIは廃止しました。表示切替は showTasks/showTrash を使用します。
```

### feedback.js

```javascript
// ========================================
// フェーズ 6.8: エラーハンドリングとユーザーフィードバック
// ========================================

/**
 * エラーメッセージ定義
 */
const ERROR_MESSAGES = {
  // バリデーションエラー
  INVALID_DATE: {
    icon: '⚠️',
    message: '期限日が無効です。YYYY-MM-DD 形式で入力してください',
    type: 'warning'
  },
  INVALID_TIME: {
    icon: '⚠️',
    message: '時刻が無効です。HH:MM 形式で入力してください',
    type: 'warning'
  },
  EMPTY_TITLE: {
    icon: '⚠️',
    message: 'タスク名を入力してください',
    type: 'warning'
  },
  INVALID_DURATION: {
    icon: '⚠️',
    message: '所要時間が無効です。30分以上を選択してください',
    type: 'warning'
  },

  // ネットワークエラー
  NETWORK_ERROR: {
    icon: '❌',
    message: 'ネットワーク接続エラー。インターネット接続を確認してください',
    type: 'error'
  },
  TIMEOUT_ERROR: {
    icon: '❌',
    message: 'リクエストがタイムアウトしました。再度お試しください',
    type: 'error'
  },

  // ストレージエラー
  STORAGE_ERROR: {
    icon: '❌',
    message: 'データの保存に失敗しました。再度お試しください',
    type: 'error'
  },
  QUOTA_ERROR: {
    icon: '❌',
    message: 'ストレージが満杯です。古いデータを削除してください',
    type: 'error'
  },

  // 成功メッセージ
  TASK_ADDED: {
    icon: '✅',
    message: 'タスクを追加しました',
    type: 'success'
  },
  TASK_UPDATED: {
    icon: '✅',
    message: 'タスクを更新しました',
    type: 'success'
  },
  TASK_DELETED: {
    icon: '✅',
    message: 'タスクを削除しました',
    type: 'success'
  },
  BULK_OPERATION_SUCCESS: {
    icon: '✅',
    message: '操作が完了しました',
    type: 'success'
  },
  DATA_SYNCED: {
    icon: 'ℹ️',
    message: 'データを同期しました',
    type: 'info'
  }
};

/**
 * トースト通知を表示
 */
function showToast(messageKey, duration = 3000, customMessage = null) {
  const config = ERROR_MESSAGES[messageKey] || {
    icon: 'ℹ️',
    message: customMessage || messageKey,
    type: 'info'
  };

  const toast = document.createElement('div');
  toast.className = `toast toast-${config.type}`;
  toast.setAttribute('role', 'status');
  toast.setAttribute('aria-live', 'polite');
  toast.setAttribute('aria-atomic', 'true');

  toast.innerHTML = `
    <span class="toast-icon">${config.icon}</span>
    <span class="toast-message">${config.message}</span>
    <button class="toast-close" aria-label="通知を閉じる">&times;</button>
  `;

  // トースト容器を取得または作成
  let toastContainer = document.getElementById('toast-container');
  if (!toastContainer) {
    toastContainer = document.createElement('div');
    toastContainer.id = 'toast-container';
    toastContainer.className = 'toast-container';
    document.body.appendChild(toastContainer);
  }

  toastContainer.appendChild(toast);

  // クローズボタン
  const closeBtn = toast.querySelector('.toast-close');
  closeBtn.addEventListener('click', () => {
    toast.classList.add('fade-out');
    setTimeout(() => toast.remove(), 300);
  });

  // アニメーション
  setTimeout(() => {
    toast.classList.add('show');
  }, 10);

  // 自動削除
  setTimeout(() => {
    if (toast.parentElement) {
      toast.classList.add('fade-out');
      setTimeout(() => toast.remove(), 300);
    }
  }, duration);

  return toast;
}

/**
 * 削除時のアンドゥ機能
 */
function showUndoNotification(message, undoCallback, undoDuration = 5000) {
  const toast = document.createElement('div');
  toast.className = 'toast toast-undo';
  toast.setAttribute('role', 'status');
  toast.setAttribute('aria-live', 'assertive');

  toast.innerHTML = `
    <span class="toast-message">${message}</span>
    <button class="toast-undo-btn" aria-label="アンドゥ">アンドゥ</button>
  `;

  // トースト容器
  let toastContainer = document.getElementById('toast-container');
  if (!toastContainer) {
    toastContainer = document.createElement('div');
    toastContainer.id = 'toast-container';
    toastContainer.className = 'toast-container';
    document.body.appendChild(toastContainer);
  }

  toastContainer.appendChild(toast);

  let undoClicked = false;

  // アンドゥボタン
  const undoBtn = toast.querySelector('.toast-undo-btn');
  undoBtn.addEventListener('click', () => {
    undoClicked = true;
    if (undoCallback) {
      undoCallback();
    }
    toast.classList.add('fade-out');
    setTimeout(() => toast.remove(), 300);
  });

  // アニメーション
  setTimeout(() => {
    toast.classList.add('show');
  }, 10);

  // 自動ロールバック（アンドゥが実行されなかった場合）
  setTimeout(() => {
    if (!undoClicked && toast.parentElement) {
      toast.classList.add('fade-out');
      setTimeout(() => toast.remove(), 300);
    }
  }, undoDuration);

  return toast;
}

/**
 * ローディング状態を表示
 */
function showLoadingState(message = 'データを読み込み中...') {
  // 既存のローディング表示がある場合はスキップ
  if (document.getElementById('loading-overlay')) {
    return;
  }

  const overlay = document.createElement('div');
  overlay.id = 'loading-overlay';
  overlay.className = 'loading-overlay';
  overlay.setAttribute('role', 'status');
  overlay.setAttribute('aria-live', 'polite');

  overlay.innerHTML = `
    <div class="loading-spinner">
      <div class="spinner"></div>
      <p class="loading-message">${message}</p>
    </div>
  `;

  document.body.appendChild(overlay);

  // タイムアウト処理（10秒以上応答がない場合）
  const timeoutId = setTimeout(() => {
    showLoadingTimeout(overlay);
  }, 10000);

  overlay.dataset.timeoutId = timeoutId;

  return overlay;
}

/**
 * ローディングタイムアウト時の処理
 */
function showLoadingTimeout(overlay) {
  const spinner = overlay.querySelector('.loading-spinner');
  const message = overlay.querySelector('.loading-message');

  spinner.innerHTML = `
    <p class="timeout-message">読み込みに時間がかかっています</p>
    <button class="btn btn-secondary retry-btn">再試行</button>
  `;

  const retryBtn = spinner.querySelector('.retry-btn');
  retryBtn.addEventListener('click', () => {
    hideLoadingState();
    // 再試行処理はコールバック関数で実装
    document.dispatchEvent(new Event('retry:loading'));
  });
}

/**
 * ローディング状態を隠す
 */
function hideLoadingState() {
  const overlay = document.getElementById('loading-overlay');
  if (overlay) {
    const timeoutId = overlay.dataset.timeoutId;
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    overlay.classList.add('fade-out');
    setTimeout(() => overlay.remove(), 300);
  }
}

/**
 * スケルトンスクリーン（プレースホルダー）を表示
 */
function showSkeletonScreen(container, count = 5) {
  if (!container) return;

  const skeleton = document.createElement('div');
  skeleton.className = 'skeleton-screen';

  for (let i = 0; i < count; i++) {
    const item = document.createElement('div');
    item.className = 'skeleton-item';
    item.innerHTML = `
      <div class="skeleton-line skeleton-title"></div>
      <div class="skeleton-line skeleton-text"></div>
      <div class="skeleton-line skeleton-text short"></div>
    `;
    skeleton.appendChild(item);
  }

  container.innerHTML = '';
  container.appendChild(skeleton);
}

/**
 * スケルトンスクリーンを削除
 */
function hideSkeletonScreen(container) {
  const skeleton = container?.querySelector('.skeleton-screen');
  if (skeleton) {
    skeleton.remove();
  }
}

/**
 * オフライン状態を表示
 */
function showOfflineBanner() {
  // 既存のバナーがある場合はスキップ
  if (document.getElementById('offline-banner')) {
    return;
  }

  const banner = document.createElement('div');
  banner.id = 'offline-banner';
  banner.className = 'offline-banner';
  banner.setAttribute('role', 'status');
  banner.setAttribute('aria-live', 'polite');

  banner.innerHTML = `
    <div class="offline-banner-content">
      <span class="offline-icon">📡</span>
      <span class="offline-text">オフラインモード - インターネット接続がありません</span>
    </div>
  `;

  document.body.insertBefore(banner, document.body.firstChild);

  return banner;
}

/**
 * オフラインバナーを隠す
 */
function hideOfflineBanner() {
  const banner = document.getElementById('offline-banner');
  if (banner) {
    banner.classList.add('fade-out');
    setTimeout(() => banner.remove(), 300);
  }
}

/**
 * 同期中インジケーターを表示
 */
function showSyncIndicator() {
  let indicator = document.getElementById('sync-indicator');

  if (!indicator) {
    indicator = document.createElement('div');
    indicator.id = 'sync-indicator';
    indicator.className = 'sync-indicator';
    indicator.setAttribute('role', 'status');
    indicator.setAttribute('aria-label', 'データを同期中');

    indicator.innerHTML = `
      <span class="sync-spinner"></span>
      <span class="sync-text">同期中...</span>
    `;

    document.body.appendChild(indicator);
  }

  indicator.classList.add('show');
  return indicator;
}

/**
 * 同期中インジケーターを隠す
 */
function hideSyncIndicator() {
  const indicator = document.getElementById('sync-indicator');
  if (indicator) {
    indicator.classList.remove('show');
  }
}

/**
 * 確認ダイアログを表示
 */
function showConfirmDialog(title, message, onConfirm, onCancel) {
  const dialog = document.createElement('div');
  dialog.className = 'confirm-dialog-overlay';
  dialog.setAttribute('role', 'alertdialog');
  dialog.setAttribute('aria-labelledby', 'confirm-dialog-title');
  dialog.setAttribute('aria-describedby', 'confirm-dialog-message');

  dialog.innerHTML = `
    <div class="confirm-dialog">
      <h2 id="confirm-dialog-title" class="confirm-dialog-title">${title}</h2>
      <p id="confirm-dialog-message" class="confirm-dialog-message">${message}</p>
      <div class="confirm-dialog-buttons">
        <button class="btn btn-secondary confirm-cancel">キャンセル</button>
        <button class="btn btn-primary confirm-ok">OK</button>
      </div>
    </div>
  `;

  document.body.appendChild(dialog);

  // イベントリスナー
  const okBtn = dialog.querySelector('.confirm-ok');
  const cancelBtn = dialog.querySelector('.confirm-cancel');

  const cleanup = () => {
    dialog.remove();
  };

  okBtn.addEventListener('click', () => {
    if (onConfirm) onConfirm();
    cleanup();
  });

  cancelBtn.addEventListener('click', () => {
    if (onCancel) onCancel();
    cleanup();
  });

  // Escape キーでキャンセル
  const escapeHandler = (e) => {
    if (e.key === 'Escape') {
      if (onCancel) onCancel();
      cleanup();
      document.removeEventListener('keydown', escapeHandler);
    }
  };
  document.addEventListener('keydown', escapeHandler);

  okBtn.focus();
  return dialog;
}

/**
 * エラー通知を表示（インラインバリデーション）
 */
function showInlineError(inputElement, errorMessage) {
  // 既存のエラー表示を削除
  removeInlineError(inputElement);

  inputElement.classList.add('input-error');
  inputElement.setAttribute('aria-invalid', 'true');

  const errorElement = document.createElement('div');
  errorElement.className = 'input-error-message';
  errorElement.setAttribute('role', 'alert');
  errorElement.textContent = errorMessage;

  inputElement.parentElement.appendChild(errorElement);

  // フォーカスがあたると自動削除
  inputElement.addEventListener('focus', () => {
    removeInlineError(inputElement);
  }, { once: true });
}

/**
 * インラインエラーを削除
 */
function removeInlineError(inputElement) {
  inputElement.classList.remove('input-error');
  inputElement.setAttribute('aria-invalid', 'false');

  const errorMessage = inputElement.parentElement?.querySelector('.input-error-message');
  if (errorMessage) {
    errorMessage.remove();
  }
}

/**
 * ネットワーク状態の監視
 */
function setupNetworkMonitoring() {
  window.addEventListener('online', () => {
    hideOfflineBanner();
    // オンライン復帰のトーストは起動時にも表示されるため、コメントアウト
    // showToast('DATA_SYNCED');
    console.log('✅ インターネット接続を復帰しました');
  });

  window.addEventListener('offline', () => {
    showOfflineBanner();
    console.log('⚠️ インターネット接続が切断されました');
  });

  // 初期状態をチェック
  if (!navigator.onLine) {
    showOfflineBanner();
  }
}

/**
 * エラーをハンドルして適切に表示
 */
function handleError(error) {
  console.error('Error:', error);

  if (error.type === 'validation') {
    showToast('EMPTY_TITLE');
  } else if (error.type === 'network') {
    showToast('NETWORK_ERROR');
  } else if (error.type === 'storage') {
    showToast('STORAGE_ERROR');
  } else if (error.type === 'timeout') {
    showToast('TIMEOUT_ERROR');
  } else {
    showToast('STORAGE_ERROR', 5000, error.message || '予期しないエラーが発生しました');
  }

  // デバッグモードでの詳細ログ
  if (localStorage.getItem('debugMode') === 'true') {
    console.error('Debug details:', {
      message: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
  }
}

/**
 * 初期化関数
 */
function initFeedback() {
  console.log('Initializing feedback features...');

  setupNetworkMonitoring();

  // グローバル関数として公開
  window.showToast = showToast;
  window.showUndoNotification = showUndoNotification;
  window.showLoadingState = showLoadingState;
  window.hideLoadingState = hideLoadingState;
  window.showOfflineBanner = showOfflineBanner;
  window.hideOfflineBanner = hideOfflineBanner;
  window.showSyncIndicator = showSyncIndicator;
  window.hideSyncIndicator = hideSyncIndicator;
  window.showConfirmDialog = showConfirmDialog;
  window.showInlineError = showInlineError;
  window.handleError = handleError;

  console.log('✅ Feedback features initialized');
}

// ページロード時に初期化
document.addEventListener('DOMContentLoaded', initFeedback);

// 動的に追加された場合の再初期化
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initFeedback);
} else {
  initFeedback();
}
```

### firebase-init.js

```javascript
/**
 * ========================================
 * Firebaseデータブリッジ & 初期化
 * ========================================
 */

// グローバルなデータキャッシュ
window.appData = {
    [STORAGE_KEYS.TASKS]: [],
    [STORAGE_KEYS.TRASH]: [],
    [STORAGE_KEYS.SETTINGS]: {}
};

// データ読み込みの完了を追跡するためのカウンター
let loadCounter = 0;
let requiredLoads = 0;
let onDataLoadComplete = null;

/**
 * Firestoreから特定のキーのデータを読み込むコールバック
 * @param {string | null} keyOrNull - データキー（またはnull）
 */
function onDataLoaded(key, keyOrNull) {
    console.log(`onDataLoaded called for key: ${key}, keyOrNull: ${keyOrNull}`);
    try {
        if (keyOrNull && keyOrNull !== 'null') {
            // Kotlinからキャッシュされたデータを取得
            const jsonData = FirestoreBridge.getCachedData(key);
            console.log(`Retrieved cached data for ${key}, length: ${jsonData ? jsonData.length : 0}`);

            if (jsonData) {
                window.appData[key] = JSON.parse(jsonData);
                console.log(`Successfully parsed data for ${key}, items:`, window.appData[key]);
            } else {
                // データがない場合はデフォルト値を使用
                if (key === STORAGE_KEYS.TASKS) window.appData[key] = [];
                if (key === STORAGE_KEYS.TRASH) window.appData[key] = [];
                if (key === STORAGE_KEYS.SETTINGS) window.appData[key] = {};
                console.log(`No cached data for ${key}, using default:`, window.appData[key]);
            }
        } else {
            // Firestoreにデータがない場合はデフォルト値を使用
            if (key === STORAGE_KEYS.TASKS) window.appData[key] = [];
            if (key === STORAGE_KEYS.TRASH) window.appData[key] = [];
            if (key === STORAGE_KEYS.SETTINGS) window.appData[key] = {};
            console.log(`No data for ${key}, using default:`, window.appData[key]);
        }
    } catch (e) {
        console.error(`Error parsing data for key ${key}:`, e);
        // エラーが発生してもデフォルト値を設定
        if (key === STORAGE_KEYS.TASKS) window.appData[key] = [];
        if (key === STORAGE_KEYS.TRASH) window.appData[key] = [];
        if (key === STORAGE_KEYS.SETTINGS) window.appData[key] = {};
    }

    loadCounter++;
    console.log(`Load progress: ${loadCounter}/${requiredLoads}`);
    if (loadCounter >= requiredLoads && typeof onDataLoadComplete === 'function') {
        console.log("All data loaded, calling onDataLoadComplete");
        onDataLoadComplete();
        onDataLoadComplete = null; // 一度だけ実行
    }
}

/**
 * アプリの初期データをFirestoreから読み込む
 * @param {function} onComplete - 全データの読み込み完了時に呼ばれるコールバック
 */
function loadInitialData(onComplete) {
    if (typeof FirestoreBridge === 'undefined') {
        console.log("Waiting for FirestoreBridge...");
        setTimeout(() => loadInitialData(onComplete), 200);
        return;
    }

    onDataLoadComplete = onComplete;
    const keysToLoad = Object.values(STORAGE_KEYS);
    requiredLoads = keysToLoad.length;
    loadCounter = 0;

    if (requiredLoads === 0) {
        onComplete();
        return;
    }

    // 各キーに対応するグローバルコールバックを動的に作成
    keysToLoad.forEach(key => {
        const callbackName = `onDataLoaded_${key}`;
        window[callbackName] = (data) => onDataLoaded(key, data);
        FirestoreBridge.loadData(key, callbackName);
    });
}

// ストレージ関数をFirestoreブリッジでオーバーライド
function saveToStorage(key, data) {
    if (typeof FirestoreBridge === 'undefined') {
        console.error("FirestoreBridge is not available.");
        return false;
    }
    // ローカルキャッシュも更新
    window.appData[key] = data;

    // デバッグ: 保存するデータを確認
    const jsonString = JSON.stringify(data);
    console.log(`Saving data for key "${key}". Data type: ${typeof data}, JSON length: ${jsonString.length}`);
    console.log(`First 100 chars: ${jsonString.substring(0, 100)}`);

    // Firestoreに保存
    FirestoreBridge.saveData(key, jsonString);
    return true;
}

function loadFromStorage(key, defaultValue = []) {
    return window.appData[key] || defaultValue;
}
```

### gauge.js

```javascript
// ========================================
// 24時間ゲージ（確定仕様 v2.0.0）
// ========================================

// 現在表示中の日付（ISO形式: YYYY-MM-DD）
let currentGaugeDate = null;

// 時間表記パターン設定
const GAUGE_TIME_PATTERNS = {
  0: Array(24).fill('').map((_, i) => `${i}`), // パターン0: 数字のみ（0-23）
  1: Array(24).fill('').map((_, i) => `${i}:00`), // パターン1: 時刻表記（0:00-23:00）
  3: Array(24).fill('').map((_, i) => i % 3 === 0 ? `${i}:00` : ''), // パターン3: 3時間区切り
  4: Array(24).fill('').map((_, i) => i % 6 === 0 ? `${i}:00` : '') // パターン4: 6時間区切り（デフォルト）
};

// 時間表記パターンを取得
function getGaugeTimePattern() {
  const pattern = localStorage.getItem('gauge-time-pattern');
  return pattern ? parseInt(pattern) : 4; // デフォルトは4（6時間区切り）
}

// 時間表記パターンを設定
function setGaugeTimePattern(pattern) {
  localStorage.setItem('gauge-time-pattern', pattern.toString());
  // ゲージを再レンダリング
  if (typeof renderNewGauge === 'function' && typeof isNewUIEnabled === 'function' && isNewUIEnabled()) {
    renderNewGauge(currentGaugeDate);
  }
}

// ゲージの日付を初期化
function initGaugeDate() {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  currentGaugeDate = formatDateISO(today);
}

// ゲージの日付を変更
function changeGaugeDate(offset) {
  if (!currentGaugeDate) initGaugeDate();

  const date = new Date(currentGaugeDate);
  date.setDate(date.getDate() + offset);
  currentGaugeDate = formatDateISO(date);

  updateGaugeDateLabel();
  updateTimeGauge(currentGaugeDate);
}

// 日付ラベルを更新
function updateGaugeDateLabel() {
  const labelEl = document.getElementById('gauge-date-label');
  const newLabelEl = document.getElementById('new-gauge-date-label');

  if (!currentGaugeDate) return;
  if (!labelEl && !newLabelEl) return;

  const date = new Date(currentGaugeDate);
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);

  const month = date.getMonth() + 1;
  const day = date.getDate();
  const weekdays = ['日', '月', '火', '水', '木', '金', '土'];
  const weekday = weekdays[date.getDay()];

  let labelText = '';
  if (formatDateISO(date) === formatDateISO(today)) {
    labelText = `今日`;
  } else if (formatDateISO(date) === formatDateISO(tomorrow)) {
    labelText = `明日`;
  } else if (formatDateISO(date) === formatDateISO(yesterday)) {
    labelText = `昨日`;
  } else {
    labelText = `${month}/${day}(${weekday})`;
  }

  // 旧UIと新UI両方を更新
  if (labelEl) labelEl.textContent = labelText;
  if (newLabelEl) newLabelEl.textContent = labelText;
}

// スワイプ検知を初期化
function initGaugeSwipe() {
  // 旧UIと新UIの両方のコンテナを取得
  const oldContainer = document.getElementById('old-time-gauge-container');
  const newContainer = document.getElementById('new-time-gauge-container');

  // スワイプハンドラーを設定する関数
  const setupSwipeHandlers = (container) => {
    if (!container) return;

    let startX = 0;
    let startY = 0;
    let isDragging = false;

    container.addEventListener('touchstart', (e) => {
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
      isDragging = true;
    }, { passive: true });

    container.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
    }, { passive: true });

    container.addEventListener('touchend', (e) => {
      if (!isDragging) return;
      isDragging = false;

      const endX = e.changedTouches[0].clientX;
      const endY = e.changedTouches[0].clientY;
      const diffX = endX - startX;
      const diffY = endY - startY;

      // 横方向のスワイプ判定（50px以上、かつ縦方向より横方向が大きい）
      if (Math.abs(diffX) > 50 && Math.abs(diffX) > Math.abs(diffY)) {
        if (diffX > 0) {
          // 右スワイプ: 前日
          changeGaugeDate(-1);
        } else {
          // 左スワイプ: 翌日
          changeGaugeDate(1);
        }
      }
    }, { passive: true });
  };

  // 旧UIと新UIの両方にスワイプハンドラーを設定
  setupSwipeHandlers(oldContainer);
  setupSwipeHandlers(newContainer);

  // ナビゲーションボタン（旧UI）
  const prevBtn = document.getElementById('gauge-prev-btn');
  const nextBtn = document.getElementById('gauge-next-btn');

  if (prevBtn) {
    prevBtn.addEventListener('click', () => changeGaugeDate(-1));
  }
  if (nextBtn) {
    nextBtn.addEventListener('click', () => changeGaugeDate(1));
  }

  // ナビゲーションボタン（新UI）
  const newPrevBtn = document.getElementById('new-gauge-prev-btn');
  const newNextBtn = document.getElementById('new-gauge-next-btn');

  if (newPrevBtn) {
    newPrevBtn.addEventListener('click', () => changeGaugeDate(-1));
  }
  if (newNextBtn) {
    newNextBtn.addEventListener('click', () => changeGaugeDate(1));
  }
}

// 時間帯のタスク一覧を表示
function showTimeSlotTasks(startMinutes, endMinutes) {
  const startHour = Math.floor(startMinutes / 60);
  const startMin = startMinutes % 60;
  const endHour = Math.floor(endMinutes / 60);
  const endMin = endMinutes % 60;

  const timeRange = `${String(startHour).padStart(2, '0')}:${String(startMin).padStart(2, '0')} ~ ${String(endHour).padStart(2, '0')}:${String(endMin).padStart(2, '0')}`;

  // 該当時間帯のタスクを取得
  const tasks = getTasks();
  const matchingTasks = tasks.filter(task => {
    if (task.isCompleted || !task.startTime || !task.endTime) return false;

    const [taskStartHour, taskStartMin] = task.startTime.split(':').map(Number);
    const [taskEndHour, taskEndMin] = task.endTime.split(':').map(Number);
    const taskStartMinutes = taskStartHour * 60 + taskStartMin;
    const taskEndMinutes = taskEndHour * 60 + taskEndMin;

    // 時間帯が重なっているかチェック
    return (taskStartMinutes < endMinutes && taskEndMinutes > startMinutes);
  });

  if (matchingTasks.length === 0) {
    alert(`${timeRange}\nこの時間帯にタスクはありません`);
    return;
  }

  // モーダルを表示
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.style.display = 'flex';

  const modalContent = document.createElement('div');
  modalContent.className = 'modal-content time-slot-modal';

  const header = document.createElement('div');
  header.className = 'modal-header';
  header.innerHTML = `
    <h2>${timeRange} のタスク</h2>
    <button class="close-btn">&times;</button>
  `;

  const body = document.createElement('div');
  body.className = 'modal-body';

  matchingTasks.forEach(task => {
    const taskDiv = document.createElement('div');
    taskDiv.className = 'time-slot-task-item';
    taskDiv.innerHTML = `
      <div class="task-title">${task.title}</div>
      <div class="task-time">🕒 ${task.startTime} ~ ${task.endTime}</div>
      ${task.memo ? `<div class="task-memo">${task.memo}</div>` : ''}
    `;
    taskDiv.addEventListener('click', () => {
      modal.remove();
      openEditModal(task.id);
    });
    body.appendChild(taskDiv);
  });

  const footer = document.createElement('div');
  footer.className = 'modal-footer';
  footer.innerHTML = `<button class="btn btn-secondary">閉じる</button>`;

  modalContent.appendChild(header);
  modalContent.appendChild(body);
  modalContent.appendChild(footer);
  modal.appendChild(modalContent);
  document.body.appendChild(modal);

  // 閉じるイベント
  const closeBtn = header.querySelector('.close-btn');
  const closeFooterBtn = footer.querySelector('.btn');

  closeBtn.addEventListener('click', () => modal.remove());
  closeFooterBtn.addEventListener('click', () => modal.remove());
  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

// 24時間ゲージ更新
// dateArg: Date オブジェクトか ISO 日付文字列（YYYY-MM-DD）を受け取る。未指定なら現在日時を使用。
function updateTimeGauge(dateArg) {
  let now = new Date();
  let targetDate = new Date(now);
  if (dateArg) {
    if (typeof dateArg === 'string') {
      // ISO 日付文字列（YYYY-MM-DD）ならその日の0時を使う
      const parts = dateArg.split('-');
      if (parts.length === 3) {
        targetDate = new Date(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]));
      }
    } else if (dateArg instanceof Date) {
      targetDate = new Date(dateArg);
      targetDate.setHours(0,0,0,0);
    }
    // ゲージの基準時刻は targetDate の午前0時からの相対として表示するため、now は targetDate の現在時刻相当を使用する
    // もし targetDate が今日でない場合は、現在時刻を targetDate の午前0時に置き換え（表示上は0%）
    const today = new Date();
    today.setHours(0,0,0,0);
    if (formatDateISO(targetDate) !== formatDateISO(today)) {
      // 表示時刻を targetDate の 0:00 に設定（経過は0）
      now = new Date(targetDate);
      now.setHours(0,0,0,0);
    }
  }
  const hours = now.getHours();
  const minutes = now.getMinutes();
  const timeText = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;

  // 現在時刻表示（旧UI）
  const currentTimeEl = document.getElementById('current-time');
  if (currentTimeEl) {
    currentTimeEl.textContent = timeText;
  }

  // 現在時刻表示（新UI）
  const newCurrentTimeEl = document.getElementById('new-current-time-display');
  if (newCurrentTimeEl) {
    newCurrentTimeEl.textContent = timeText;
  }

  // 経過時間のパーセンテージ（0:00からの経過）
  const minutesFromMidnight = hours * 60 + minutes;
  const percentElapsed = (minutesFromMidnight / (24 * 60)) * 100;

  // 経過ゲージ更新（旧UIのみ）
  const elapsedBar = document.getElementById('time-gauge-elapsed');
  if (elapsedBar) {
    elapsedBar.style.width = `${percentElapsed}%`;
  }

  // 現在時刻マーカー位置更新（旧UIのみ）
  const marker = document.getElementById('time-marker');
  if (marker) {
    marker.style.left = `${percentElapsed}%`;
  }

  // 指定日の日付で予定を集計するよう updateScheduledTasks を呼び出す
  updateScheduledTasks(dateArg);
}

// 今日の予定タスク時間を表示
// dateArg: Date オブジェクトか ISO 日付文字列（YYYY-MM-DD）。未指定なら今日を対象。
function updateScheduledTasks(dateArg) {
  // baseDate を対象日の 0:00 に設定
  let baseDate = new Date();
  baseDate.setHours(0, 0, 0, 0);
  if (dateArg) {
    if (typeof dateArg === 'string') {
      const parts = dateArg.split('-');
      if (parts.length === 3) baseDate = new Date(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]));
    } else if (dateArg instanceof Date) {
      baseDate = new Date(dateArg);
      baseDate.setHours(0,0,0,0);
    }
  }

  // 対象日のルーティンタスクを自動生成
  if (typeof createDailyRoutineTasks === 'function') {
    createDailyRoutineTasks(baseDate);
  }

  const tasks = getTasks();

  const tomorrow = new Date(baseDate);
  tomorrow.setDate(tomorrow.getDate() + 1);

  const yesterday = new Date(baseDate);
  yesterday.setDate(yesterday.getDate() - 1);

  // 変更点の説明（日本語コメント）:
  // - 期限なしタスクはゲージに含めない（今日が期限のタスクのみ対象）
  // - 完了済みタスクはゲージに含めない
  // - デイリールーティンタスクも含める（期限が今日の日付に設定されている）
  // そのため、ここでは "dueDate が存在し、かつ baseDate の範囲内" のタスクのみを抽出する
  const todayTasks = tasks.filter(task => {
    // 完了済みは除外
    if (task.isCompleted) return false;

    // 期限がある場合のみ、今日の範囲内かチェック
    if (task.dueDate) {
      const dueDate = new Date(task.dueDate);
      return dueDate >= baseDate && dueDate < tomorrow;
    }

    // 期限なしのタスクは除外
    return false;
  });

  // 前日が期限で、日をまたぐタスクを抽出（翌日分として当日に加算）
  const yesterdayTasks = tasks.filter(task => {
    if (task.isCompleted) return false;
    if (task.dueDate) {
      const dueDate = new Date(task.dueDate);
      return dueDate >= yesterday && dueDate < baseDate;
    }
    return false;
  });

  // 現在時刻（分単位）- 表示中の日付が今日の場合のみ現在時刻を使用
  const now = new Date();
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const isToday = formatDateISO(baseDate) === formatDateISO(today);

  // 今日の場合は現在時刻、それ以外の日は0:00を基準にする
  const currentMinutes = isToday ? (now.getHours() * 60 + now.getMinutes()) : 0;

  // 【重要】これから先のタスク時間を計算（重複を考慮）
  // タイムスロットを収集
  const timeSlots = [];

  todayTasks.forEach(task => {
    if (task.startTime && task.endTime) {
      const [startHour, startMin] = task.startTime.split(':').map(Number);
      const [endHour, endMin] = task.endTime.split(':').map(Number);
      let startMinutes = startHour * 60 + startMin;
      let endMinutes = endHour * 60 + endMin;

      // 日をまたぐ場合の処理
      if (endMinutes < startMinutes) {
        // タスクが日をまたぐ場合、当日分（開始時刻から24:00まで）のみ
        startMinutes = Math.max(startMinutes, currentMinutes);
        endMinutes = 24 * 60;
      } else {
        // 日をまたがない通常のタスク
        // 現在時刻より前に終了するタスクはスキップ
        if (endMinutes <= currentMinutes) return;

        // 現在進行中のタスクは現在時刻から開始
        if (startMinutes < currentMinutes) {
          startMinutes = currentMinutes;
        }
      }

      timeSlots.push({ start: startMinutes, end: endMinutes });

    } else if (task.duration) {
      // duration のみの場合は現在時刻から duration 分後まで（仮配置）
      timeSlots.push({
        start: currentMinutes,
        end: Math.min(currentMinutes + task.duration, 24 * 60)
      });
    }
  });

  // 前日から継続するタスク（今日の0:00以降の部分のみ）
  yesterdayTasks.forEach(task => {
    if (task.startTime && task.endTime) {
      const [startHour, startMin] = task.startTime.split(':').map(Number);
      const [endHour, endMin] = task.endTime.split(':').map(Number);
      const startMinutes = startHour * 60 + startMin;
      const endMinutes = endHour * 60 + endMin;

      if (endMinutes < startMinutes) {
        // 日をまたぐタスクの今日分
        if (endMinutes > currentMinutes) {
          timeSlots.push({
            start: Math.max(0, currentMinutes),
            end: endMinutes
          });
        }
      }
    }
  });

  // タイムスロットを統合（重複を排除）
  if (timeSlots.length === 0) {
    var totalDurationMinutes = 0;
  } else {
    // 開始時刻でソート
    timeSlots.sort((a, b) => a.start - b.start);

    const mergedSlots = [timeSlots[0]];
    for (let i = 1; i < timeSlots.length; i++) {
      const current = timeSlots[i];
      const last = mergedSlots[mergedSlots.length - 1];

      if (current.start <= last.end) {
        // 重複している: 統合
        last.end = Math.max(last.end, current.end);
      } else {
        // 重複していない: 新しいスロットとして追加
        mergedSlots.push(current);
      }
    }

    // 統合されたスロットの合計時間を計算
    var totalDurationMinutes = mergedSlots.reduce((sum, slot) => {
      return sum + (slot.end - slot.start);
    }, 0);
  }

  // 予定ゲージ更新（時間帯ごとに個別のブロックを作成）
  const scheduledBar = document.getElementById('time-gauge-scheduled');
  scheduledBar.innerHTML = ''; // 既存のブロックをクリア
  scheduledBar.style.display = 'block';
  scheduledBar.style.left = '0';
  scheduledBar.style.width = '100%';

  // 各タスクを時間帯ごとにブロックとして表示
  const taskBlocks = [];

  todayTasks.forEach(task => {
    if (task.startTime && task.endTime) {
      const [startHour, startMin] = task.startTime.split(':').map(Number);
      const [endHour, endMin] = task.endTime.split(':').map(Number);
      const startMinutes = startHour * 60 + startMin;
      const endMinutes = endHour * 60 + endMin;

      if (endMinutes < startMinutes) {
        // 日をまたぐ場合: 当日分のみ表示
        taskBlocks.push({
          startMinutes: startMinutes,
          endMinutes: 24 * 60,
          task: task
        });
      } else {
        taskBlocks.push({
          startMinutes: startMinutes,
          endMinutes: endMinutes,
          task: task
        });
      }
    }
  });

  // 前日から継続するタスク
  yesterdayTasks.forEach(task => {
    if (task.startTime && task.endTime) {
      const [startHour, startMin] = task.startTime.split(':').map(Number);
      const [endHour, endMin] = task.endTime.split(':').map(Number);
      const startMinutes = startHour * 60 + startMin;
      const endMinutes = endHour * 60 + endMin;

      if (endMinutes < startMinutes) {
        taskBlocks.push({
          startMinutes: 0,
          endMinutes: endMinutes,
          task: task
        });
      }
    }
  });

  // ブロックを開始時刻順にソート
  taskBlocks.sort((a, b) => a.startMinutes - b.startMinutes);

  // 各ブロックを表示
  taskBlocks.forEach(block => {
    const blockEl = document.createElement('div');
    blockEl.className = 'task-time-block';
    const leftPercent = (block.startMinutes / (24 * 60)) * 100;
    const widthPercent = ((block.endMinutes - block.startMinutes) / (24 * 60)) * 100;
    blockEl.style.left = `${leftPercent}%`;
    blockEl.style.width = `${widthPercent}%`;
    blockEl.dataset.taskId = block.task.id;
    blockEl.dataset.startTime = block.task.startTime;
    blockEl.dataset.endTime = block.task.endTime;

    // 時刻ラベルを追加
    const startHour = Math.floor(block.startMinutes / 60);
    const startMin = block.startMinutes % 60;
    const endHour = Math.floor(block.endMinutes / 60);
    const endMin = block.endMinutes % 60;
    const timeLabel = `${String(startHour).padStart(2, '0')}:${String(startMin).padStart(2, '0')}-${String(endHour).padStart(2, '0')}:${String(endMin).padStart(2, '0')}`;
    blockEl.dataset.timeLabel = timeLabel;

    // クリックイベント
    blockEl.addEventListener('click', (e) => {
      e.stopPropagation();
      showTimeSlotTasks(block.startMinutes, block.endMinutes);
    });

    scheduledBar.appendChild(blockEl);
  });

  // 【修正】空き時間と密度の計算
  const totalMinutesInDay = 24 * 60;
  // 今日の場合は残り時間、それ以外の日は24時間全体を基準にする
  const remainingTimeInDay = isToday ? (totalMinutesInDay - currentMinutes) : totalMinutesInDay;
  const freeTimeMinutes = remainingTimeInDay - totalDurationMinutes; // 空き時間

  // 自由時間ゲージ更新
  const freeBar = document.getElementById('time-gauge-free');
  if (freeTimeMinutes > 0) {
    const freeStartPercent = (currentMinutes / (24 * 60)) * 100 + (totalDurationMinutes / (24 * 60)) * 100;
    const freeWidthPercent = (freeTimeMinutes / (24 * 60)) * 100;
    freeBar.style.display = 'block';
    freeBar.style.left = `${freeStartPercent}%`;
    freeBar.style.width = `${Math.min(freeWidthPercent, 100 - freeStartPercent)}%`;
  } else {
    freeBar.style.display = 'none';
  }

  // タスク密度を計算して表示
  const remainingElement = document.getElementById('remaining-tasks');
  const newRemainingElement = document.getElementById('new-remaining-tasks');

  // 【修正】分かりやすい表示（絵文字なし・モノクロ）
  let displayText = '';
  if (freeTimeMinutes < 0) {
    // タスクが多すぎる場合
    const overMinutes = Math.abs(freeTimeMinutes);
    const overHours = Math.floor(overMinutes / 60);
    const overMins = overMinutes % 60;
    if (overHours > 0) {
      displayText = `時間オーバー: ${overHours}時間${overMins > 0 ? overMins + '分' : ''}`;
    } else {
      displayText = `時間オーバー: ${overMins}分`;
    }

    // 時間オーバー警告を表示（今日の日付の場合のみ）
    if (isToday && typeof openTimeOverloadModal === 'function') {
      // 警告モーダルを表示（1回だけ）
      if (!window.overloadModalShown) {
        window.overloadModalShown = true;
        setTimeout(() => {
          openTimeOverloadModal(freeTimeMinutes, todayTasks);
        }, 500);
      }
    }
  } else {
    // 空き時間を表示
    const hours = Math.floor(freeTimeMinutes / 60);
    const minutes = freeTimeMinutes % 60;

    if (hours > 0) {
      displayText = `空き: ${hours}時間${minutes > 0 ? minutes + '分' : ''}`;
    } else if (minutes > 0) {
      displayText = `空き: ${minutes}分`;
    } else {
      displayText = `空きなし`;
    }
  }

  // 旧UIと新UI両方を更新
  if (remainingElement) remainingElement.textContent = displayText;
  if (newRemainingElement) newRemainingElement.textContent = displayText;

  // 空き時間を記録（今日の日付の場合のみ）
  if (isToday && typeof recordDailyFreeTime === 'function') {
    recordDailyFreeTime(freeTimeMinutes);
  }

  // 新ゲージをレンダリング（新UI有効時）
  if (typeof isNewUIEnabled === 'function' && isNewUIEnabled()) {
    if (typeof renderNewGauge === 'function') {
      renderNewGauge(dateArg);
    }
  }
}

// ========================================
// 新しい24ステップゲージレンダリング
// ========================================

/**
 * 新UI用：24ステップゲージをレンダリング
 * @param {string|Date} dateArg - 対象日付（未指定なら今日）
 */
function renderNewGauge(dateArg) {
  const gaugeContainer = document.querySelector('.new-gauge-bar');
  if (!gaugeContainer) return;

  // 対象日の日付を設定
  let baseDate = new Date();
  baseDate.setHours(0, 0, 0, 0);
  if (dateArg) {
    if (typeof dateArg === 'string') {
      const parts = dateArg.split('-');
      if (parts.length === 3) {
        baseDate = new Date(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]));
      }
    } else if (dateArg instanceof Date) {
      baseDate = new Date(dateArg);
      baseDate.setHours(0, 0, 0, 0);
    }
  }

  // 24個のステップを生成
  const stepsHTML = Array.from({ length: 24 }, (_, hour) => {
    const tasks = getTasks();

    // その時間帯にタスクがあるかチェック
    const isActive = tasks.some(task => {
      if (task.isCompleted || !task.startTime || !task.endTime) return false;

      // 対象日付のタスクのみ対象
      if (task.dueDate) {
        const taskDate = new Date(task.dueDate);
        taskDate.setHours(0, 0, 0, 0);
        if (formatDateISO(taskDate) !== formatDateISO(baseDate)) return false;
      } else {
        return false;
      }

      const [startHour, startMin] = task.startTime.split(':').map(Number);
      const [endHour, endMin] = task.endTime.split(':').map(Number);
      const startMinutes = startHour * 60 + startMin;
      const endMinutes = endHour * 60 + endMin;

      // 日をまたぐ場合の処理
      if (endMinutes < startMinutes) {
        // 日をまたぐタスク
        return hour >= startHour || hour < endHour;
      } else {
        // 通常のタスク
        return hour >= startHour && hour < endHour;
      }
    });

    // 現在時刻をハイライト
    const now = new Date();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const isCurrent = formatDateISO(baseDate) === formatDateISO(today) && hour === now.getHours();

    const classes = ['new-gauge-step'];
    if (isActive) classes.push('active');
    if (isCurrent) classes.push('current-marker');

    return `<div class="${classes.join(' ')}" data-hour="${hour}"></div>`;
  }).join('');

  gaugeContainer.innerHTML = stepsHTML;

  // 時間ラベルを更新
  renderGaugeTimeLabels();

  // 現在時刻を更新
  updateNewGaugeTime(baseDate);
}

/**
 * 新UI用：時間ラベルをレンダリング
 */
function renderGaugeTimeLabels() {
  const labelsContainer = document.querySelector('.new-time-labels');
  if (!labelsContainer) return;

  const pattern = getGaugeTimePattern();
  const labels = GAUGE_TIME_PATTERNS[pattern] || GAUGE_TIME_PATTERNS[4];

  const labelsHTML = labels.map(label =>
    `<span class="new-time-label">${label}</span>`
  ).join('');

  labelsContainer.innerHTML = labelsHTML;
}

/**
 * 新UI用：ゲージの時刻表示を更新
 */
function updateNewGaugeTime(dateArg) {
  const timeEl = document.getElementById('new-current-time-display');
  if (!timeEl) return;

  let now = new Date();

  // 対象日が今日でない場合は0:00を表示
  const baseDate = dateArg ? new Date(dateArg) : new Date();
  baseDate.setHours(0, 0, 0, 0);
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  if (formatDateISO(baseDate) !== formatDateISO(today)) {
    now = new Date(baseDate);
  }

  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  timeEl.textContent = `${hours}:${minutes}`;
}
```

### gauge-01-init.js

```javascript
// ========================================
// 24時間ゲージ（確定仕様 v2.0.0）
// ========================================

// 現在表示中の日付（ISO形式: YYYY-MM-DD）
let currentGaugeDate = null;

// 時間表記パターン設定
const GAUGE_TIME_PATTERNS = {
  0: Array(24).fill('').map((_, i) => `${i}`), // パターン0: 数字のみ（0-23）
  1: Array(24).fill('').map((_, i) => `${i}:00`), // パターン1: 時刻表記（0:00-23:00）
  3: Array(24).fill('').map((_, i) => i % 3 === 0 ? `${i}:00` : ''), // パターン3: 3時間区切り
  4: Array(24).fill('').map((_, i) => i % 6 === 0 ? `${i}:00` : '') // パターン4: 6時間区切り（デフォルト）
};

// 時間表記パターンを取得
function getGaugeTimePattern() {
  const pattern = localStorage.getItem('gauge-time-pattern');
  return pattern ? parseInt(pattern) : 4; // デフォルトは4（6時間区切り）
}

// 時間表記パターンを設定
function setGaugeTimePattern(pattern) {
  localStorage.setItem('gauge-time-pattern', pattern.toString());
  // ゲージを再レンダリング
  if (typeof renderNewGauge === 'function' && typeof isNewUIEnabled === 'function' && isNewUIEnabled()) {
    renderNewGauge(currentGaugeDate);
  }
}

// ゲージの日付を初期化
function initGaugeDate() {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  currentGaugeDate = formatDateISO(today);
}

// ゲージの日付を変更
function changeGaugeDate(offset) {
  if (!currentGaugeDate) initGaugeDate();

  const date = new Date(currentGaugeDate);
  date.setDate(date.getDate() + offset);
  currentGaugeDate = formatDateISO(date);

  updateGaugeDateLabel();
  updateTimeGauge(currentGaugeDate);
}

// 日付ラベルを更新
function updateGaugeDateLabel() {
  const labelEl = document.getElementById('gauge-date-label');
  const newLabelEl = document.getElementById('new-gauge-date-label');

  if (!currentGaugeDate) return;
  if (!labelEl && !newLabelEl) return;

  const date = new Date(currentGaugeDate);
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);

  const month = date.getMonth() + 1;
  const day = date.getDate();
  const weekdays = ['日', '月', '火', '水', '木', '金', '土'];
  const weekday = weekdays[date.getDay()];

  let labelText = '';
  if (formatDateISO(date) === formatDateISO(today)) {
    labelText = `今日`;
  } else if (formatDateISO(date) === formatDateISO(tomorrow)) {
    labelText = `明日`;
  } else if (formatDateISO(date) === formatDateISO(yesterday)) {
    labelText = `昨日`;
  } else {
    labelText = `${month}/${day}(${weekday})`;
  }

  // 旧UIと新UI両方を更新
  if (labelEl) labelEl.textContent = labelText;
  if (newLabelEl) newLabelEl.textContent = labelText;
}

// スワイプ検知を初期化
function initGaugeSwipe() {
  // 旧UIと新UIの両方のコンテナを取得
  const oldContainer = document.getElementById('old-time-gauge-container');
  const newContainer = document.getElementById('new-time-gauge-container');

  // スワイプハンドラーを設定する関数
  const setupSwipeHandlers = (container) => {
    if (!container) return;

    let startX = 0;
    let startY = 0;
    let isDragging = false;

    container.addEventListener('touchstart', (e) => {
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
      isDragging = true;
    }, { passive: true });

    container.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
    }, { passive: true });

    container.addEventListener('touchend', (e) => {
      if (!isDragging) return;
      isDragging = false;

      const endX = e.changedTouches[0].clientX;
      const endY = e.changedTouches[0].clientY;
      const diffX = endX - startX;
      const diffY = endY - startY;

      // 横方向のスワイプ判定（50px以上、かつ縦方向より横方向が大きい）
      if (Math.abs(diffX) > 50 && Math.abs(diffX) > Math.abs(diffY)) {
        if (diffX > 0) {
          // 右スワイプ: 前日
          changeGaugeDate(-1);
        } else {
          // 左スワイプ: 翌日
          changeGaugeDate(1);
        }
      }
    }, { passive: true });
  };

  // 旧UIと新UIの両方にスワイプハンドラーを設定
  setupSwipeHandlers(oldContainer);
  setupSwipeHandlers(newContainer);

  // ナビゲーションボタン（旧UI）
  const prevBtn = document.getElementById('gauge-prev-btn');
  const nextBtn = document.getElementById('gauge-next-btn');

  if (prevBtn) {
    prevBtn.addEventListener('click', () => changeGaugeDate(-1));
  }
  if (nextBtn) {
    nextBtn.addEventListener('click', () => changeGaugeDate(1));
  }

  // ナビゲーションボタン（新UI）
  const newPrevBtn = document.getElementById('new-gauge-prev-btn');
  const newNextBtn = document.getElementById('new-gauge-next-btn');

  if (newPrevBtn) {
    newPrevBtn.addEventListener('click', () => changeGaugeDate(-1));
  }
  if (newNextBtn) {
    newNextBtn.addEventListener('click', () => changeGaugeDate(1));
  }
}

// 時間帯のタスク一覧を表示
function showTimeSlotTasks(startMinutes, endMinutes) {
  const startHour = Math.floor(startMinutes / 60);
  const startMin = startMinutes % 60;
  const endHour = Math.floor(endMinutes / 60);
  const endMin = endMinutes % 60;

  const timeRange = `${String(startHour).padStart(2, '0')}:${String(startMin).padStart(2, '0')} ~ ${String(endHour).padStart(2, '0')}:${String(endMin).padStart(2, '0')}`;

  // 該当時間帯のタスクを取得
  const tasks = getTasks();
  const matchingTasks = tasks.filter(task => {
    if (task.isCompleted || !task.startTime || !task.endTime) return false;

    const [taskStartHour, taskStartMin] = task.startTime.split(':').map(Number);
    const [taskEndHour, taskEndMin] = task.endTime.split(':').map(Number);
    const taskStartMinutes = taskStartHour * 60 + taskStartMin;
    const taskEndMinutes = taskEndHour * 60 + taskEndMin;

    // 時間帯が重なっているかチェック
    return (taskStartMinutes < endMinutes && taskEndMinutes > startMinutes);
  });

  if (matchingTasks.length === 0) {
    alert(`${timeRange}\nこの時間帯にタスクはありません`);
    return;
  }

  // モーダルを表示
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.style.display = 'flex';

  const modalContent = document.createElement('div');
  modalContent.className = 'modal-content time-slot-modal';

  const header = document.createElement('div');
  header.className = 'modal-header';
  header.innerHTML = `
    <h2>${timeRange} のタスク</h2>
    <button class="close-btn">&times;</button>
  `;

  const body = document.createElement('div');
  body.className = 'modal-body';

  matchingTasks.forEach(task => {
    const taskDiv = document.createElement('div');
    taskDiv.className = 'time-slot-task-item';
    taskDiv.innerHTML = `
      <div class="task-title">${task.title}</div>
      <div class="task-time">🕒 ${task.startTime} ~ ${task.endTime}</div>
      ${task.memo ? `<div class="task-memo">${task.memo}</div>` : ''}
    `;
    taskDiv.addEventListener('click', () => {
      modal.remove();
      openEditModal(task.id);
    });
    body.appendChild(taskDiv);
  });

  const footer = document.createElement('div');
  footer.className = 'modal-footer';
  footer.innerHTML = `<button class="btn btn-secondary">閉じる</button>`;

  modalContent.appendChild(header);
  modalContent.appendChild(body);
  modalContent.appendChild(footer);
  modal.appendChild(modalContent);
  document.body.appendChild(modal);

  // 閉じるイベント
  const closeBtn = header.querySelector('.close-btn');
  const closeFooterBtn = footer.querySelector('.btn');

  closeBtn.addEventListener('click', () => modal.remove());
  closeFooterBtn.addEventListener('click', () => modal.remove());
  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

// 24時間ゲージ更新
// dateArg: Date オブジェクトか ISO 日付文字列（YYYY-MM-DD）を受け取る。未指定なら現在日時を使用。
function updateTimeGauge(dateArg) {
  let now = new Date();
  let targetDate = new Date(now);
  if (dateArg) {
    if (typeof dateArg === 'string') {
      // ISO 日付文字列（YYYY-MM-DD）ならその日の0時を使う
      const parts = dateArg.split('-');
      if (parts.length === 3) {
        targetDate = new Date(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]));
      }
    } else if (dateArg instanceof Date) {
      targetDate = new Date(dateArg);
      targetDate.setHours(0,0,0,0);
    }
    // ゲージの基準時刻は targetDate の午前0時からの相対として表示するため、now は targetDate の現在時刻相当を使用する
    // もし targetDate が今日でない場合は、現在時刻を targetDate の午前0時に置き換え（表示上は0%）
    const today = new Date();
    today.setHours(0,0,0,0);
    if (formatDateISO(targetDate) !== formatDateISO(today)) {
      // 表示時刻を targetDate の 0:00 に設定（経過は0）
      now = new Date(targetDate);
      now.setHours(0,0,0,0);
    }
  }
  const hours = now.getHours();
  const minutes = now.getMinutes();
  const timeText = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;

  // 現在時刻表示（旧UI）
  const currentTimeEl = document.getElementById('current-time');
  if (currentTimeEl) {
    currentTimeEl.textContent = timeText;
  }

  // 現在時刻表示（新UI）
  const newCurrentTimeEl = document.getElementById('new-current-time-display');
  if (newCurrentTimeEl) {
    newCurrentTimeEl.textContent = timeText;
  }

  // 経過時間のパーセンテージ（0:00からの経過）
  const minutesFromMidnight = hours * 60 + minutes;
  const percentElapsed = (minutesFromMidnight / (24 * 60)) * 100;

  // 経過ゲージ更新（旧UIのみ）
  const elapsedBar = document.getElementById('time-gauge-elapsed');
  if (elapsedBar) {
    elapsedBar.style.width = `${percentElapsed}%`;
  }

  // 現在時刻マーカー位置更新（旧UIのみ）
  const marker = document.getElementById('time-marker');
  if (marker) {
    marker.style.left = `${percentElapsed}%`;
  }

  // 指定日の日付で予定を集計するよう updateScheduledTasks を呼び出す
```

### gauge-02-render.js

```javascript
  updateScheduledTasks(dateArg);
}

// 今日の予定タスク時間を表示
// dateArg: Date オブジェクトか ISO 日付文字列（YYYY-MM-DD）。未指定なら今日を対象。
function updateScheduledTasks(dateArg) {
  // baseDate を対象日の 0:00 に設定
  let baseDate = new Date();
  baseDate.setHours(0, 0, 0, 0);
  if (dateArg) {
    if (typeof dateArg === 'string') {
      const parts = dateArg.split('-');
      if (parts.length === 3) baseDate = new Date(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]));
    } else if (dateArg instanceof Date) {
      baseDate = new Date(dateArg);
      baseDate.setHours(0,0,0,0);
    }
  }

  // 対象日のルーティンタスクを自動生成
  if (typeof createDailyRoutineTasks === 'function') {
    createDailyRoutineTasks(baseDate);
  }

  const tasks = getTasks();

  const tomorrow = new Date(baseDate);
  tomorrow.setDate(tomorrow.getDate() + 1);

  const yesterday = new Date(baseDate);
  yesterday.setDate(yesterday.getDate() - 1);

  // 変更点の説明（日本語コメント）:
  // - 期限なしタスクはゲージに含めない（今日が期限のタスクのみ対象）
  // - 完了済みタスクはゲージに含めない
  // - デイリールーティンタスクも含める（期限が今日の日付に設定されている）
  // そのため、ここでは "dueDate が存在し、かつ baseDate の範囲内" のタスクのみを抽出する
  const todayTasks = tasks.filter(task => {
    // 完了済みは除外
    if (task.isCompleted) return false;

    // 期限がある場合のみ、今日の範囲内かチェック
    if (task.dueDate) {
      const dueDate = new Date(task.dueDate);
      return dueDate >= baseDate && dueDate < tomorrow;
    }

    // 期限なしのタスクは除外
    return false;
  });

  // 前日が期限で、日をまたぐタスクを抽出（翌日分として当日に加算）
  const yesterdayTasks = tasks.filter(task => {
    if (task.isCompleted) return false;
    if (task.dueDate) {
      const dueDate = new Date(task.dueDate);
      return dueDate >= yesterday && dueDate < baseDate;
    }
    return false;
  });

  // 現在時刻（分単位）- 表示中の日付が今日の場合のみ現在時刻を使用
  const now = new Date();
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const isToday = formatDateISO(baseDate) === formatDateISO(today);

  // 今日の場合は現在時刻、それ以外の日は0:00を基準にする
  const currentMinutes = isToday ? (now.getHours() * 60 + now.getMinutes()) : 0;

  // 【重要】これから先のタスク時間を計算（重複を考慮）
  // タイムスロットを収集
  const timeSlots = [];

  todayTasks.forEach(task => {
    if (task.startTime && task.endTime) {
      const [startHour, startMin] = task.startTime.split(':').map(Number);
      const [endHour, endMin] = task.endTime.split(':').map(Number);
      let startMinutes = startHour * 60 + startMin;
      let endMinutes = endHour * 60 + endMin;

      // 日をまたぐ場合の処理
      if (endMinutes < startMinutes) {
        // タスクが日をまたぐ場合、当日分（開始時刻から24:00まで）のみ
        startMinutes = Math.max(startMinutes, currentMinutes);
        endMinutes = 24 * 60;
      } else {
        // 日をまたがない通常のタスク
        // 現在時刻より前に終了するタスクはスキップ
        if (endMinutes <= currentMinutes) return;

        // 現在進行中のタスクは現在時刻から開始
        if (startMinutes < currentMinutes) {
          startMinutes = currentMinutes;
        }
      }

      timeSlots.push({ start: startMinutes, end: endMinutes });

    } else if (task.duration) {
      // duration のみの場合は現在時刻から duration 分後まで（仮配置）
      timeSlots.push({
        start: currentMinutes,
        end: Math.min(currentMinutes + task.duration, 24 * 60)
      });
    }
  });

  // 前日から継続するタスク（今日の0:00以降の部分のみ）
  yesterdayTasks.forEach(task => {
    if (task.startTime && task.endTime) {
      const [startHour, startMin] = task.startTime.split(':').map(Number);
      const [endHour, endMin] = task.endTime.split(':').map(Number);
      const startMinutes = startHour * 60 + startMin;
      const endMinutes = endHour * 60 + endMin;

      if (endMinutes < startMinutes) {
        // 日をまたぐタスクの今日分
        if (endMinutes > currentMinutes) {
          timeSlots.push({
            start: Math.max(0, currentMinutes),
            end: endMinutes
          });
        }
      }
    }
  });

  // タイムスロットを統合（重複を排除）
  if (timeSlots.length === 0) {
    var totalDurationMinutes = 0;
  } else {
    // 開始時刻でソート
    timeSlots.sort((a, b) => a.start - b.start);

    const mergedSlots = [timeSlots[0]];
    for (let i = 1; i < timeSlots.length; i++) {
      const current = timeSlots[i];
      const last = mergedSlots[mergedSlots.length - 1];

      if (current.start <= last.end) {
        // 重複している: 統合
        last.end = Math.max(last.end, current.end);
      } else {
        // 重複していない: 新しいスロットとして追加
        mergedSlots.push(current);
      }
    }

    // 統合されたスロットの合計時間を計算
    var totalDurationMinutes = mergedSlots.reduce((sum, slot) => {
      return sum + (slot.end - slot.start);
    }, 0);
  }

  // 予定ゲージ更新（時間帯ごとに個別のブロックを作成）
  const scheduledBar = document.getElementById('time-gauge-scheduled');
  scheduledBar.innerHTML = ''; // 既存のブロックをクリア
  scheduledBar.style.display = 'block';
  scheduledBar.style.left = '0';
  scheduledBar.style.width = '100%';

  // 各タスクを時間帯ごとにブロックとして表示
  const taskBlocks = [];

  todayTasks.forEach(task => {
    if (task.startTime && task.endTime) {
      const [startHour, startMin] = task.startTime.split(':').map(Number);
      const [endHour, endMin] = task.endTime.split(':').map(Number);
      const startMinutes = startHour * 60 + startMin;
      const endMinutes = endHour * 60 + endMin;

      if (endMinutes < startMinutes) {
        // 日をまたぐ場合: 当日分のみ表示
        taskBlocks.push({
          startMinutes: startMinutes,
          endMinutes: 24 * 60,
          task: task
        });
      } else {
        taskBlocks.push({
          startMinutes: startMinutes,
          endMinutes: endMinutes,
          task: task
        });
      }
    }
  });

  // 前日から継続するタスク
  yesterdayTasks.forEach(task => {
    if (task.startTime && task.endTime) {
      const [startHour, startMin] = task.startTime.split(':').map(Number);
      const [endHour, endMin] = task.endTime.split(':').map(Number);
      const startMinutes = startHour * 60 + startMin;
      const endMinutes = endHour * 60 + endMin;

      if (endMinutes < startMinutes) {
        taskBlocks.push({
          startMinutes: 0,
          endMinutes: endMinutes,
          task: task
        });
      }
    }
  });

  // ブロックを開始時刻順にソート
  taskBlocks.sort((a, b) => a.startMinutes - b.startMinutes);

  // 各ブロックを表示
  taskBlocks.forEach(block => {
    const blockEl = document.createElement('div');
    blockEl.className = 'task-time-block';
    const leftPercent = (block.startMinutes / (24 * 60)) * 100;
    const widthPercent = ((block.endMinutes - block.startMinutes) / (24 * 60)) * 100;
    blockEl.style.left = `${leftPercent}%`;
    blockEl.style.width = `${widthPercent}%`;
    blockEl.dataset.taskId = block.task.id;
    blockEl.dataset.startTime = block.task.startTime;
```

### gauge-03-new-gauge.js

```javascript
    blockEl.dataset.endTime = block.task.endTime;

    // 時刻ラベルを追加
    const startHour = Math.floor(block.startMinutes / 60);
    const startMin = block.startMinutes % 60;
    const endHour = Math.floor(block.endMinutes / 60);
    const endMin = block.endMinutes % 60;
    const timeLabel = `${String(startHour).padStart(2, '0')}:${String(startMin).padStart(2, '0')}-${String(endHour).padStart(2, '0')}:${String(endMin).padStart(2, '0')}`;
    blockEl.dataset.timeLabel = timeLabel;

    // クリックイベント
    blockEl.addEventListener('click', (e) => {
      e.stopPropagation();
      showTimeSlotTasks(block.startMinutes, block.endMinutes);
    });

    scheduledBar.appendChild(blockEl);
  });

  // 【修正】空き時間と密度の計算
  const totalMinutesInDay = 24 * 60;
  // 今日の場合は残り時間、それ以外の日は24時間全体を基準にする
  const remainingTimeInDay = isToday ? (totalMinutesInDay - currentMinutes) : totalMinutesInDay;
  const freeTimeMinutes = remainingTimeInDay - totalDurationMinutes; // 空き時間

  // 自由時間ゲージ更新
  const freeBar = document.getElementById('time-gauge-free');
  if (freeTimeMinutes > 0) {
    const freeStartPercent = (currentMinutes / (24 * 60)) * 100 + (totalDurationMinutes / (24 * 60)) * 100;
    const freeWidthPercent = (freeTimeMinutes / (24 * 60)) * 100;
    freeBar.style.display = 'block';
    freeBar.style.left = `${freeStartPercent}%`;
    freeBar.style.width = `${Math.min(freeWidthPercent, 100 - freeStartPercent)}%`;
  } else {
    freeBar.style.display = 'none';
  }

  // タスク密度を計算して表示
  const remainingElement = document.getElementById('remaining-tasks');
  const newRemainingElement = document.getElementById('new-remaining-tasks');

  // 【修正】分かりやすい表示（絵文字なし・モノクロ）
  let displayText = '';
  if (freeTimeMinutes < 0) {
    // タスクが多すぎる場合
    const overMinutes = Math.abs(freeTimeMinutes);
    const overHours = Math.floor(overMinutes / 60);
    const overMins = overMinutes % 60;
    if (overHours > 0) {
      displayText = `時間オーバー: ${overHours}時間${overMins > 0 ? overMins + '分' : ''}`;
    } else {
      displayText = `時間オーバー: ${overMins}分`;
    }

    // 時間オーバー警告を表示（今日の日付の場合のみ）
    if (isToday && typeof openTimeOverloadModal === 'function') {
      // 警告モーダルを表示（1回だけ）
      if (!window.overloadModalShown) {
        window.overloadModalShown = true;
        setTimeout(() => {
          openTimeOverloadModal(freeTimeMinutes, todayTasks);
        }, 500);
      }
    }
  } else {
    // 空き時間を表示
    const hours = Math.floor(freeTimeMinutes / 60);
    const minutes = freeTimeMinutes % 60;

    if (hours > 0) {
      displayText = `空き: ${hours}時間${minutes > 0 ? minutes + '分' : ''}`;
    } else if (minutes > 0) {
      displayText = `空き: ${minutes}分`;
    } else {
      displayText = `空きなし`;
    }
  }

  // 旧UIと新UI両方を更新
  if (remainingElement) remainingElement.textContent = displayText;
  if (newRemainingElement) newRemainingElement.textContent = displayText;

  // 空き時間を記録（今日の日付の場合のみ）
  if (isToday && typeof recordDailyFreeTime === 'function') {
    recordDailyFreeTime(freeTimeMinutes);
  }

  // 新ゲージをレンダリング（新UI有効時）
  if (typeof isNewUIEnabled === 'function' && isNewUIEnabled()) {
    if (typeof renderNewGauge === 'function') {
      renderNewGauge(dateArg);
    }
  }
}

// ========================================
// 新しい24ステップゲージレンダリング
// ========================================

/**
 * 新UI用：24ステップゲージをレンダリング
 * @param {string|Date} dateArg - 対象日付（未指定なら今日）
 */
function renderNewGauge(dateArg) {
  const gaugeContainer = document.querySelector('.new-gauge-bar');
  if (!gaugeContainer) return;

  // 対象日の日付を設定
  let baseDate = new Date();
  baseDate.setHours(0, 0, 0, 0);
  if (dateArg) {
    if (typeof dateArg === 'string') {
      const parts = dateArg.split('-');
      if (parts.length === 3) {
        baseDate = new Date(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]));
      }
    } else if (dateArg instanceof Date) {
      baseDate = new Date(dateArg);
      baseDate.setHours(0, 0, 0, 0);
    }
  }

  // 24個のステップを生成
  const stepsHTML = Array.from({ length: 24 }, (_, hour) => {
    const tasks = getTasks();

    // その時間帯にタスクがあるかチェック
    const isActive = tasks.some(task => {
      if (task.isCompleted || !task.startTime || !task.endTime) return false;

      // 対象日付のタスクのみ対象
      if (task.dueDate) {
        const taskDate = new Date(task.dueDate);
        taskDate.setHours(0, 0, 0, 0);
        if (formatDateISO(taskDate) !== formatDateISO(baseDate)) return false;
      } else {
        return false;
      }

      const [startHour, startMin] = task.startTime.split(':').map(Number);
      const [endHour, endMin] = task.endTime.split(':').map(Number);
      const startMinutes = startHour * 60 + startMin;
      const endMinutes = endHour * 60 + endMin;

      // 日をまたぐ場合の処理
      if (endMinutes < startMinutes) {
        // 日をまたぐタスク
        return hour >= startHour || hour < endHour;
      } else {
        // 通常のタスク
        return hour >= startHour && hour < endHour;
      }
    });

    // 現在時刻をハイライト
    const now = new Date();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const isCurrent = formatDateISO(baseDate) === formatDateISO(today) && hour === now.getHours();

    const classes = ['new-gauge-step'];
    if (isActive) classes.push('active');
    if (isCurrent) classes.push('current-marker');

    return `<div class="${classes.join(' ')}" data-hour="${hour}"></div>`;
  }).join('');

  gaugeContainer.innerHTML = stepsHTML;

  // 時間ラベルを更新
  renderGaugeTimeLabels();

  // 現在時刻を更新
  updateNewGaugeTime(baseDate);
}

/**
 * 新UI用：時間ラベルをレンダリング
 */
function renderGaugeTimeLabels() {
  const labelsContainer = document.querySelector('.new-time-labels');
  if (!labelsContainer) return;

  const pattern = getGaugeTimePattern();
  const labels = GAUGE_TIME_PATTERNS[pattern] || GAUGE_TIME_PATTERNS[4];

  const labelsHTML = labels.map(label =>
    `<span class="new-time-label">${label}</span>`
  ).join('');

  labelsContainer.innerHTML = labelsHTML;
}

/**
 * 新UI用：ゲージの時刻表示を更新
 */
function updateNewGaugeTime(dateArg) {
  const timeEl = document.getElementById('new-current-time-display');
  if (!timeEl) return;

  let now = new Date();

  // 対象日が今日でない場合は0:00を表示
  const baseDate = dateArg ? new Date(dateArg) : new Date();
  baseDate.setHours(0, 0, 0, 0);
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  if (formatDateISO(baseDate) !== formatDateISO(today)) {
    now = new Date(baseDate);
  }

  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  timeEl.textContent = `${hours}:${minutes}`;
}
```

### help.js

```javascript
// ========================================
// フェーズ 6.9: ヘルプとオンボーディング
// ========================================

/**
 * チュートリアルステップ定義
 */
const TUTORIAL_STEPS = [
  {
    target: '#quick-add-input',
    title: 'クイック入力でタスク追加',
    description: 'ここにタスク名を入力してEnterキーで素早くタスクを追加できます。「明日 14時 買い物」のように日時も入力できます',
    position: 'top',
    highlight: true
  },
  {
    target: '#time-gauge-container',
    title: '24時間タイムゲージ',
    description: '今日の時間配分が一目でわかります。青が予定時間、灰色が空き時間です',
    position: 'bottom',
    highlight: true
  },
  {
    target: '#search-input',
    title: 'タスクを検索',
    description: 'タスク名またはメモから素早くタスクを検索できます',
    position: 'bottom',
    highlight: false
  },
  {
    target: '#select-mode-icon-btn',
    title: '複数選択モード',
    description: '複数のタスクを選択して一括で操作できます',
    position: 'bottom',
    highlight: false
  },
  {
    target: '#create-task-btn',
    title: '新規タスク作成',
    description: 'より詳細な設定でタスクを作成できます（日時、メモ、優先度など）',
    position: 'top',
    highlight: false
  }
];

/**
 * ショートカット定義
 */
const SHORTCUTS = [
  {
    gesture: '右スワイプ →',
    action: 'タスク完了/未完了',
    icon: '✓'
  },
  {
    gesture: '← 左スワイプ',
    action: 'タスク削除',
    icon: '×'
  },
  {
    gesture: 'Enter キー',
    action: 'クイック入力フォーム送信',
    icon: '⏎'
  },
  {
    gesture: 'Escape キー',
    action: 'モーダルを閉じる',
    icon: 'Esc'
  },
  {
    gesture: 'Tab キー',
    action: 'フォーカスの移動',
    icon: '→'
  }
];

/**
 * FAQ データ
 */
const FAQ_ITEMS = [
  {
    question: '自然言語で日時を入力できますか？',
    answer: 'はい、できます。「明日 14時 買い物」「来週月曜 会議」など、自然な言語で日時を指定できます。'
  },
  {
    question: 'タスクを一括で操作できますか？',
    answer: 'はい。選択モード（アイコン）から複数タスクを選択して、一括で完了・削除・日付変更ができます。'
  },
  {
    question: 'オフラインでも使用できますか？',
    answer: 'はい、オフラインモードでもタスクの作成・編集が可能です。インターネット接続時に自動的に同期されます。'
  },
  {
    question: 'タスクを削除したら復元できますか？',
    answer: 'はい。削除時に「アンドゥ」ボタンが表示され、5秒以内なら復元できます。'
  },
  {
    question: '絵文字をタスクに追加できますか？',
    answer: 'はい。入力フィールドの絵文字アイコン（📝）から選択して追加できます。'
  },
  {
    question: '期限切れタスクはどうなりますか？',
    answer: '期限が過ぎたタスクは赤く表示されます。クイックアクションで明日に一括移動できます。'
  }
];

/**
 * チュートリアルを開始
 */
function startTutorial() {
  if (localStorage.getItem('tutorialCompleted') === 'true' &&
      !localStorage.getItem('showTutorialAgain')) {
    return; // チュートリアル既完了
  }

  let currentStep = 0;

  function showStep(stepIndex) {
    currentStep = stepIndex;

    // 前のハイライトを削除
    document.querySelectorAll('.tutorial-highlight').forEach(el => {
      el.classList.remove('tutorial-highlight');
    });

    const step = TUTORIAL_STEPS[stepIndex];
    const target = document.querySelector(step.target);

    if (!target) {
      // ターゲット要素が見つからない場合は次へ
      if (stepIndex < TUTORIAL_STEPS.length - 1) {
        setTimeout(() => showStep(stepIndex + 1), 300);
      } else {
        completeTutorial();
      }
      return;
    }

    // ハイライト
    if (step.highlight) {
      target.classList.add('tutorial-highlight');
    }

    // ツールチップ表示
    showTutorialTooltip(target, step, stepIndex);
  }

  showStep(0);

  function completeTutorial() {
    localStorage.setItem('tutorialCompleted', 'true');
    localStorage.removeItem('showTutorialAgain');
    hideTutorialOverlay();
    console.log('✅ チュートリアル完了');
  }

  // ウィンドウレベルで次へ/前へ関数を定義
  window.tutorialNext = () => {
    if (currentStep < TUTORIAL_STEPS.length - 1) {
      showStep(currentStep + 1);
    } else {
      completeTutorial();
    }
  };

  window.tutorialPrev = () => {
    if (currentStep > 0) {
      showStep(currentStep - 1);
    }
  };

  window.tutorialSkip = completeTutorial;
}

/**
 * チュートリアル用ツールチップを表示
 */
function showTutorialTooltip(target, step, stepIndex) {
  // 既存のツールチップを削除
  document.querySelectorAll('.tutorial-tooltip').forEach(el => el.remove());

  const tooltip = document.createElement('div');
  tooltip.className = 'tutorial-tooltip';
  tooltip.setAttribute('role', 'dialog');
  tooltip.setAttribute('aria-label', `チュートリアル: ${step.title}`);

  const totalSteps = TUTORIAL_STEPS.length;

  tooltip.innerHTML = `
    <div class="tutorial-tooltip-header">
      <h3 class="tutorial-tooltip-title">${step.title}</h3>
      <span class="tutorial-step-counter">${stepIndex + 1}/${totalSteps}</span>
    </div>
    <p class="tutorial-tooltip-description">${step.description}</p>
    <div class="tutorial-tooltip-buttons">
      <button class="btn btn-secondary" onclick="tutorialPrev()"
              ${stepIndex === 0 ? 'disabled' : ''}>前へ</button>
      <button class="btn btn-secondary" onclick="tutorialSkip()">スキップ</button>
      <button class="btn btn-primary" onclick="tutorialNext()">
        ${stepIndex === totalSteps - 1 ? '完了' : '次へ'}
      </button>
    </div>
  `;

  document.body.appendChild(tooltip);

  // ツールチップを target の近くに配置
  positionTooltip(tooltip, target, step.position);
}

/**
 * ツールチップを配置
 */
function positionTooltip(tooltip, target, position) {
  const rect = target.getBoundingClientRect();
  const tooltipHeight = 200;
  const tooltipWidth = 280;
  const gap = 16;

  let top, left;

  if (position === 'top') {
    top = rect.top - tooltipHeight - gap;
    left = rect.left + rect.width / 2 - tooltipWidth / 2;
  } else {
    top = rect.bottom + gap;
    left = rect.left + rect.width / 2 - tooltipWidth / 2;
  }

  // ビューポート内に収まるように調整
  if (left < 0) left = 16;
  if (left + tooltipWidth > window.innerWidth) left = window.innerWidth - tooltipWidth - 16;

  tooltip.style.top = `${Math.max(16, top)}px`;
  tooltip.style.left = `${left}px`;
}

/**
 * チュートリアルオーバーレイを表示
 */
function showTutorialOverlay() {
  if (!document.getElementById('tutorial-overlay')) {
    const overlay = document.createElement('div');
    overlay.id = 'tutorial-overlay';
    overlay.className = 'tutorial-overlay';
    document.body.appendChild(overlay);
  }
}

/**
 * チュートリアルオーバーレイを非表示
 */
function hideTutorialOverlay() {
  const overlay = document.getElementById('tutorial-overlay');
  if (overlay) {
    overlay.remove();
  }
  document.querySelectorAll('.tutorial-highlight').forEach(el => {
    el.classList.remove('tutorial-highlight');
  });
  document.querySelectorAll('.tutorial-tooltip').forEach(el => {
    el.remove();
  });
}

/**
 * ショートカットガイドを表示
 */
function showShortcutsGuide() {
  const dialog = document.createElement('div');
  dialog.className = 'shortcuts-modal';
  dialog.setAttribute('role', 'dialog');
  dialog.setAttribute('aria-labelledby', 'shortcuts-title');

  let shortcutsHtml = '<h2 id="shortcuts-title" class="shortcuts-title">ジェスチャーショートカット</h2>';
  shortcutsHtml += '<div class="shortcuts-grid">';

  SHORTCUTS.forEach(shortcut => {
    shortcutsHtml += `
      <div class="shortcut-card">
        <div class="shortcut-icon">${shortcut.icon}</div>
        <div class="shortcut-gesture">${shortcut.gesture}</div>
        <div class="shortcut-action">${shortcut.action}</div>
      </div>
    `;
  });

  shortcutsHtml += '</div>';
  shortcutsHtml += `
    <div class="shortcuts-modal-footer">
      <button class="btn btn-primary" onclick="document.querySelector('.shortcuts-modal')?.remove()">
        閉じる
      </button>
    </div>
  `;

  dialog.innerHTML = shortcutsHtml;
  document.body.appendChild(dialog);
}

/**
 * FAQ を表示
 */
function showFAQ() {
  const faqContainer = document.createElement('div');
  faqContainer.className = 'faq-container';
  faqContainer.setAttribute('role', 'region');
  faqContainer.setAttribute('aria-label', 'よくある質問');

  let faqHtml = '<h2 class="faq-title">よくある質問（FAQ）</h2>';
  faqHtml += '<div class="faq-search">';
  faqHtml += '<input type="text" id="faq-search-input" placeholder="質問を検索..." aria-label="FAQ を検索">';
  faqHtml += '</div>';
  faqHtml += '<div class="faq-items">';

  FAQ_ITEMS.forEach((item, index) => {
    faqHtml += `
      <div class="faq-item">
        <button class="faq-question" onclick="this.nextElementSibling.classList.toggle('show')" aria-expanded="false">
          <span class="faq-q-icon">Q:</span> ${item.question}
        </button>
        <div class="faq-answer">
          <span class="faq-a-icon">A:</span> ${item.answer}
        </div>
      </div>
    `;
  });

  faqHtml += '</div>';

  faqContainer.innerHTML = faqHtml;
  document.body.appendChild(faqContainer);

  // 検索機能
  const searchInput = faqContainer.querySelector('#faq-search-input');
  searchInput.addEventListener('input', (e) => {
    const query = e.target.value.toLowerCase();
    document.querySelectorAll('.faq-item').forEach(item => {
      const question = item.querySelector('.faq-question').textContent.toLowerCase();
      const answer = item.querySelector('.faq-answer').textContent.toLowerCase();
      item.style.display = question.includes(query) || answer.includes(query) ? '' : 'none';
    });
  });
}

/**
 * ツールチップを追加
 */
function addTooltips() {
  const tooltipConfigs = [
    {
      selector: '#bulk-select-all-btn',
      text: '複数のタスクをすべて選択/解除できます'
    },
    {
      selector: '#search-input',
      text: 'タスク名またはメモから検索できます'
    },
    {
      selector: '#quick-date-btn',
      text: '日付と時間を詳しく設定できます'
    },
    {
      selector: '#settings-icon-btn',
      text: 'ルーティンやクイックアクション、設定を変更できます'
    }
  ];

  tooltipConfigs.forEach(config => {
    const element = document.querySelector(config.selector);
    if (element) {
      element.setAttribute('data-tooltip', config.text);
      element.classList.add('has-tooltip');
    }
  });
}

/**
 * チュートリアルの再表示オプションを設定画面に追加
 */
function addTutorialReplayOption() {
  const settingsModal = document.getElementById('settings-modal');
  if (!settingsModal) return;

  const existingOption = document.querySelector('.tutorial-replay-option');
  if (existingOption) return;

  const section = document.createElement('div');
  section.className = 'tutorial-replay-option';
  section.innerHTML = `
    <h3 class="settings-section-title">ヘルプとチュートリアル</h3>
    <button type="button" class="btn btn-secondary" onclick="startTutorial(); localStorage.setItem('showTutorialAgain', 'true');">
      チュートリアルを再表示
    </button>
    <button type="button" class="btn btn-secondary" onclick="showShortcutsGuide();">
      ショートカットガイド
    </button>
    <button type="button" class="btn btn-secondary" onclick="showFAQ();">
      よくある質問（FAQ）
    </button>
  `;

  const settingsBody = settingsModal.querySelector('.modal-body');
  if (settingsBody) {
    settingsBody.appendChild(section);
  }
}

/**
 * 初期化関数
 */
let helpInitialized = false;

function initHelp() {
  // 重複初期化を防止
  if (helpInitialized) return;
  helpInitialized = true;

  console.log('Initializing help and onboarding features...');

  // 初回起動時にチュートリアル表示（本当に初回のみ）
  // ユーザーからのフィードバックにより、自動表示は無効化
  // if (!localStorage.getItem('tutorialCompleted') && !localStorage.getItem('_help_initialized')) {
  //   setTimeout(() => {
  //     startTutorial();
  //   }, 1000);
  //   localStorage.setItem('_help_initialized', 'true');
  // }

  // ツールチップを追加
  addTooltips();

  // 設定画面にオプションを追加
  addTutorialReplayOption();

  // グローバル関数として公開
  window.showShortcutsGuide = showShortcutsGuide;
  window.showFAQ = showFAQ;

  console.log('✅ Help and onboarding features initialized');
}

// ページロード時に初期化（1回のみ）
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initHelp);
} else {
  initHelp();
}
```

### i18n.js

```javascript
// Simple i18n dictionary and applier for Android WebView assets
(function() {
  const I18N = {
    ja: {
      texts: {
        '#settings-modal .modal-header h2': '設定',
        '#save-settings-btn': '保存',
        '#completed-section .toggle-text': '完了済み',
        '#login-modal #login-modal-title': 'ログイン',
        '#google-login-btn': 'Googleでログイン',
        '#continue-anonymous-btn': '匿名のまま使い続ける',
        '#logout-btn': 'ログアウト'
      },
      applyExtras() {
        // 設定モーダル セクション見出し（登場順）
        const sectionTitles = document.querySelectorAll('#settings-modal .settings-section-title');
        if (sectionTitles && sectionTitles.length) {
          if (sectionTitles[0]) sectionTitles[0].textContent = '🎨 表示設定';
          if (sectionTitles[1]) sectionTitles[1].textContent = '🔔 通知設定';
          if (sectionTitles[2]) sectionTitles[2].textContent = '⏱ ルーチン';
          if (sectionTitles[3]) sectionTitles[3].textContent = '⚡ クイックアクション';
        }

        // ゲージのナビ（前/次）
        const prevBtn = document.getElementById('gauge-prev-btn');
        if (prevBtn) {
          prevBtn.setAttribute('aria-label', '前の日に移動');
          prevBtn.setAttribute('title', '前の日に移動');
        }
        const nextBtn = document.getElementById('gauge-next-btn');
        if (nextBtn) {
          nextBtn.setAttribute('aria-label', '次の日に移動');
          nextBtn.setAttribute('title', '次の日に移動');
        }
      }
    }
  };

  function setText(selector, text) {
    const el = document.querySelector(selector);
    if (!el) return;
    // Prefer textContent to avoid injecting HTML
    el.textContent = text;
  }

  window.applyI18n = function(locale = 'ja') {
    const dict = I18N[locale] || I18N.ja;
    Object.entries(dict.texts).forEach(([sel, val]) => setText(sel, val));
    if (typeof dict.applyExtras === 'function') dict.applyExtras();
  };
})();

```

### input-experience.js

```javascript
// ========================================
// フェーズ 6.5: 入力体験の改善
// ========================================

/**
 * 自然言語で日時を解析
 * 例: "明日 14時", "来週月曜", "3日後 15:30", "今週末"
 */
function parseNaturalDatetime(input) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  let parsedDate = null;
  let parsedTime = null;

  // テキストを正規化
  const normalized = input.toLowerCase().trim();

  // ===== 日付パターン解析 =====

  // "今日" パターン
  if (normalized.includes('今日')) {
    parsedDate = new Date(today);
  }
  // "明日" パターン
  else if (normalized.includes('明日')) {
    parsedDate = new Date(today);
    parsedDate.setDate(parsedDate.getDate() + 1);
  }
  // "昨日" パターン
  else if (normalized.includes('昨日')) {
    parsedDate = new Date(today);
    parsedDate.setDate(parsedDate.getDate() - 1);
  }
  // "来週" パターン (月曜から)
  else if (normalized.includes('来週')) {
    parsedDate = new Date(today);
    // 来週の月曜を計算
    const dayOfWeek = parsedDate.getDay();
    const daysUntilMonday = (8 - dayOfWeek) % 7 || 1;
    parsedDate.setDate(parsedDate.getDate() + daysUntilMonday + 6);
  }
  // "今週末" または "週末" パターン (土曜)
  else if (normalized.includes('今週末') || (normalized.includes('週末') && !normalized.includes('来週'))) {
    parsedDate = new Date(today);
    const dayOfWeek = parsedDate.getDay();
    const daysUntilSaturday = (6 - dayOfWeek + 7) % 7 || 6;
    parsedDate.setDate(parsedDate.getDate() + daysUntilSaturday);
  }
  // "来週末" パターン
  else if (normalized.includes('来週末')) {
    parsedDate = new Date(today);
    const dayOfWeek = parsedDate.getDay();
    const daysUntilSaturday = (6 - dayOfWeek + 7) % 7 || 6;
    parsedDate.setDate(parsedDate.getDate() + daysUntilSaturday + 7);
  }
  // "N日後" パターン
  else {
    const daysMatch = normalized.match(/(\d+)\s*(?:日|日後|days?)/);
    if (daysMatch) {
      parsedDate = new Date(today);
      parsedDate.setDate(parsedDate.getDate() + parseInt(daysMatch[1]));
    }
  }

  // ===== 曜日パターン解析 =====

  const weekdayMap = {
    '月': 1, '火': 2, '水': 3, '木': 4, '金': 5, '土': 6, '日': 0,
    'mon': 1, 'tue': 2, 'wed': 3, 'thu': 4, 'fri': 5, 'sat': 6, 'sun': 0
  };

  for (const [day, dayNum] of Object.entries(weekdayMap)) {
    if (normalized.includes(day) && !parsedDate) {
      // 曜日指定 （例：「来週月曜」「月曜」）
      parsedDate = new Date(today);

      // "来週" 付き
      if (normalized.includes('来週')) {
        // 来週の指定曜日
        const weekPlus = 7;
        const currentDay = parsedDate.getDay();
        let daysAhead = dayNum - currentDay;
        if (daysAhead <= 0) daysAhead += 7;
        parsedDate.setDate(parsedDate.getDate() + daysAhead + weekPlus);
      } else {
        // 今週の指定曜日（過去になる場合は来週）
        const currentDay = parsedDate.getDay();
        let daysAhead = dayNum - currentDay;
        if (daysAhead <= 0) daysAhead += 7;
        parsedDate.setDate(parsedDate.getDate() + daysAhead);
      }
      break;
    }
  }

  // ===== 時刻パターン解析 =====

  // "HH:MM" または "HH時MM分" パターン
  const timeMatch = normalized.match(/(\d{1,2})\s*[:時]\s*(\d{0,2})/);
  if (timeMatch) {
    const hour = parseInt(timeMatch[1]);
    const minute = parseInt(timeMatch[2]) || 0;

    // 有効な時刻チェック
    if (hour >= 0 && hour < 24 && minute >= 0 && minute < 60) {
      parsedTime = {
        hour: hour,
        minute: minute
      };
    }
  }
  // "N時" パターン（分なし）
  else {
    const hourMatch = normalized.match(/(\d{1,2})\s*時(?!\d)/);
    if (hourMatch) {
      const hour = parseInt(hourMatch[1]);
      if (hour >= 0 && hour < 24) {
        parsedTime = {
          hour: hour,
          minute: 0
        };
      }
    }
  }

  // ===== 期限日の決定 =====

  if (!parsedDate) {
    // パターンマッチしなかった場合は null を返す
    return null;
  }

  parsedDate.setHours(parsedTime?.hour || 12, parsedTime?.minute || 0, 0, 0);

  return {
    dueDate: parsedDate.toISOString(),
    startTime: parsedTime ? `${String(parsedTime.hour).padStart(2, '0')}:${String(parsedTime.minute).padStart(2, '0')}` : null,
    endTime: null,
    duration: null
  };
}

/**
 * 自然言語入力を処理してクイック入力フォームに反映
 */
function processNaturalInput(input) {
  // "明日 14時 買い物" → {date: tomorrow, time: 14:00, title: "買い物"}

  // 日時を抽出
  const datetimeResult = parseNaturalDatetime(input);

  if (datetimeResult && datetimeResult.dueDate) {
    // 日付と時刻を抽出した場合、日付フィールドを更新
    const dateStr = datetimeResult.dueDate.split('T')[0];
    const quickDateInput = document.getElementById('quick-add-date');
    if (quickDateInput) {
      quickDateInput.value = dateStr;

      // 日付ボタンに「has-date」クラスを追加
      const quickDateBtn = document.getElementById('quick-date-btn');
      if (quickDateBtn) {
        quickDateBtn.classList.add('has-date');
      }
    }

    // 開始時刻を設定（モーダルの場合）
    if (datetimeResult.startTime) {
      const taskStartTime = document.getElementById('task-start-time');
      if (taskStartTime) {
        taskStartTime.value = datetimeResult.startTime;
      }
    }

    // 日時部分をタスク名から削除
    let taskTitle = input;
    // 日付部分を削除
    taskTitle = taskTitle.replace(/明日|今日|昨日|来週|今週末|来週末|(\d+)日(?:後)?|(\d+)\s*[:時].*?(?:分)?/g, '').trim();

    return {
      hasDatetime: true,
      taskTitle: taskTitle || input,
      dueDate: datetimeResult.dueDate,
      startTime: datetimeResult.startTime
    };
  }

  return {
    hasDatetime: false,
    taskTitle: input,
    dueDate: null,
    startTime: null
  };
}

/**
 * 定型文テンプレート（オートコンプリート）
 */
const TEMPLATE_SNIPPETS = [
  { text: '買い物', memo: '', duration: 30 },
  { text: '会議準備', memo: '', duration: 60 },
  { text: 'メール確認', memo: '', duration: 15 },
  { text: 'コード レビュー', memo: '', duration: 90 },
  { text: 'ドキュメント作成', memo: '', duration: 120 },
  { text: 'チーム会議', memo: '', duration: 45 },
  { text: 'ランチ', memo: '', duration: 60 },
  { text: '運動', memo: '', duration: 45 },
  { text: '読書', memo: '', duration: 30 },
  { text: '掃除', memo: '', duration: 30 }
];

/**
 * テンプレート補完を提案（マッチするテンプレート）
 */
function getTemplateCompletions(input) {
  if (!input || input.length < 2) {
    return [];
  }

  const normalized = input.toLowerCase();
  return TEMPLATE_SNIPPETS.filter(template =>
    template.text.toLowerCase().includes(normalized) ||
    normalized.includes(template.text.toLowerCase())
  ).slice(0, 5); // 最大5件
}

/**
 * オートコンプリート UI を更新
 */
function updateAutocompleteUI(input) {
  const completions = getTemplateCompletions(input);

  // オートコンプリート表示エリアが なければ作成
  let autocompleteContainer = document.getElementById('input-autocomplete-container');
  if (!autocompleteContainer) {
    autocompleteContainer = document.createElement('div');
    autocompleteContainer.id = 'input-autocomplete-container';
    autocompleteContainer.className = 'input-autocomplete-container';

    const quickInputWrapper = document.querySelector('.quick-input-wrapper');
    if (quickInputWrapper) {
      quickInputWrapper.appendChild(autocompleteContainer);
    }
  }

  if (completions.length === 0) {
    autocompleteContainer.innerHTML = '';
    autocompleteContainer.style.display = 'none';
    return;
  }

  // オートコンプリート項目を表示
  autocompleteContainer.innerHTML = completions.map(completion => `
    <div class="autocomplete-item" onclick="applyTemplate(this)">
      <strong>${escapeHtml(completion.text)}</strong>
      ${completion.duration ? `<span class="duration">${completion.duration}分</span>` : ''}
    </div>
  `).join('');

  autocompleteContainer.style.display = 'block';
}

/**
 * テンプレートを適用
 */
function applyTemplate(element) {
  const templateText = element.querySelector('strong').textContent;
  const quickInput = document.getElementById('quick-add-input');
  if (quickInput) {
    quickInput.value = templateText;
    quickInput.focus();
  }

  const autocompleteContainer = document.getElementById('input-autocomplete-container');
  if (autocompleteContainer) {
    autocompleteContainer.innerHTML = '';
    autocompleteContainer.style.display = 'none';
  }
}

/**
 * HTML特殊文字をエスケープ
 */
function escapeHtml(text) {
  const map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  };
  return text.replace(/[&<>"']/g, m => map[m]);
}

/**
 * 絵文字ピッカー（シンプル版）
 */
const COMMON_EMOJIS = [
  '🎯', '📝', '✅', '⏰', '📅', '💼', '🚀', '📊', '💡', '🎨',
  '🔧', '🐛', '📖', '🎓', '💬', '🌟', '🎉', '📞', '✉️', '🗂️'
];

/**
 * 絵文字ピッカー UI を表示
 */
function showEmojiPicker() {
  let emojiContainer = document.getElementById('emoji-picker-container');
  if (!emojiContainer) {
    emojiContainer = document.createElement('div');
    emojiContainer.id = 'emoji-picker-container';
    emojiContainer.className = 'emoji-picker-container';
    emojiContainer.innerHTML = `
      <div class="emoji-picker-header">
        <span>よく使う絵文字</span>
        <button type="button" class="emoji-picker-close">&times;</button>
      </div>
      <div class="emoji-picker-grid">
        ${COMMON_EMOJIS.map(emoji => `
          <button type="button" class="emoji-item" onclick="insertEmoji(this)">${emoji}</button>
        `).join('')}
      </div>
    `;

    const quickInputWrapper = document.querySelector('.quick-input-wrapper');
    if (quickInputWrapper) {
      quickInputWrapper.appendChild(emojiContainer);
    }
  }

  const isVisible = emojiContainer.style.display === 'block';
  emojiContainer.style.display = isVisible ? 'none' : 'block';

  // 閉じるボタン
  const closeBtn = emojiContainer.querySelector('.emoji-picker-close');
  if (closeBtn) {
    closeBtn.addEventListener('click', () => {
      emojiContainer.style.display = 'none';
    });
  }
}

/**
 * 絵文字をタスク名に挿入
 */
function insertEmoji(element) {
  const emoji = element.textContent;
  const quickInput = document.getElementById('quick-add-input');
  if (quickInput) {
    const start = quickInput.selectionStart;
    const end = quickInput.selectionEnd;
    const text = quickInput.value;
    quickInput.value = text.substring(0, start) + emoji + text.substring(end);
    quickInput.selectionStart = quickInput.selectionEnd = start + emoji.length;
    quickInput.focus();
  }
}

/**
 * キーボード表示時の画面調整
 */
function setupKeyboardHandling() {
  const quickAddForm = document.getElementById('quick-add-form');
  const quickInput = document.getElementById('quick-add-input');

  if (!quickAddForm || !quickInput) return;

  quickInput.addEventListener('focus', () => {
    // キーボード表示時、クイック入力フォームをスクロール位置に持ってくる
    setTimeout(() => {
      quickAddForm.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }, 300);
  });

  quickInput.addEventListener('blur', () => {
    // オートコンプリートを非表示
    const autocompleteContainer = document.getElementById('input-autocomplete-container');
    if (autocompleteContainer) {
      autocompleteContainer.style.display = 'none';
    }
  });
}

/**
 * 初期化
 */
function initInputExperience() {
  const quickInput = document.getElementById('quick-add-input');
  if (!quickInput) return;

  // 自然言語入力のためのリスナー
  quickInput.addEventListener('input', (e) => {
    const value = e.target.value.trim();

    // 自然言語日時の解析
    if (value.length > 2) {
      const result = processNaturalInput(value);
      // コンソールに結果を出力（デバッグ用）
      // console.log('Natural language parsing:', result);
    }

    // テンプレート補完の提案
    updateAutocompleteUI(value);
  });

  // キーボード処理
  setupKeyboardHandling();

  // Enterキー処理の改善
  quickInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && e.target.value.trim()) {
      // 自然言語入力を処理
      const result = processNaturalInput(e.target.value);

      // フォーム送信（通常のイベントで処理される）
      e.target.form.dispatchEvent(new Event('submit'));
    }
  });

  // 絵文字ピッカーボタン（存在する場合）
  // NOTE: 将来的に絵文字ボタンを追加する場合

  console.log('Input experience enhancement initialized');
}

// ページロード時に初期化
document.addEventListener('DOMContentLoaded', initInputExperience);

// 動的に追加された場合の再初期化
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initInputExperience);
} else {
  initInputExperience();
}
```

### migration.js

```javascript
// データ移行機能（無効化）
(function() {
  // ページ読み込み後に実行
  // DISABLED: Migration button is not needed in production
  /*
  window.addEventListener('load', function() {
    addMigrationButton();
  });
  */

  function addMigrationButton() {
    // 設定セクションにボタンを追加
    const settingsSection = document.querySelector('.settings-section') || document.body;

    const migrationDiv = document.createElement('div');
    migrationDiv.style.cssText = 'position: fixed; bottom: 20px; right: 20px; z-index: 9999;';
    migrationDiv.innerHTML = `
      <button id="migrationBtn" style="
        background: #4CAF50;
        color: white;
        border: none;
        padding: 15px 20px;
        border-radius: 50%;
        font-size: 24px;
        cursor: pointer;
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      ">📦</button>
    `;

    document.body.appendChild(migrationDiv);

    document.getElementById('migrationBtn').addEventListener('click', showMigrationModal);
  }

  function showMigrationModal() {
    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    `;

    modal.innerHTML = `
      <div style="
        background: white;
        padding: 30px;
        border-radius: 10px;
        max-width: 400px;
        width: 90%;
      ">
        <h2 style="margin-top: 0;">データ移行</h2>
        <p>Webアプリからモバイルアプリへデータを移行します</p>

        <button id="exportBtn" style="
          background: #2196F3;
          color: white;
          border: none;
          padding: 15px;
          border-radius: 5px;
          width: 100%;
          margin-bottom: 10px;
          font-size: 16px;
          cursor: pointer;
        ">LocalStorageをエクスポート</button>

        <button id="importBtn" style="
          background: #4CAF50;
          color: white;
          border: none;
          padding: 15px;
          border-radius: 5px;
          width: 100%;
          margin-bottom: 10px;
          font-size: 16px;
          cursor: pointer;
        ">Firestoreにインポート</button>

        <button id="closeBtn" style="
          background: #f44336;
          color: white;
          border: none;
          padding: 10px;
          border-radius: 5px;
          width: 100%;
          font-size: 16px;
          cursor: pointer;
        ">閉じる</button>

        <textarea id="exportData" style="
          width: 100%;
          height: 200px;
          margin-top: 10px;
          font-family: monospace;
          font-size: 12px;
          display: none;
        "></textarea>
      </div>
    `;

    document.body.appendChild(modal);

    document.getElementById('exportBtn').addEventListener('click', function() {
      exportLocalStorage();
    });

    document.getElementById('importBtn').addEventListener('click', function() {
      importToFirestore();
    });

    document.getElementById('closeBtn').addEventListener('click', function() {
      document.body.removeChild(modal);
    });
  }

  function exportLocalStorage() {
    const exportData = {};
    const keys = [
      'nowtask_tasks',
      'nowtask_trash',
      'nowtask_shelved',
      'nowtask_settings',
      'nowtask_routines',
      'nowtask_task_history',
      'nowtask_templates',
      'nowtask_sort_pref'
    ];

    keys.forEach(key => {
      const data = localStorage.getItem(key);
      if (data) {
        exportData[key] = data;
      }
    });

    const jsonString = JSON.stringify(exportData, null, 2);
    const textarea = document.getElementById('exportData');
    textarea.style.display = 'block';
    textarea.value = jsonString;

    // クリップボードにコピー
    textarea.select();
    document.execCommand('copy');

    alert('✅ データをエクスポートしました！\n下に表示されています。\nクリップボードにもコピーされました。');
  }

  function importToFirestore() {
    const textarea = document.getElementById('exportData');
    let jsonData = textarea.value;

    if (!jsonData) {
      // テキストエリアが空の場合は、LocalStorageから直接読み込む
      const exportData = {};
      const keys = [
        'nowtask_tasks',
        'nowtask_trash',
        'nowtask_shelved',
        'nowtask_settings',
        'nowtask_routines',
        'nowtask_task_history',
        'nowtask_templates',
        'nowtask_sort_pref'
      ];

      keys.forEach(key => {
        const data = localStorage.getItem(key);
        if (data) {
          exportData[key] = data;
        }
      });

      jsonData = JSON.stringify(exportData);
    }

    if (typeof FirestoreBridge !== 'undefined') {
      FirestoreBridge.importData(jsonData);
      alert('✅ Firestoreへのインポートを開始しました！');
    } else {
      alert('❌ FirestoreBridgeが見つかりません。\nAndroidアプリで実行してください。');
    }
  }
})();
```

### modals.js

```javascript
// ========================================
// モーダル管理
// ========================================

// 新規作成モーダルを開く
function openCreateModal() {
  editingTaskId = null;

  document.getElementById('modal-title').textContent = '新規タスク';
  document.getElementById('task-title').value = '';
  document.getElementById('task-memo').value = '';

  // 今日の日付をデフォルトに設定
  const today = new Date();
  const localISO = new Date(today.getTime() - today.getTimezoneOffset() * 60000).toISOString().slice(0, 10);
  document.getElementById('task-due-date').value = localISO;

  document.getElementById('task-duration').value = '';
  document.getElementById('task-start-time').value = '';
  document.getElementById('task-end-time').value = '';
  document.getElementById('task-urgent').checked = false;
  document.getElementById('task-priority').value = '';
  document.getElementById('title-char-count').textContent = '0';
  document.getElementById('delete-btn').style.display = 'none';
  document.getElementById('timer-section').style.display = 'none';
  document.getElementById('subtasks-section').style.display = 'none';
  document.getElementById('save-btn').disabled = true;

  // 時間フィールドの自動計算イベントを設定
  setupTimeAutoCalculation();

  document.getElementById('task-modal').classList.add('show');
  document.getElementById('task-title').focus();
}

// 編集モーダルを開く
function openEditModal(id) {
  const task = getTaskById(id);
  if (!task) return;

  editingTaskId = id;

  document.getElementById('modal-title').textContent = 'タスク編集';
  document.getElementById('task-title').value = task.title;
  document.getElementById('task-memo').value = task.memo;
  document.getElementById('title-char-count').textContent = task.title.length;

  if (task.dueDate) {
    // ISO形式をdate形式に変換
    const date = new Date(task.dueDate);
    const localISO = new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().slice(0, 10);
    document.getElementById('task-due-date').value = localISO;
  } else {
    document.getElementById('task-due-date').value = '';
  }
  // 所要時間・開始時刻・終了時刻・緊急・優先順位を反映
  document.getElementById('task-duration').value = task.duration || '';
  document.getElementById('task-start-time').value = task.startTime || '';
  document.getElementById('task-end-time').value = task.endTime || '';
  document.getElementById('task-urgent').checked = task.urgent || false;
  document.getElementById('task-priority').value = task.priority || '';

  document.getElementById('delete-btn').style.display = 'inline-block';
  document.getElementById('timer-section').style.display = 'block';
  document.getElementById('subtasks-section').style.display = 'block';
  document.getElementById('save-btn').disabled = false;

  // サブタスクリスト表示
  editingSubtasks = getSubtasks(id);
  renderSubtasksList();

  // タイマー表示更新
  updateTimerDisplay(id);

  // タイマー更新インターバル設定
  if (timerInterval) {
    clearInterval(timerInterval);
  }
  timerInterval = setInterval(() => {
    if (editingTaskId) {
      updateTimerDisplay(editingTaskId);
    }
  }, 1000);

  // 時間フィールドの自動計算イベントを設定
  setupTimeAutoCalculation();

  document.getElementById('task-modal').classList.add('show');
  document.getElementById('task-title').focus();
}

// モーダルを閉じる
function closeModal() {
  const modal = document.getElementById('task-modal');

  // 閉じるアニメーションを開始
  modal.classList.add('hiding');

  // アニメーション終了後に実際に閉じる
  setTimeout(() => {
    modal.classList.remove('show', 'hiding');
    editingTaskId = null;
    editingSubtasks = [];

    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
  }, 200); // 200ms（アニメーション時間）
}

// サブタスクリスト表示
function renderSubtasksList() {
  const container = document.getElementById('subtasks-list');
  container.innerHTML = '';

  editingSubtasks.forEach((subtask, index) => {
    const item = document.createElement('div');
    item.className = 'subtask-item' + (subtask.isCompleted ? ' completed' : '');

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = subtask.isCompleted;
    checkbox.addEventListener('change', () => {
      editingSubtasks[index].isCompleted = checkbox.checked;
      renderSubtasksList();
    });

    // タイトルを編集可能にする
    if (subtask.isEditing) {
      const input = document.createElement('input');
      input.type = 'text';
      input.value = subtask.title || '';
      input.className = 'subtask-input';
      input.maxLength = 100;
      input.placeholder = 'サブタスク名を入力';

      input.addEventListener('blur', () => {
        if (input.value.trim()) {
          editingSubtasks[index].title = input.value.trim();
          editingSubtasks[index].isEditing = false;
          renderSubtasksList();
        } else {
          // 空の場合は削除
          editingSubtasks.splice(index, 1);
          renderSubtasksList();
        }
      });

      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          input.blur();
        }
      });

      item.appendChild(checkbox);
      item.appendChild(input);
      container.appendChild(item);

      // 自動フォーカス
      setTimeout(() => input.focus(), 0);
    } else {
      const title = document.createElement('span');
      title.textContent = subtask.title;

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = '×';
      deleteBtn.addEventListener('click', () => {
        editingSubtasks.splice(index, 1);
        renderSubtasksList();
      });

      item.appendChild(checkbox);
      item.appendChild(title);
      item.appendChild(deleteBtn);
      container.appendChild(item);
    }
  });
}

// サブタスク追加
function addSubtask() {
  const subtask = {
    id: generateUUID(),
    title: '',
    memo: '',
    dueDate: null,
    isCompleted: false,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    parentId: editingTaskId,
    isTutorial: false,
    totalTime: 0,
    isTimerRunning: false,
    timerStartTime: null,
    isEditing: true
  };

  editingSubtasks.push(subtask);
  renderSubtasksList();
}

// タスク保存
function saveTask() {
  const title = document.getElementById('task-title').value.trim();
  if (!title) {
    alert('タスク名を入力してください');
    return;
  }

  const memo = document.getElementById('task-memo').value.trim();
  const dueDateInput = document.getElementById('task-due-date').value;
  const durationValue = document.getElementById('task-duration').value;
  const duration = durationValue ? parseInt(durationValue) : null;
  const startTime = document.getElementById('task-start-time').value || null;
  const endTime = document.getElementById('task-end-time').value || null;
  const urgent = document.getElementById('task-urgent').checked;
  const priority = document.getElementById('task-priority').value;

  // 期限日のみ（時刻なし）
  let dueDate = null;
  if (dueDateInput) {
    dueDate = new Date(dueDateInput + 'T00:00:00').toISOString();
  }

  if (editingTaskId) {
    // 更新
    updateTask(editingTaskId, { title, memo, dueDate, duration, startTime, endTime, urgent, priority });

    // サブタスク保存
    const tasks = getTasks();
    const existingSubtaskIds = getSubtasks(editingTaskId).map(st => st.id);

    // 削除されたサブタスクを処理
    existingSubtaskIds.forEach(id => {
      if (!editingSubtasks.find(st => st.id === id)) {
        deleteTask(id);
      }
    });

    // サブタスクを保存
    editingSubtasks.forEach(subtask => {
      const existingTask = getTaskById(subtask.id);
      if (existingTask) {
        updateTask(subtask.id, subtask);
      } else {
        const newTasks = getTasks();
        // サブタスクに duration が指定されていれば反映（通常は null）
        if (subtask.duration === undefined) subtask.duration = null;
        newTasks.unshift(subtask);
        saveTasks(newTasks);
      }
    });

    // サブタスクの時間をメインタスクに集計
    if (typeof aggregateSubtaskTimes === 'function') {
      aggregateSubtaskTimes(editingTaskId);
    }
  } else {
    // 新規作成
    const tasks = getTasks();
    const now = new Date().toISOString();
    const task = {
      id: generateUUID(),
      title: title,
      memo: memo,
      dueDate: dueDate,
      isCompleted: false,
      createdAt: now,
      updatedAt: now,
      parentId: null,
      isTutorial: false,
      totalTime: 0,
      isTimerRunning: false,
      timerStartTime: null,
      duration: duration,
      startTime: startTime,
      endTime: endTime,
      urgent: urgent,
      priority: priority
    };
    tasks.unshift(task);
    saveTasks(tasks);

    // 履歴に追加
    if (typeof addToTaskHistory === 'function') {
      addToTaskHistory(task.title, null, null, 20);
      try {
        document.dispatchEvent(new CustomEvent('task:history:updated'));
      } catch (e) {
        console.warn('CustomEvent dispatch failed for task:history:updated', e);
      }
    }
  }

  closeModal();
  renderTasks();
}

// タスク削除
function deleteCurrentTask() {
  if (!editingTaskId) return;

  confirmAction('このタスクを削除しますか？', () => {
    deleteTask(editingTaskId);
    closeModal();
    renderTasks();
  });
}

// 確認ダイアログ
function confirmAction(message, callback) {
  document.getElementById('confirm-message').textContent = message;
  document.getElementById('confirm-modal').classList.add('show');

  const okBtn = document.getElementById('confirm-ok-btn');
  const cancelBtn = document.getElementById('confirm-cancel-btn');

  const handleOk = () => {
    document.getElementById('confirm-modal').classList.remove('show');
    callback();
    cleanup();
  };

  const handleCancel = () => {
    document.getElementById('confirm-modal').classList.remove('show');
    cleanup();
  };

  const cleanup = () => {
    okBtn.removeEventListener('click', handleOk);
    cancelBtn.removeEventListener('click', handleCancel);
  };

  okBtn.addEventListener('click', handleOk);
  cancelBtn.addEventListener('click', handleCancel);
}

// ========================================
// 時間フィールドの自動計算
// ========================================

// 開始時刻と所要時間から終了時刻を自動計算
function setupTimeAutoCalculation() {
  const startTimeInput = document.getElementById('task-start-time');
  const durationInput = document.getElementById('task-duration');
  const endTimeInput = document.getElementById('task-end-time');

  // イベントリスナーを削除してから再設定（重複防止）
  const newStartTimeInput = startTimeInput.cloneNode(true);
  const newDurationInput = durationInput.cloneNode(true);
  startTimeInput.parentNode.replaceChild(newStartTimeInput, startTimeInput);
  durationInput.parentNode.replaceChild(newDurationInput, durationInput);

  const calculateEndTime = () => {
    const startTime = document.getElementById('task-start-time').value;
    const duration = document.getElementById('task-duration').value;
    const endTime = document.getElementById('task-end-time').value;

    // 開始時刻と所要時間が入力されていて、終了時刻が未入力の場合
    if (startTime && duration && !endTime) {
      const [startHour, startMin] = startTime.split(':').map(Number);
      const durationMinutes = parseInt(duration);

      // 開始時刻（分単位）
      const startTotalMinutes = startHour * 60 + startMin;
      // 終了時刻（分単位）
      let endTotalMinutes = startTotalMinutes + durationMinutes;

      // 24時間を超える場合は24時間以内に収める（翌日への繰越）
      if (endTotalMinutes >= 24 * 60) {
        endTotalMinutes = endTotalMinutes % (24 * 60);
      }

      const endHour = Math.floor(endTotalMinutes / 60);
      const endMin = endTotalMinutes % 60;

      // 終了時刻を設定
      document.getElementById('task-end-time').value =
        `${String(endHour).padStart(2, '0')}:${String(endMin).padStart(2, '0')}`;
    }
  };

  // 開始時刻が変更されたとき
  document.getElementById('task-start-time').addEventListener('input', calculateEndTime);
  // 所要時間が変更されたとき
  document.getElementById('task-duration').addEventListener('change', calculateEndTime);
}

// ========================================
// 設定モーダル
// ========================================

// 設定モーダルを開く
function openSettingsModal() {
  console.log('[MODALS] openSettingsModal called');
  try {
    renderRoutinesList();

    // ゲージ時間表記パターンの初期化
    const gaugePatternSelect = document.getElementById('gauge-time-pattern');
    if (gaugePatternSelect && typeof getGaugeTimePattern === 'function') {
      const currentPattern = getGaugeTimePattern();
      gaugePatternSelect.value = currentPattern.toString();
    }

    const modal = document.getElementById('settings-modal');
    if (modal) {
      console.log('[MODALS] Modal element found');
      console.log('[MODALS] [BEFORE] Modal classList:', Array.from(modal.classList));
      console.log('[MODALS] [BEFORE] Modal display:', window.getComputedStyle(modal).display);

      modal.classList.add('show');

      console.log('[MODALS] [AFTER] Modal classList:', Array.from(modal.classList));
      console.log('[MODALS] [AFTER] Modal display:', window.getComputedStyle(modal).display);
      console.log('[MODALS] [AFTER] Has show class?', modal.classList.contains('show'));
    } else {
      console.error('[MODALS] settings-modal element not found');
    }
  } catch (error) {
    console.error('[MODALS] Error in openSettingsModal:', error);
  }
}

// グローバルスコープに登録
window.openSettingsModal = openSettingsModal;

// ルーティンリストを描画
function renderRoutinesList() {
  try {
    console.log('renderRoutinesList called');
    const routines = getRoutines();
    console.log('Routines:', routines);
    const container = document.getElementById('routines-list');
    if (!container) {
      console.error('routines-list container not found');
      return;
    }
    console.log('Container found:', container);
    container.innerHTML = '';

  if (!Array.isArray(routines)) {
    console.error('Routines is not an array:', routines);
    return;
  }

  console.log('Rendering', routines.length, 'routines');
  routines.forEach((routine, index) => {
    const item = document.createElement('div');
    item.className = 'routine-item';

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.className = 'routine-name-input';
    nameInput.value = routine.name || '';
    nameInput.placeholder = 'ルーティン名を入力';
    nameInput.maxLength = 50;
    nameInput.dataset.index = index;

    // 詳細設定ボタン
    const detailBtn = document.createElement('button');
    detailBtn.type = 'button';
    detailBtn.className = 'routine-detail-btn';
    detailBtn.textContent = '⏰';
    detailBtn.title = '時刻設定';
    detailBtn.addEventListener('click', (e) => {
      e.preventDefault();
      const detailPanel = item.querySelector('.routine-detail-panel');
      if (detailPanel.style.display === 'none') {
        detailPanel.style.display = 'flex';
      } else {
        detailPanel.style.display = 'none';
      }
    });

    const durationInput = document.createElement('select');
    durationInput.className = 'routine-duration-input';
    durationInput.dataset.index = index;

    // 時間オプション
    const durationOptions = [
      { value: 5, text: '5分' },
      { value: 10, text: '10分' },
      { value: 15, text: '15分' },
      { value: 30, text: '30分' },
      { value: 45, text: '45分' },
      { value: 60, text: '1時間' },
      { value: 90, text: '1時間30分' },
      { value: 120, text: '2時間' },
      { value: 180, text: '3時間' },
      { value: 240, text: '4時間' },
      { value: 360, text: '6時間' },
      { value: 420, text: '7時間' },
      { value: 480, text: '8時間' },
      { value: 540, text: '9時間' }
    ];

    durationOptions.forEach(opt => {
      const option = document.createElement('option');
      option.value = opt.value;
      option.textContent = opt.text;
      if (routine.duration === opt.value) {
        option.selected = true;
      }
      durationInput.appendChild(option);
    });

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'routine-delete-btn';
    deleteBtn.textContent = '×';
    deleteBtn.type = 'button';
    deleteBtn.addEventListener('click', () => {
      deleteRoutine(index);
    });

    // 詳細パネル（開始時刻・終了時刻）
    const detailPanel = document.createElement('div');
    detailPanel.className = 'routine-detail-panel';
    detailPanel.style.display = 'none';
    detailPanel.style.flexDirection = 'column';
    detailPanel.style.gap = '8px';
    detailPanel.style.padding = '8px';
    detailPanel.style.width = '100%';
    detailPanel.style.boxSizing = 'border-box';

    // 開始時刻
    const startTimeContainer = document.createElement('div');
    startTimeContainer.style.display = 'flex';
    startTimeContainer.style.alignItems = 'center';
    startTimeContainer.style.gap = '8px';

    const startTimeLabel = document.createElement('label');
    startTimeLabel.textContent = '開始:';
    startTimeLabel.style.minWidth = '60px';
    const startTimeInput = document.createElement('input');
    startTimeInput.type = 'time';
    startTimeInput.className = 'routine-time-input';
    startTimeInput.value = routine.startTime || '';
    startTimeInput.dataset.index = index;
    startTimeInput.dataset.field = 'startTime';
    startTimeInput.style.flex = '1';

    startTimeContainer.appendChild(startTimeLabel);
    startTimeContainer.appendChild(startTimeInput);

    // 終了時刻
    const endTimeContainer = document.createElement('div');
    endTimeContainer.style.display = 'flex';
    endTimeContainer.style.alignItems = 'center';
    endTimeContainer.style.gap = '8px';

    const endTimeLabel = document.createElement('label');
    endTimeLabel.textContent = '終了:';
    endTimeLabel.style.minWidth = '60px';
    const endTimeInput = document.createElement('input');
    endTimeInput.type = 'time';
    endTimeInput.className = 'routine-time-input';
    endTimeInput.value = routine.endTime || '';
    endTimeInput.dataset.index = index;
    endTimeInput.dataset.field = 'endTime';
    endTimeInput.style.flex = '1';

    endTimeContainer.appendChild(endTimeLabel);
    endTimeContainer.appendChild(endTimeInput);

    // 緊急フラグ
    const urgentContainer = document.createElement('div');
    urgentContainer.style.display = 'flex';
    urgentContainer.style.alignItems = 'center';
    urgentContainer.style.gap = '8px';

    const urgentLabel = document.createElement('label');
    urgentLabel.textContent = '緊急:';
    urgentLabel.style.minWidth = '60px';
    const urgentCheckbox = document.createElement('input');
    urgentCheckbox.type = 'checkbox';
    urgentCheckbox.className = 'routine-urgent-input';
    urgentCheckbox.checked = routine.urgent || false;
    urgentCheckbox.dataset.index = index;
    urgentCheckbox.dataset.field = 'urgent';

    urgentContainer.appendChild(urgentLabel);
    urgentContainer.appendChild(urgentCheckbox);

    // 優先順位
    const priorityContainer = document.createElement('div');
    priorityContainer.style.display = 'flex';
    priorityContainer.style.alignItems = 'center';
    priorityContainer.style.gap = '8px';

    const priorityLabel = document.createElement('label');
    priorityLabel.textContent = '優先順位:';
    priorityLabel.style.minWidth = '60px';
    const prioritySelect = document.createElement('select');
    prioritySelect.className = 'routine-priority-input';
    prioritySelect.dataset.index = index;
    prioritySelect.dataset.field = 'priority';
    prioritySelect.style.flex = '1';

    const priorityOptions = [
      { value: '', text: '未設定' },
      { value: 'high', text: '高' },
      { value: 'medium', text: '中' },
      { value: 'low', text: '低' }
    ];

    priorityOptions.forEach(opt => {
      const option = document.createElement('option');
      option.value = opt.value;
      option.textContent = opt.text;
      if (routine.priority === opt.value) {
        option.selected = true;
      }
      prioritySelect.appendChild(option);
    });

    priorityContainer.appendChild(priorityLabel);
    priorityContainer.appendChild(prioritySelect);

    // 期間設定
    const dateRangeLabel = document.createElement('label');
    dateRangeLabel.textContent = '期間:';
    dateRangeLabel.style.width = '100%';
    dateRangeLabel.style.marginTop = '4px';
    dateRangeLabel.style.fontWeight = 'bold';

    const dateRangeContainer = document.createElement('div');
    dateRangeContainer.style.display = 'flex';
    dateRangeContainer.style.flexDirection = 'column';
    dateRangeContainer.style.gap = '4px';
    dateRangeContainer.style.width = '100%';

    // ラジオボタン: 期日なし
    const radioNoneContainer = document.createElement('div');
    const radioNone = document.createElement('input');
    radioNone.type = 'radio';
    radioNone.name = `routine-daterange-${index}`;
    radioNone.value = 'none';
    radioNone.className = 'routine-daterange-radio';
    radioNone.dataset.index = index;
    const dateRange = routine.dateRange || { type: 'none' };
    radioNone.checked = dateRange.type === 'none';

    const radioNoneLabel = document.createElement('label');
    radioNoneLabel.textContent = '期日なし（毎日）';
    radioNoneLabel.style.marginLeft = '4px';
    radioNoneContainer.appendChild(radioNone);
    radioNoneContainer.appendChild(radioNoneLabel);

    // ラジオボタン: 期間設定
    const radioPeriodContainer = document.createElement('div');
    const radioPeriod = document.createElement('input');
    radioPeriod.type = 'radio';
    radioPeriod.name = `routine-daterange-${index}`;
    radioPeriod.value = 'period';
    radioPeriod.className = 'routine-daterange-radio';
    radioPeriod.dataset.index = index;
    radioPeriod.checked = dateRange.type === 'period';

    const radioPeriodLabel = document.createElement('label');
    radioPeriodLabel.textContent = '期間設定';
    radioPeriodLabel.style.marginLeft = '4px';
    radioPeriodContainer.appendChild(radioPeriod);
    radioPeriodContainer.appendChild(radioPeriodLabel);

    // 期間設定の日付入力フィールド
    const periodInputsContainer = document.createElement('div');
    periodInputsContainer.style.display = dateRange.type === 'period' ? 'flex' : 'none';
    periodInputsContainer.style.flexDirection = 'column';
    periodInputsContainer.style.gap = '4px';
    periodInputsContainer.style.marginLeft = '20px';
    periodInputsContainer.className = 'routine-period-inputs';
    periodInputsContainer.dataset.index = index;

    const startDateContainer = document.createElement('div');
    startDateContainer.style.display = 'flex';
    startDateContainer.style.alignItems = 'center';
    startDateContainer.style.gap = '8px';

    const startDateLabel = document.createElement('label');
    startDateLabel.textContent = '開始日:';
    startDateLabel.style.minWidth = '60px';
    const startDateInput = document.createElement('input');
    startDateInput.type = 'date';
    startDateInput.className = 'routine-daterange-start';
    startDateInput.value = dateRange.startDate || '';
    startDateInput.dataset.index = index;
    startDateInput.style.flex = '1';

    startDateContainer.appendChild(startDateLabel);
    startDateContainer.appendChild(startDateInput);

    const endDateContainer = document.createElement('div');
    endDateContainer.style.display = 'flex';
    endDateContainer.style.alignItems = 'center';
    endDateContainer.style.gap = '8px';

    const endDateLabel = document.createElement('label');
    endDateLabel.textContent = '終了日:';
    endDateLabel.style.minWidth = '60px';
    const endDateInput = document.createElement('input');
    endDateInput.type = 'date';
    endDateInput.className = 'routine-daterange-end';
    endDateInput.value = dateRange.endDate || '';
    endDateInput.dataset.index = index;
    endDateInput.style.flex = '1';

    endDateContainer.appendChild(endDateLabel);
    endDateContainer.appendChild(endDateInput);

    periodInputsContainer.appendChild(startDateContainer);
    periodInputsContainer.appendChild(endDateContainer);

    // ラジオボタン変更時の処理
    radioNone.addEventListener('change', () => {
      if (radioNone.checked) {
        periodInputsContainer.style.display = 'none';
      }
    });
    radioPeriod.addEventListener('change', () => {
      if (radioPeriod.checked) {
        periodInputsContainer.style.display = 'flex';
      }
    });

    dateRangeContainer.appendChild(radioNoneContainer);
    dateRangeContainer.appendChild(radioPeriodContainer);
    dateRangeContainer.appendChild(periodInputsContainer);

    detailPanel.appendChild(startTimeContainer);
    detailPanel.appendChild(endTimeContainer);
    detailPanel.appendChild(urgentContainer);
    detailPanel.appendChild(priorityContainer);
    detailPanel.appendChild(dateRangeLabel);
    detailPanel.appendChild(dateRangeContainer);

    // アイテムに追加
    item.appendChild(nameInput);
    item.appendChild(durationInput);
    item.appendChild(detailBtn);
    item.appendChild(deleteBtn);
    item.appendChild(detailPanel);
    container.appendChild(item);
  });
  } catch (e) {
    console.error('Error in renderRoutinesList:', e);
    alert('ルーティンリストの表示エラー: ' + e.message);
  }
}

// ルーティンを削除
function deleteRoutine(index) {
  const routines = getRoutines();
  routines.splice(index, 1);
  saveRoutines(routines);
  renderRoutinesList();
}

// ルーティンを追加
function addRoutine() {
  // 現在の入力内容を保存してから新しいルーティンを追加
  const nameInputs = document.querySelectorAll('.routine-name-input');
  const durationInputs = document.querySelectorAll('.routine-duration-input');
  const timeInputs = document.querySelectorAll('.routine-time-input');
  const routines = [];

  nameInputs.forEach((nameInput, index) => {
    const name = nameInput.value.trim();
    const existingRoutines = getRoutines();

    // 開始時刻と終了時刻を取得
    let startTime = '';
    let endTime = '';
    timeInputs.forEach(input => {
      const inputIndex = parseInt(input.dataset.index);
      if (inputIndex === index) {
        if (input.dataset.field === 'startTime') {
          startTime = input.value || '';
        } else if (input.dataset.field === 'endTime') {
          endTime = input.value || '';
        }
      }
    });

    // 緊急フラグと優先順位を取得
    const urgentCheckbox = document.querySelector(`.routine-urgent-input[data-index="${index}"]`);
    const prioritySelect = document.querySelector(`.routine-priority-input[data-index="${index}"]`);
    const urgent = urgentCheckbox ? urgentCheckbox.checked : false;
    const priority = prioritySelect ? prioritySelect.value : '';

    // 期間設定を取得
    const dateRangeRadios = document.querySelectorAll(`.routine-daterange-radio[data-index="${index}"]`);
    let dateRangeType = 'none';
    dateRangeRadios.forEach(radio => {
      if (radio.checked) {
        dateRangeType = radio.value;
      }
    });

    const startDateInput = document.querySelector(`.routine-daterange-start[data-index="${index}"]`);
    const endDateInput = document.querySelector(`.routine-daterange-end[data-index="${index}"]`);
    const dateRange = {
      type: dateRangeType,
      startDate: dateRangeType === 'period' && startDateInput ? startDateInput.value : null,
      endDate: dateRangeType === 'period' && endDateInput ? endDateInput.value : null
    };

    const routine = {
      id: existingRoutines[index]?.id || generateUUID(),
      name: name,
      duration: parseInt(durationInputs[index].value),
      startTime: startTime,
      endTime: endTime,
      urgent: urgent,
      priority: priority,
      dateRange: dateRange
    };
    routines.push(routine);
  });

  // 新しい空のルーティンを追加
  const newRoutine = {
    id: generateUUID(),
    name: '',
    duration: 30,
    startTime: '',
    endTime: '',
    urgent: false,
    priority: '',
    dateRange: { type: 'none', startDate: null, endDate: null }
  };
  routines.push(newRoutine);

  saveRoutines(routines);
  renderRoutinesList();

  // 新規ルーティンの名前入力にフォーカス
  setTimeout(() => {
    const inputs = document.querySelectorAll('.routine-name-input');
    if (inputs.length > 0) {
      inputs[inputs.length - 1].focus();
    }
  }, 0);
}

// 設定モーダルを閉じる
function closeSettingsModal() {
  console.log('[MODALS] closeSettingsModal called');
  const modal = document.getElementById('settings-modal');
  if (modal) {
    // 閉じるアニメーションを開始
    modal.classList.add('hiding');

    // アニメーション終了後に実際に閉じる
    setTimeout(() => {
      modal.classList.remove('show', 'hiding');
    }, 200); // 200ms（アニメーション時間）
  }
}

// グローバルスコープに登録
window.closeSettingsModal = closeSettingsModal;

// 設定を保存
function saveSettings() {
  const routines = [];
  const nameInputs = document.querySelectorAll('.routine-name-input');
  const durationInputs = document.querySelectorAll('.routine-duration-input');
  const timeInputs = document.querySelectorAll('.routine-time-input');

  nameInputs.forEach((nameInput, index) => {
    const name = nameInput.value.trim();
    if (name) {
      // 開始時刻と終了時刻を取得
      let startTime = '';
      let endTime = '';
      timeInputs.forEach(input => {
        const inputIndex = parseInt(input.dataset.index);
        if (inputIndex === index) {
          if (input.dataset.field === 'startTime') {
            startTime = input.value || '';
          } else if (input.dataset.field === 'endTime') {
            endTime = input.value || '';
          }
        }
      });

      // 緊急フラグと優先順位を取得
      const urgentCheckbox = document.querySelector(`.routine-urgent-input[data-index="${index}"]`);
      const prioritySelect = document.querySelector(`.routine-priority-input[data-index="${index}"]`);
      const urgent = urgentCheckbox ? urgentCheckbox.checked : false;
      const priority = prioritySelect ? prioritySelect.value : '';

      // 期間設定を取得
      const dateRangeRadios = document.querySelectorAll(`.routine-daterange-radio[data-index="${index}"]`);
      let dateRangeType = 'none';
      dateRangeRadios.forEach(radio => {
        if (radio.checked) {
          dateRangeType = radio.value;
        }
      });

      const startDateInput = document.querySelector(`.routine-daterange-start[data-index="${index}"]`);
      const endDateInput = document.querySelector(`.routine-daterange-end[data-index="${index}"]`);
      const dateRange = {
        type: dateRangeType,
        startDate: dateRangeType === 'period' && startDateInput ? startDateInput.value : null,
        endDate: dateRangeType === 'period' && endDateInput ? endDateInput.value : null
      };

      const routine = {
        id: getRoutines()[index]?.id || generateUUID(),
        name: name,
        duration: parseInt(durationInputs[index].value),
        startTime: startTime,
        endTime: endTime,
        urgent: urgent,
        priority: priority,
        dateRange: dateRange
      };
      routines.push(routine);
    }
  });

  saveRoutines(routines);

  // ゲージ時間表記パターンを保存
  const gaugePatternSelect = document.getElementById('gauge-time-pattern');
  if (gaugePatternSelect && typeof setGaugeTimePattern === 'function') {
    const selectedPattern = parseInt(gaugePatternSelect.value);
    setGaugeTimePattern(selectedPattern);
  }

  // 既存タスクへの反映と新規タスク作成
  routines.forEach(routine => {
    // 既存タスクを更新
    if (typeof updateRoutineTasks === 'function') {
      updateRoutineTasks(routine);
    }
  });

  // 新規ルーティンタスクを作成
  createRoutineTasks();

  closeSettingsModal();
  renderTasks();
}

// ========================================
// ログインモーダル
// ========================================

// ログインモーダルを開く
function openLoginModal() {
  console.log('[MODALS] openLoginModal called');
  const modal = document.getElementById('login-modal');
  if (modal) {
    console.log('[MODALS] Modal element found');
    // 現在のユーザー情報を更新
    updateCurrentUserInfo();
    modal.classList.add('show');
    console.log('[MODALS] Show class added, classList:', Array.from(modal.classList));
  } else {
    console.error('[MODALS] login-modal element not found');
  }
}

// グローバルスコープに登録
window.openLoginModal = openLoginModal;

// ログインモーダルを閉じる
function closeLoginModal() {
  console.log('[MODALS] closeLoginModal called');
  const modal = document.getElementById('login-modal');
  if (modal) {
    // 閉じるアニメーションを開始
    modal.classList.add('hiding');

    // アニメーション終了後に実際に閉じる
    setTimeout(() => {
      modal.classList.remove('show', 'hiding');
    }, 200); // 200ms（アニメーション時間）
  }
}

// グローバルスコープに登録
window.closeLoginModal = closeLoginModal;

// 現在のユーザー情報を更新
function updateCurrentUserInfo() {
  const userInfoElement = document.getElementById('current-user-info');
  if (!userInfoElement) return;

  if (typeof FirestoreBridge !== 'undefined') {
    const userId = FirestoreBridge.getUserId();
    if (userId && userId !== 'anonymous') {
      userInfoElement.textContent = 'ユーザーID: ' + userId.substring(0, 8) + '...';
    } else {
      userInfoElement.textContent = '匿名ユーザー';
    }
  } else {
    userInfoElement.textContent = '匿名ユーザー（Web版）';
  }
}
```

### modals-01-create-edit.js

```javascript
// ========================================
// モーダル管理
// ========================================

// 新規作成モーダルを開く
function openCreateModal() {
  editingTaskId = null;

  document.getElementById('modal-title').textContent = '新規タスク';
  document.getElementById('task-title').value = '';
  document.getElementById('task-memo').value = '';

  // 今日の日付をデフォルトに設定
  const today = new Date();
  const localISO = new Date(today.getTime() - today.getTimezoneOffset() * 60000).toISOString().slice(0, 10);
  document.getElementById('task-due-date').value = localISO;

  document.getElementById('task-duration').value = '';
  document.getElementById('task-start-time').value = '';
  document.getElementById('task-end-time').value = '';
  document.getElementById('task-urgent').checked = false;
  document.getElementById('task-priority').value = '';
  document.getElementById('title-char-count').textContent = '0';
  document.getElementById('delete-btn').style.display = 'none';
  document.getElementById('timer-section').style.display = 'none';
  document.getElementById('subtasks-section').style.display = 'none';
  document.getElementById('save-btn').disabled = true;

  // 時間フィールドの自動計算イベントを設定
  setupTimeAutoCalculation();

  document.getElementById('task-modal').classList.add('show');
  document.getElementById('task-title').focus();
}

// 編集モーダルを開く
function openEditModal(id) {
  const task = getTaskById(id);
  if (!task) return;

  editingTaskId = id;

  document.getElementById('modal-title').textContent = 'タスク編集';
  document.getElementById('task-title').value = task.title;
  document.getElementById('task-memo').value = task.memo;
  document.getElementById('title-char-count').textContent = task.title.length;

  if (task.dueDate) {
    // ISO形式をdate形式に変換
    const date = new Date(task.dueDate);
    const localISO = new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().slice(0, 10);
    document.getElementById('task-due-date').value = localISO;
  } else {
    document.getElementById('task-due-date').value = '';
  }
  // 所要時間・開始時刻・終了時刻・緊急・優先順位を反映
  document.getElementById('task-duration').value = task.duration || '';
  document.getElementById('task-start-time').value = task.startTime || '';
  document.getElementById('task-end-time').value = task.endTime || '';
  document.getElementById('task-urgent').checked = task.urgent || false;
  document.getElementById('task-priority').value = task.priority || '';

  document.getElementById('delete-btn').style.display = 'inline-block';
  document.getElementById('timer-section').style.display = 'block';
  document.getElementById('subtasks-section').style.display = 'block';
  document.getElementById('save-btn').disabled = false;

  // サブタスクリスト表示
  editingSubtasks = getSubtasks(id);
  renderSubtasksList();

  // タイマー表示更新
  updateTimerDisplay(id);

  // タイマー更新インターバル設定
  if (timerInterval) {
    clearInterval(timerInterval);
  }
  timerInterval = setInterval(() => {
    if (editingTaskId) {
      updateTimerDisplay(editingTaskId);
    }
  }, 1000);

  // 時間フィールドの自動計算イベントを設定
  setupTimeAutoCalculation();

  document.getElementById('task-modal').classList.add('show');
  document.getElementById('task-title').focus();
}

// モーダルを閉じる
function closeModal() {
  const modal = document.getElementById('task-modal');

  // 閉じるアニメーションを開始
  modal.classList.add('hiding');

  // アニメーション終了後に実際に閉じる
  setTimeout(() => {
    modal.classList.remove('show', 'hiding');
    editingTaskId = null;
    editingSubtasks = [];

    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
  }, 200); // 200ms（アニメーション時間）
}

// サブタスクリスト表示
function renderSubtasksList() {
  const container = document.getElementById('subtasks-list');
  container.innerHTML = '';

  editingSubtasks.forEach((subtask, index) => {
    const item = document.createElement('div');
    item.className = 'subtask-item' + (subtask.isCompleted ? ' completed' : '');

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = subtask.isCompleted;
    checkbox.addEventListener('change', () => {
      editingSubtasks[index].isCompleted = checkbox.checked;
      renderSubtasksList();
    });

    // タイトルを編集可能にする
    if (subtask.isEditing) {
      const input = document.createElement('input');
      input.type = 'text';
      input.value = subtask.title || '';
      input.className = 'subtask-input';
      input.maxLength = 100;
      input.placeholder = 'サブタスク名を入力';

      input.addEventListener('blur', () => {
        if (input.value.trim()) {
          editingSubtasks[index].title = input.value.trim();
          editingSubtasks[index].isEditing = false;
          renderSubtasksList();
        } else {
          // 空の場合は削除
          editingSubtasks.splice(index, 1);
          renderSubtasksList();
        }
      });

      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          input.blur();
        }
      });

      item.appendChild(checkbox);
      item.appendChild(input);
      container.appendChild(item);

      // 自動フォーカス
      setTimeout(() => input.focus(), 0);
    } else {
      const title = document.createElement('span');
      title.textContent = subtask.title;

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = '×';
      deleteBtn.addEventListener('click', () => {
        editingSubtasks.splice(index, 1);
        renderSubtasksList();
      });

      item.appendChild(checkbox);
      item.appendChild(title);
      item.appendChild(deleteBtn);
      container.appendChild(item);
    }
  });
}

// サブタスク追加
function addSubtask() {
  const subtask = {
    id: generateUUID(),
    title: '',
    memo: '',
    dueDate: null,
    isCompleted: false,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    parentId: editingTaskId,
    isTutorial: false,
    totalTime: 0,
    isTimerRunning: false,
    timerStartTime: null,
    isEditing: true
  };

  editingSubtasks.push(subtask);
  renderSubtasksList();
}

// タスク保存
function saveTask() {
  const title = document.getElementById('task-title').value.trim();
  if (!title) {
    alert('タスク名を入力してください');
    return;
  }

  const memo = document.getElementById('task-memo').value.trim();
  const dueDateInput = document.getElementById('task-due-date').value;
  const durationValue = document.getElementById('task-duration').value;
  const duration = durationValue ? parseInt(durationValue) : null;
  const startTime = document.getElementById('task-start-time').value || null;
  const endTime = document.getElementById('task-end-time').value || null;
  const urgent = document.getElementById('task-urgent').checked;
  const priority = document.getElementById('task-priority').value;

  // 期限日のみ（時刻なし）
  let dueDate = null;
  if (dueDateInput) {
    dueDate = new Date(dueDateInput + 'T00:00:00').toISOString();
  }

  if (editingTaskId) {
    // 更新
    updateTask(editingTaskId, { title, memo, dueDate, duration, startTime, endTime, urgent, priority });

    // サブタスク保存
    const tasks = getTasks();
    const existingSubtaskIds = getSubtasks(editingTaskId).map(st => st.id);

    // 削除されたサブタスクを処理
    existingSubtaskIds.forEach(id => {
      if (!editingSubtasks.find(st => st.id === id)) {
        deleteTask(id);
      }
    });

    // サブタスクを保存
    editingSubtasks.forEach(subtask => {
      const existingTask = getTaskById(subtask.id);
      if (existingTask) {
        updateTask(subtask.id, subtask);
      } else {
        const newTasks = getTasks();
        // サブタスクに duration が指定されていれば反映（通常は null）
        if (subtask.duration === undefined) subtask.duration = null;
        newTasks.unshift(subtask);
```

### modals-02-subtasks.js

```javascript
        saveTasks(newTasks);
      }
    });

    // サブタスクの時間をメインタスクに集計
    if (typeof aggregateSubtaskTimes === 'function') {
      aggregateSubtaskTimes(editingTaskId);
    }
  } else {
    // 新規作成
    const tasks = getTasks();
    const now = new Date().toISOString();
    const task = {
      id: generateUUID(),
      title: title,
      memo: memo,
      dueDate: dueDate,
      isCompleted: false,
      createdAt: now,
      updatedAt: now,
      parentId: null,
      isTutorial: false,
      totalTime: 0,
      isTimerRunning: false,
      timerStartTime: null,
      duration: duration,
      startTime: startTime,
      endTime: endTime,
      urgent: urgent,
      priority: priority
    };
    tasks.unshift(task);
    saveTasks(tasks);

    // 履歴に追加
    if (typeof addToTaskHistory === 'function') {
      addToTaskHistory(task.title, null, null, 20);
      try {
        document.dispatchEvent(new CustomEvent('task:history:updated'));
      } catch (e) {
        console.warn('CustomEvent dispatch failed for task:history:updated', e);
      }
    }
  }

  closeModal();
  renderTasks();
}

// タスク削除
function deleteCurrentTask() {
  if (!editingTaskId) return;

  confirmAction('このタスクを削除しますか？', () => {
    deleteTask(editingTaskId);
    closeModal();
    renderTasks();
  });
}

// 確認ダイアログ
function confirmAction(message, callback) {
  document.getElementById('confirm-message').textContent = message;
  document.getElementById('confirm-modal').classList.add('show');

  const okBtn = document.getElementById('confirm-ok-btn');
  const cancelBtn = document.getElementById('confirm-cancel-btn');

  const handleOk = () => {
    document.getElementById('confirm-modal').classList.remove('show');
    callback();
    cleanup();
  };

  const handleCancel = () => {
    document.getElementById('confirm-modal').classList.remove('show');
    cleanup();
  };

  const cleanup = () => {
    okBtn.removeEventListener('click', handleOk);
    cancelBtn.removeEventListener('click', handleCancel);
  };

  okBtn.addEventListener('click', handleOk);
  cancelBtn.addEventListener('click', handleCancel);
}

// ========================================
// 時間フィールドの自動計算
// ========================================

// 開始時刻と所要時間から終了時刻を自動計算
function setupTimeAutoCalculation() {
  const startTimeInput = document.getElementById('task-start-time');
  const durationInput = document.getElementById('task-duration');
  const endTimeInput = document.getElementById('task-end-time');

  // イベントリスナーを削除してから再設定（重複防止）
  const newStartTimeInput = startTimeInput.cloneNode(true);
  const newDurationInput = durationInput.cloneNode(true);
  startTimeInput.parentNode.replaceChild(newStartTimeInput, startTimeInput);
  durationInput.parentNode.replaceChild(newDurationInput, durationInput);

  const calculateEndTime = () => {
    const startTime = document.getElementById('task-start-time').value;
    const duration = document.getElementById('task-duration').value;
    const endTime = document.getElementById('task-end-time').value;

    // 開始時刻と所要時間が入力されていて、終了時刻が未入力の場合
    if (startTime && duration && !endTime) {
      const [startHour, startMin] = startTime.split(':').map(Number);
      const durationMinutes = parseInt(duration);

      // 開始時刻（分単位）
      const startTotalMinutes = startHour * 60 + startMin;
      // 終了時刻（分単位）
      let endTotalMinutes = startTotalMinutes + durationMinutes;

      // 24時間を超える場合は24時間以内に収める（翌日への繰越）
      if (endTotalMinutes >= 24 * 60) {
        endTotalMinutes = endTotalMinutes % (24 * 60);
      }

      const endHour = Math.floor(endTotalMinutes / 60);
      const endMin = endTotalMinutes % 60;

      // 終了時刻を設定
      document.getElementById('task-end-time').value =
        `${String(endHour).padStart(2, '0')}:${String(endMin).padStart(2, '0')}`;
    }
  };

  // 開始時刻が変更されたとき
  document.getElementById('task-start-time').addEventListener('input', calculateEndTime);
  // 所要時間が変更されたとき
  document.getElementById('task-duration').addEventListener('change', calculateEndTime);
}

// ========================================
// 設定モーダル
// ========================================

// 設定モーダルを開く
function openSettingsModal() {
  console.log('openSettingsModal called');
  renderRoutinesList();

  // ゲージ時間表記パターンの初期化
  const gaugePatternSelect = document.getElementById('gauge-time-pattern');
  if (gaugePatternSelect && typeof getGaugeTimePattern === 'function') {
    const currentPattern = getGaugeTimePattern();
    gaugePatternSelect.value = currentPattern.toString();
  }

  const modal = document.getElementById('settings-modal');
  if (modal) {
    console.log('[BEFORE] Modal classList:', Array.from(modal.classList));
    console.log('[BEFORE] Modal display:', window.getComputedStyle(modal).display);
    console.log('[BEFORE] Modal z-index:', window.getComputedStyle(modal).zIndex);

    modal.classList.add('show');

    console.log('[AFTER] Modal classList:', Array.from(modal.classList));
    console.log('[AFTER] Modal display:', window.getComputedStyle(modal).display);
    console.log('[AFTER] Modal z-index:', window.getComputedStyle(modal).zIndex);
    console.log('[AFTER] Has show class?', modal.classList.contains('show'));
  } else {
    console.error('settings-modal not found');
  }
}

// ルーティンリストを描画
function renderRoutinesList() {
  try {
    console.log('renderRoutinesList called');
    const routines = getRoutines();
    console.log('Routines:', routines);
    const container = document.getElementById('routines-list');
    if (!container) {
      console.error('routines-list container not found');
      return;
    }
    console.log('Container found:', container);
    container.innerHTML = '';

  if (!Array.isArray(routines)) {
    console.error('Routines is not an array:', routines);
    return;
  }

  console.log('Rendering', routines.length, 'routines');
  routines.forEach((routine, index) => {
    const item = document.createElement('div');
    item.className = 'routine-item';

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.className = 'routine-name-input';
    nameInput.value = routine.name || '';
    nameInput.placeholder = 'ルーティン名を入力';
    nameInput.maxLength = 50;
    nameInput.dataset.index = index;

    // 詳細設定ボタン
    const detailBtn = document.createElement('button');
    detailBtn.type = 'button';
    detailBtn.className = 'routine-detail-btn';
    detailBtn.textContent = '⏰';
    detailBtn.title = '時刻設定';
    detailBtn.addEventListener('click', (e) => {
      e.preventDefault();
      const detailPanel = item.querySelector('.routine-detail-panel');
      if (detailPanel.style.display === 'none') {
        detailPanel.style.display = 'flex';
      } else {
        detailPanel.style.display = 'none';
      }
    });

    const durationInput = document.createElement('select');
    durationInput.className = 'routine-duration-input';
    durationInput.dataset.index = index;

    // 時間オプション
    const durationOptions = [
      { value: 5, text: '5分' },
      { value: 10, text: '10分' },
      { value: 15, text: '15分' },
      { value: 30, text: '30分' },
      { value: 45, text: '45分' },
      { value: 60, text: '1時間' },
      { value: 90, text: '1時間30分' },
      { value: 120, text: '2時間' },
      { value: 180, text: '3時間' },
      { value: 240, text: '4時間' },
      { value: 360, text: '6時間' },
      { value: 420, text: '7時間' },
      { value: 480, text: '8時間' },
      { value: 540, text: '9時間' }
    ];

    durationOptions.forEach(opt => {
      const option = document.createElement('option');
      option.value = opt.value;
      option.textContent = opt.text;
      if (routine.duration === opt.value) {
        option.selected = true;
      }
      durationInput.appendChild(option);
```

### modals-03-settings-routines.js

```javascript
    });

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'routine-delete-btn';
    deleteBtn.textContent = '×';
    deleteBtn.type = 'button';
    deleteBtn.addEventListener('click', () => {
      deleteRoutine(index);
    });

    // 詳細パネル（開始時刻・終了時刻）
    const detailPanel = document.createElement('div');
    detailPanel.className = 'routine-detail-panel';
    detailPanel.style.display = 'none';
    detailPanel.style.flexDirection = 'column';
    detailPanel.style.gap = '8px';
    detailPanel.style.padding = '8px';
    detailPanel.style.width = '100%';
    detailPanel.style.boxSizing = 'border-box';

    // 開始時刻
    const startTimeContainer = document.createElement('div');
    startTimeContainer.style.display = 'flex';
    startTimeContainer.style.alignItems = 'center';
    startTimeContainer.style.gap = '8px';

    const startTimeLabel = document.createElement('label');
    startTimeLabel.textContent = '開始:';
    startTimeLabel.style.minWidth = '60px';
    const startTimeInput = document.createElement('input');
    startTimeInput.type = 'time';
    startTimeInput.className = 'routine-time-input';
    startTimeInput.value = routine.startTime || '';
    startTimeInput.dataset.index = index;
    startTimeInput.dataset.field = 'startTime';
    startTimeInput.style.flex = '1';

    startTimeContainer.appendChild(startTimeLabel);
    startTimeContainer.appendChild(startTimeInput);

    // 終了時刻
    const endTimeContainer = document.createElement('div');
    endTimeContainer.style.display = 'flex';
    endTimeContainer.style.alignItems = 'center';
    endTimeContainer.style.gap = '8px';

    const endTimeLabel = document.createElement('label');
    endTimeLabel.textContent = '終了:';
    endTimeLabel.style.minWidth = '60px';
    const endTimeInput = document.createElement('input');
    endTimeInput.type = 'time';
    endTimeInput.className = 'routine-time-input';
    endTimeInput.value = routine.endTime || '';
    endTimeInput.dataset.index = index;
    endTimeInput.dataset.field = 'endTime';
    endTimeInput.style.flex = '1';

    endTimeContainer.appendChild(endTimeLabel);
    endTimeContainer.appendChild(endTimeInput);

    // 緊急フラグ
    const urgentContainer = document.createElement('div');
    urgentContainer.style.display = 'flex';
    urgentContainer.style.alignItems = 'center';
    urgentContainer.style.gap = '8px';

    const urgentLabel = document.createElement('label');
    urgentLabel.textContent = '緊急:';
    urgentLabel.style.minWidth = '60px';
    const urgentCheckbox = document.createElement('input');
    urgentCheckbox.type = 'checkbox';
    urgentCheckbox.className = 'routine-urgent-input';
    urgentCheckbox.checked = routine.urgent || false;
    urgentCheckbox.dataset.index = index;
    urgentCheckbox.dataset.field = 'urgent';

    urgentContainer.appendChild(urgentLabel);
    urgentContainer.appendChild(urgentCheckbox);

    // 優先順位
    const priorityContainer = document.createElement('div');
    priorityContainer.style.display = 'flex';
    priorityContainer.style.alignItems = 'center';
    priorityContainer.style.gap = '8px';

    const priorityLabel = document.createElement('label');
    priorityLabel.textContent = '優先順位:';
    priorityLabel.style.minWidth = '60px';
    const prioritySelect = document.createElement('select');
    prioritySelect.className = 'routine-priority-input';
    prioritySelect.dataset.index = index;
    prioritySelect.dataset.field = 'priority';
    prioritySelect.style.flex = '1';

    const priorityOptions = [
      { value: '', text: '未設定' },
      { value: 'high', text: '高' },
      { value: 'medium', text: '中' },
      { value: 'low', text: '低' }
    ];

    priorityOptions.forEach(opt => {
      const option = document.createElement('option');
      option.value = opt.value;
      option.textContent = opt.text;
      if (routine.priority === opt.value) {
        option.selected = true;
      }
      prioritySelect.appendChild(option);
    });

    priorityContainer.appendChild(priorityLabel);
    priorityContainer.appendChild(prioritySelect);

    // 期間設定
    const dateRangeLabel = document.createElement('label');
    dateRangeLabel.textContent = '期間:';
    dateRangeLabel.style.width = '100%';
    dateRangeLabel.style.marginTop = '4px';
    dateRangeLabel.style.fontWeight = 'bold';

    const dateRangeContainer = document.createElement('div');
    dateRangeContainer.style.display = 'flex';
    dateRangeContainer.style.flexDirection = 'column';
    dateRangeContainer.style.gap = '4px';
    dateRangeContainer.style.width = '100%';

    // ラジオボタン: 期日なし
    const radioNoneContainer = document.createElement('div');
    const radioNone = document.createElement('input');
    radioNone.type = 'radio';
    radioNone.name = `routine-daterange-${index}`;
    radioNone.value = 'none';
    radioNone.className = 'routine-daterange-radio';
    radioNone.dataset.index = index;
    const dateRange = routine.dateRange || { type: 'none' };
    radioNone.checked = dateRange.type === 'none';

    const radioNoneLabel = document.createElement('label');
    radioNoneLabel.textContent = '期日なし（毎日）';
    radioNoneLabel.style.marginLeft = '4px';
    radioNoneContainer.appendChild(radioNone);
    radioNoneContainer.appendChild(radioNoneLabel);

    // ラジオボタン: 期間設定
    const radioPeriodContainer = document.createElement('div');
    const radioPeriod = document.createElement('input');
    radioPeriod.type = 'radio';
    radioPeriod.name = `routine-daterange-${index}`;
    radioPeriod.value = 'period';
    radioPeriod.className = 'routine-daterange-radio';
    radioPeriod.dataset.index = index;
    radioPeriod.checked = dateRange.type === 'period';

    const radioPeriodLabel = document.createElement('label');
    radioPeriodLabel.textContent = '期間設定';
    radioPeriodLabel.style.marginLeft = '4px';
    radioPeriodContainer.appendChild(radioPeriod);
    radioPeriodContainer.appendChild(radioPeriodLabel);

    // 期間設定の日付入力フィールド
    const periodInputsContainer = document.createElement('div');
    periodInputsContainer.style.display = dateRange.type === 'period' ? 'flex' : 'none';
    periodInputsContainer.style.flexDirection = 'column';
    periodInputsContainer.style.gap = '4px';
    periodInputsContainer.style.marginLeft = '20px';
    periodInputsContainer.className = 'routine-period-inputs';
    periodInputsContainer.dataset.index = index;

    const startDateContainer = document.createElement('div');
    startDateContainer.style.display = 'flex';
    startDateContainer.style.alignItems = 'center';
    startDateContainer.style.gap = '8px';

    const startDateLabel = document.createElement('label');
    startDateLabel.textContent = '開始日:';
    startDateLabel.style.minWidth = '60px';
    const startDateInput = document.createElement('input');
    startDateInput.type = 'date';
    startDateInput.className = 'routine-daterange-start';
    startDateInput.value = dateRange.startDate || '';
    startDateInput.dataset.index = index;
    startDateInput.style.flex = '1';

    startDateContainer.appendChild(startDateLabel);
    startDateContainer.appendChild(startDateInput);

    const endDateContainer = document.createElement('div');
    endDateContainer.style.display = 'flex';
    endDateContainer.style.alignItems = 'center';
    endDateContainer.style.gap = '8px';

    const endDateLabel = document.createElement('label');
    endDateLabel.textContent = '終了日:';
    endDateLabel.style.minWidth = '60px';
    const endDateInput = document.createElement('input');
    endDateInput.type = 'date';
    endDateInput.className = 'routine-daterange-end';
    endDateInput.value = dateRange.endDate || '';
    endDateInput.dataset.index = index;
    endDateInput.style.flex = '1';

    endDateContainer.appendChild(endDateLabel);
    endDateContainer.appendChild(endDateInput);

    periodInputsContainer.appendChild(startDateContainer);
    periodInputsContainer.appendChild(endDateContainer);

    // ラジオボタン変更時の処理
    radioNone.addEventListener('change', () => {
      if (radioNone.checked) {
        periodInputsContainer.style.display = 'none';
      }
    });
    radioPeriod.addEventListener('change', () => {
      if (radioPeriod.checked) {
        periodInputsContainer.style.display = 'flex';
      }
    });

    dateRangeContainer.appendChild(radioNoneContainer);
    dateRangeContainer.appendChild(radioPeriodContainer);
    dateRangeContainer.appendChild(periodInputsContainer);

    detailPanel.appendChild(startTimeContainer);
    detailPanel.appendChild(endTimeContainer);
    detailPanel.appendChild(urgentContainer);
    detailPanel.appendChild(priorityContainer);
    detailPanel.appendChild(dateRangeLabel);
    detailPanel.appendChild(dateRangeContainer);

    // アイテムに追加
    item.appendChild(nameInput);
    item.appendChild(durationInput);
    item.appendChild(detailBtn);
    item.appendChild(deleteBtn);
    item.appendChild(detailPanel);
    container.appendChild(item);
  });
  } catch (e) {
    console.error('Error in renderRoutinesList:', e);
    alert('ルーティンリストの表示エラー: ' + e.message);
  }
}

// ルーティンを削除
function deleteRoutine(index) {
  const routines = getRoutines();
  routines.splice(index, 1);
  saveRoutines(routines);
```

### modals-04-auth-user.js

```javascript
  renderRoutinesList();
}

// ルーティンを追加
function addRoutine() {
  // 現在の入力内容を保存してから新しいルーティンを追加
  const nameInputs = document.querySelectorAll('.routine-name-input');
  const durationInputs = document.querySelectorAll('.routine-duration-input');
  const timeInputs = document.querySelectorAll('.routine-time-input');
  const routines = [];

  nameInputs.forEach((nameInput, index) => {
    const name = nameInput.value.trim();
    const existingRoutines = getRoutines();

    // 開始時刻と終了時刻を取得
    let startTime = '';
    let endTime = '';
    timeInputs.forEach(input => {
      const inputIndex = parseInt(input.dataset.index);
      if (inputIndex === index) {
        if (input.dataset.field === 'startTime') {
          startTime = input.value || '';
        } else if (input.dataset.field === 'endTime') {
          endTime = input.value || '';
        }
      }
    });

    // 緊急フラグと優先順位を取得
    const urgentCheckbox = document.querySelector(`.routine-urgent-input[data-index="${index}"]`);
    const prioritySelect = document.querySelector(`.routine-priority-input[data-index="${index}"]`);
    const urgent = urgentCheckbox ? urgentCheckbox.checked : false;
    const priority = prioritySelect ? prioritySelect.value : '';

    // 期間設定を取得
    const dateRangeRadios = document.querySelectorAll(`.routine-daterange-radio[data-index="${index}"]`);
    let dateRangeType = 'none';
    dateRangeRadios.forEach(radio => {
      if (radio.checked) {
        dateRangeType = radio.value;
      }
    });

    const startDateInput = document.querySelector(`.routine-daterange-start[data-index="${index}"]`);
    const endDateInput = document.querySelector(`.routine-daterange-end[data-index="${index}"]`);
    const dateRange = {
      type: dateRangeType,
      startDate: dateRangeType === 'period' && startDateInput ? startDateInput.value : null,
      endDate: dateRangeType === 'period' && endDateInput ? endDateInput.value : null
    };

    const routine = {
      id: existingRoutines[index]?.id || generateUUID(),
      name: name,
      duration: parseInt(durationInputs[index].value),
      startTime: startTime,
      endTime: endTime,
      urgent: urgent,
      priority: priority,
      dateRange: dateRange
    };
    routines.push(routine);
  });

  // 新しい空のルーティンを追加
  const newRoutine = {
    id: generateUUID(),
    name: '',
    duration: 30,
    startTime: '',
    endTime: '',
    urgent: false,
    priority: '',
    dateRange: { type: 'none', startDate: null, endDate: null }
  };
  routines.push(newRoutine);

  saveRoutines(routines);
  renderRoutinesList();

  // 新規ルーティンの名前入力にフォーカス
  setTimeout(() => {
    const inputs = document.querySelectorAll('.routine-name-input');
    if (inputs.length > 0) {
      inputs[inputs.length - 1].focus();
    }
  }, 0);
}

// 設定モーダルを閉じる
function closeSettingsModal() {
  const modal = document.getElementById('settings-modal');

  // 閉じるアニメーションを開始
  modal.classList.add('hiding');

  // アニメーション終了後に実際に閉じる
  setTimeout(() => {
    modal.classList.remove('show', 'hiding');
  }, 200); // 200ms（アニメーション時間）
}

// 設定を保存
function saveSettings() {
  const routines = [];
  const nameInputs = document.querySelectorAll('.routine-name-input');
  const durationInputs = document.querySelectorAll('.routine-duration-input');
  const timeInputs = document.querySelectorAll('.routine-time-input');

  nameInputs.forEach((nameInput, index) => {
    const name = nameInput.value.trim();
    if (name) {
      // 開始時刻と終了時刻を取得
      let startTime = '';
      let endTime = '';
      timeInputs.forEach(input => {
        const inputIndex = parseInt(input.dataset.index);
        if (inputIndex === index) {
          if (input.dataset.field === 'startTime') {
            startTime = input.value || '';
          } else if (input.dataset.field === 'endTime') {
            endTime = input.value || '';
          }
        }
      });

      // 緊急フラグと優先順位を取得
      const urgentCheckbox = document.querySelector(`.routine-urgent-input[data-index="${index}"]`);
      const prioritySelect = document.querySelector(`.routine-priority-input[data-index="${index}"]`);
      const urgent = urgentCheckbox ? urgentCheckbox.checked : false;
      const priority = prioritySelect ? prioritySelect.value : '';

      // 期間設定を取得
      const dateRangeRadios = document.querySelectorAll(`.routine-daterange-radio[data-index="${index}"]`);
      let dateRangeType = 'none';
      dateRangeRadios.forEach(radio => {
        if (radio.checked) {
          dateRangeType = radio.value;
        }
      });

      const startDateInput = document.querySelector(`.routine-daterange-start[data-index="${index}"]`);
      const endDateInput = document.querySelector(`.routine-daterange-end[data-index="${index}"]`);
      const dateRange = {
        type: dateRangeType,
        startDate: dateRangeType === 'period' && startDateInput ? startDateInput.value : null,
        endDate: dateRangeType === 'period' && endDateInput ? endDateInput.value : null
      };

      const routine = {
        id: getRoutines()[index]?.id || generateUUID(),
        name: name,
        duration: parseInt(durationInputs[index].value),
        startTime: startTime,
        endTime: endTime,
        urgent: urgent,
        priority: priority,
        dateRange: dateRange
      };
      routines.push(routine);
    }
  });

  saveRoutines(routines);

  // ゲージ時間表記パターンを保存
  const gaugePatternSelect = document.getElementById('gauge-time-pattern');
  if (gaugePatternSelect && typeof setGaugeTimePattern === 'function') {
    const selectedPattern = parseInt(gaugePatternSelect.value);
    setGaugeTimePattern(selectedPattern);
  }

  // 既存タスクへの反映と新規タスク作成
  routines.forEach(routine => {
    // 既存タスクを更新
    if (typeof updateRoutineTasks === 'function') {
      updateRoutineTasks(routine);
    }
  });

  // 新規ルーティンタスクを作成
  createRoutineTasks();

  closeSettingsModal();
  renderTasks();
}

// ========================================
// ログインモーダル
// ========================================

// ログインモーダルを開く
function openLoginModal() {
  const modal = document.getElementById('login-modal');
  if (modal) {
    // 現在のユーザー情報を更新
    updateCurrentUserInfo();
    modal.classList.add('show');
  }
}

// ログインモーダルを閉じる
function closeLoginModal() {
  const modal = document.getElementById('login-modal');
  if (modal) {
    // 閉じるアニメーションを開始
    modal.classList.add('hiding');

    // アニメーション終了後に実際に閉じる
    setTimeout(() => {
      modal.classList.remove('show', 'hiding');
    }, 200); // 200ms（アニメーション時間）
  }
}

// 現在のユーザー情報を更新
function updateCurrentUserInfo() {
  const userInfoElement = document.getElementById('current-user-info');
  if (!userInfoElement) return;

  if (typeof FirestoreBridge !== 'undefined') {
    const userId = FirestoreBridge.getUserId();
    if (userId && userId !== 'anonymous') {
      userInfoElement.textContent = 'ユーザーID: ' + userId.substring(0, 8) + '...';
    } else {
      userInfoElement.textContent = '匿名ユーザー';
    }
  } else {
    userInfoElement.textContent = '匿名ユーザー（Web版）';
  }
}
```

### overload.js

```javascript
// ========================================
// 時間オーバー警告機能
// ========================================

/**
 * 時間オーバー警告モーダルを開く
 * @param {number} overloadMinutes - オーバーしている分数
 * @param {Array} tasks - 今日のタスク一覧
 */
function openTimeOverloadModal(overloadMinutes, tasks) {
  const modal = document.getElementById('time-overload-modal');
  if (!modal) return;

  // オーバー時間を表示
  const overloadAmountEl = document.getElementById('overload-amount');
  const hours = Math.floor(Math.abs(overloadMinutes) / 60);
  const mins = Math.abs(overloadMinutes) % 60;

  if (hours > 0) {
    overloadAmountEl.textContent = `${hours}時間${mins > 0 ? mins + '分' : ''}`;
  } else {
    overloadAmountEl.textContent = `${mins}分`;
  }

  // タスクリストを生成
  renderOverloadTasks(tasks);

  // モーダルを表示
  modal.style.display = 'flex';
  modal.classList.add('show');
}

/**
 * 時間オーバー警告モーダルを閉じる
 */
function closeTimeOverloadModal() {
  const modal = document.getElementById('time-overload-modal');
  if (!modal) return;

  modal.style.display = 'none';
  modal.classList.remove('show');
}

/**
 * 時間オーバーのタスクリストを描画
 * @param {Array} tasks - 今日のタスク一覧
 */
function renderOverloadTasks(tasks) {
  const container = document.getElementById('overload-tasks-list');
  if (!container) return;

  container.innerHTML = '';

  // タスクを時間が長い順にソート
  const sortedTasks = [...tasks].sort((a, b) => {
    const getDuration = (task) => {
      if (task.startTime && task.endTime) {
        const [startHour, startMin] = task.startTime.split(':').map(Number);
        const [endHour, endMin] = task.endTime.split(':').map(Number);
        const startMinutes = startHour * 60 + startMin;
        let endMinutes = endHour * 60 + endMin;
        if (endMinutes < startMinutes) endMinutes += 24 * 60;
        return endMinutes - startMinutes;
      }
      return task.duration || 0;
    };
    return getDuration(b) - getDuration(a);
  });

  sortedTasks.forEach(task => {
    const taskEl = document.createElement('div');
    taskEl.className = 'overload-task-item';

    // タスクの時間を計算
    let timeText = '';
    if (task.startTime && task.endTime) {
      timeText = `${task.startTime} ~ ${task.endTime}`;
    } else if (task.duration) {
      const hours = Math.floor(task.duration / 60);
      const mins = task.duration % 60;
      timeText = hours > 0 ? `${hours}時間${mins}分` : `${mins}分`;
    }

    taskEl.innerHTML = `
      <div class="overload-task-info">
        <div class="overload-task-title">${escapeHtml(task.title)}</div>
        <div class="overload-task-time">${timeText}</div>
      </div>
      <div class="overload-task-actions">
        <button class="btn-edit-task" data-task-id="${task.id}" title="編集">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
          </svg>
        </button>
        <button class="btn-postpone-task" data-task-id="${task.id}" title="明日に延期">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="16" y1="2" x2="16" y2="6"></line>
            <line x1="8" y1="2" x2="8" y2="6"></line>
            <line x1="3" y1="10" x2="21" y2="10"></line>
          </svg>
        </button>
        <button class="btn-delete-task" data-task-id="${task.id}" title="削除">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
          </svg>
        </button>
      </div>
    `;

    container.appendChild(taskEl);
  });

  // イベントリスナーを追加
  attachOverloadTaskEvents();
}

/**
 * タスクアクションのイベントリスナーを追加
 */
function attachOverloadTaskEvents() {
  // 編集ボタン
  document.querySelectorAll('.btn-edit-task').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const taskId = btn.dataset.taskId;
      closeTimeOverloadModal();
      openEditModal(taskId);
    });
  });

  // 延期ボタン
  document.querySelectorAll('.btn-postpone-task').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const taskId = btn.dataset.taskId;
      postponeTaskToTomorrow(taskId);
    });
  });

  // 削除ボタン
  document.querySelectorAll('.btn-delete-task').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const taskId = btn.dataset.taskId;
      deleteTaskFromOverload(taskId);
    });
  });
}

/**
 * タスクを明日に延期
 * @param {string} taskId - タスクID
 */
function postponeTaskToTomorrow(taskId) {
  const tasks = getTasks();
  const task = tasks.find(t => t.id === taskId);
  if (!task) return;

  // 明日の日付を設定
  const tomorrow = new Date();
  tomorrow.setDate(tomorrow.getDate() + 1);
  tomorrow.setHours(0, 0, 0, 0);
  task.dueDate = tomorrow.toISOString();
  task.updatedAt = new Date().toISOString();

  saveTasks(tasks);
  renderTasks();
  updateTimeGauge();

  // リストを再描画
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayTasks = tasks.filter(t => {
    if (t.isCompleted || t.isRoutine) return false;
    if (t.dueDate) {
      const dueDate = new Date(t.dueDate);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      return dueDate >= today && dueDate < tomorrow;
    }
    return false;
  });

  if (todayTasks.length > 0) {
    renderOverloadTasks(todayTasks);
  } else {
    closeTimeOverloadModal();
  }
}

/**
 * タスクを削除（ゴミ箱に移動）
 * @param {string} taskId - タスクID
 */
function deleteTaskFromOverload(taskId) {
  const tasks = getTasks();
  const task = tasks.find(t => t.id === taskId);
  if (!task) return;

  task.isDeleted = true;
  task.deletedAt = new Date().toISOString();
  task.updatedAt = new Date().toISOString();

  saveTasks(tasks);
  renderTasks();
  updateTimeGauge();

  // リストを再描画
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayTasks = tasks.filter(t => {
    if (t.isCompleted || t.isRoutine || t.isDeleted) return false;
    if (t.dueDate) {
      const dueDate = new Date(t.dueDate);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      return dueDate >= today && dueDate < tomorrow;
    }
    return false;
  });

  if (todayTasks.length > 0) {
    renderOverloadTasks(todayTasks);
  } else {
    closeTimeOverloadModal();
  }
}

/**
 * HTMLエスケープ
 */
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}
```

### performance.js

```javascript
// ========================================
// フェーズ7: パフォーマンス最適化
// ========================================
// 起動速度、メモリ使用量、ネットワーク通信の最適化

/**
 * 7.1: 起動速度の最適化
 * - Splash画面の改善
 * - 遅延読み込みの実装
 */

// パフォーマンスメトリクス追跡
const performanceMetrics = {
  startTime: performance.now(),
  loadingPhases: {},
  memorySnapshots: []
};

/**
 * 初期化処理の非同期実行
 * 7.1.1: 起動時の初期化処理を非同期化
 */
async function initializeAsync() {
  const initStart = performance.now();

  try {
    // Phase 1: 同期的な最小初期化（UIの最初の描画）
    initializeSplashScreen();
    recordPhase('splash', performance.now() - initStart);

    // Phase 2: 非同期初期化（バックグラウンド）
    await Promise.all([
      loadTasksAsyncWithPriority(),
      initializeEventHandlersLazy(),
      preloadCommonResources()
    ]);

    recordPhase('async_init', performance.now() - initStart);

    // Phase 3: オプショナルリソース（遅延読み込み）
    scheduleDeferredInitialization();

    hideSplashScreen();
    recordPhase('total_init', performance.now() - initStart);

    console.log('✓ 初期化完了:', performanceMetrics.loadingPhases);

  } catch (error) {
    console.error('初期化エラー:', error);
    hideSplashScreen();
  }
}

/**
 * フェーズ記録
 */
function recordPhase(phaseName, duration) {
  performanceMetrics.loadingPhases[phaseName] = Math.round(duration);
}

/**
 * Splash画面の表示
 */
function initializeSplashScreen() {
  const splash = document.getElementById('splash-screen');
  if (splash) {
    splash.style.display = 'flex';
    splash.style.opacity = '1';
  }
}

/**
 * Splash画面の非表示
 */
function hideSplashScreen() {
  const splash = document.getElementById('splash-screen');
  if (splash) {
    splash.style.opacity = '0';
    setTimeout(() => {
      splash.style.display = 'none';
    }, 300);
  }
}

/**
 * プログレスインジケーターの更新
 */
function updateSplashProgress(percentage) {
  const progressBar = document.querySelector('.splash-progress');
  if (progressBar) {
    progressBar.style.width = percentage + '%';
  }
}

/**
 * 優先度付きでタスクを非同期読み込み
 * - 表示予定のタスク（今日、明日）を優先
 * - その他は遅延読み込み
 */
async function loadTasksAsyncWithPriority() {
  return new Promise((resolve) => {
    setTimeout(() => {
      try {
        // 優先度高: 表示予定のタスク
        const tasks = loadFromStorage(STORAGE_KEYS.TASKS, []);
        const today = formatDateISO(new Date());
        const tomorrow = formatDateISO(new Date(Date.now() + 86400000));

        // キャッシュに分類して保存
        const priorityCache = {
          today: tasks.filter(t => t.dueDate === today),
          tomorrow: tasks.filter(t => t.dueDate === tomorrow),
          other: tasks.filter(t => !t.dueDate || (t.dueDate !== today && t.dueDate !== tomorrow))
        };

        localStorage.setItem('_priority_cache', JSON.stringify(priorityCache));
        updateSplashProgress(60);
        resolve();
      } catch (error) {
        console.error('タスク読み込みエラー:', error);
        resolve();
      }
    }, 0);
  });
}

/**
 * イベントハンドラーの遅延初期化
 */
async function initializeEventHandlersLazy() {
  return new Promise((resolve) => {
    setTimeout(() => {
      try {
        // 重要なイベントのみ即座に登録
        if (document.getElementById('quick-add-input')) {
          document.getElementById('quick-add-input').addEventListener('keypress', handleQuickAddEnter);
        }

        updateSplashProgress(75);
        resolve();
      } catch (error) {
        console.error('イベントハンドラー初期化エラー:', error);
        resolve();
      }
    }, 100);
  });
}

/**
 * 共通リソースの事前読み込み
 */
async function preloadCommonResources() {
  return new Promise((resolve) => {
    setTimeout(() => {
      try {
        // SVGアイコン、CSS、フォントをプリロード
        const resourcesPreload = [
          'js/templates.js',
          'js/calendar.js'
        ];

        resourcesPreload.forEach(resource => {
          const link = document.createElement('link');
          link.rel = 'modulepreload';
          link.href = resource;
          document.head.appendChild(link);
        });

        updateSplashProgress(85);
        resolve();
      } catch (error) {
        resolve(); // エラーは無視して続行
      }
    }, 150);
  });
}

/**
 * 遅延初期化のスケジュール
 * requestIdleCallback()で、ブラウザがアイドル状態の時に実行
 */
function scheduleDeferredInitialization() {
  if ('requestIdleCallback' in window) {
    requestIdleCallback(() => {
      loadDeferredResources();
    }, { timeout: 2000 });
  } else {
    setTimeout(loadDeferredResources, 2000);
  }
}

/**
 * 遅延読み込みリソース
 * - Analytics, Share機能, Calendar など
 */
async function loadDeferredResources() {
  const deferredScripts = [
    'js/analytics.js',
    'js/share.js',
    'js/calendar.js'
  ];

  for (const script of deferredScripts) {
    try {
      const moduleScript = document.createElement('script');
      moduleScript.src = script + '?v=49';
      moduleScript.async = true;
      document.head.appendChild(moduleScript);
      await new Promise(resolve => {
        moduleScript.onload = resolve;
        moduleScript.onerror = resolve;
      });
    } catch (error) {
      console.warn(`遅延リソース読み込み失敗: ${script}`, error);
    }
  }
}

/**
 * 7.2: メモリ使用量の最適化
 * - WebViewのメモリ管理
 * - データ処理の効率化
 */

/**
 * WebViewメモリキャッシュの最適化
 * 7.2.1: キャッシュの定期的なクリア
 */
class MemoryManager {
  constructor() {
    this.cacheSize = 0;
    this.maxCacheSize = 50 * 1024 * 1024; // 50MB
    this.lastCleanup = Date.now();
    this.cleanupInterval = 5 * 60 * 1000; // 5分
  }

  /**
   * メモリ使用量をチェック
   */
  checkMemory() {
    if (performance.memory) {
      const usedJSHeapSize = performance.memory.usedJSHeapSize;
      const jsHeapSizeLimit = performance.memory.jsHeapSizeLimit;
      const percentUsed = (usedJSHeapSize / jsHeapSizeLimit) * 100;

      // メモリ使用率が85%を超えたらクリア
      if (percentUsed > 85) {
        this.clearUnusedCache();
      }

      return {
        used: Math.round(usedJSHeapSize / 1024 / 1024),
        limit: Math.round(jsHeapSizeLimit / 1024 / 1024),
        percent: Math.round(percentUsed)
      };
    }
    return null;
  }

  /**
   * 不要なキャッシュをクリア
   */
  clearUnusedCache() {
    try {
      // グローバルキャッシュをクリア
      if (window.dataCache) {
        // 重要でないデータのみ削除
        ['_priority_cache', '_temp_cache'].forEach(key => {
          delete window.dataCache[key];
        });
      }

      // DOM内の隠れた要素をクリア
      const hiddenElements = document.querySelectorAll('[style*="display: none"]');
      hiddenElements.forEach(el => {
        if (el.innerHTML && el.innerHTML.length > 10000) {
          el.innerHTML = ''; // 大きなDOMはクリア
        }
      });

      console.log('✓ キャッシュクリア完了');
    } catch (error) {
      console.error('キャッシュクリアエラー:', error);
    }
  }

  /**
   * 定期的なメモリ監視を開始
   */
  startMonitoring() {
    setInterval(() => {
      if (Date.now() - this.lastCleanup > this.cleanupInterval) {
        this.checkMemory();
        this.lastCleanup = Date.now();
      }
    }, 30000); // 30秒ごとにチェック
  }
}

// メモリマネージャー初期化
const memoryManager = new MemoryManager();

/**
 * 7.2.2: 大量タスク時のパフォーマンス改善
 * - 仮想スクロール実装
 * - 不要なDOM操作の削減
 */

class VirtualScroller {
  constructor(containerId, itemHeight = 60) {
    this.container = document.getElementById(containerId);
    this.itemHeight = itemHeight;
    this.items = [];
    this.visibleRange = { start: 0, end: 0 };
    this.scrollTop = 0;
    this.viewport = null;
    this.virtualDOM = null;
    this.setupEventListener();
  }

  /**
   * アイテムを設定
   */
  setItems(items) {
    this.items = items;
    this.render();
  }

  /**
   * スクロールイベントリスナー設定
   */
  setupEventListener() {
    if (this.container) {
      this.container.addEventListener('scroll', () => this.onScroll());
    }
  }

  /**
   * スクロール時の処理
   */
  onScroll() {
    if (!this.container) return;

    this.scrollTop = this.container.scrollTop;
    const containerHeight = this.container.clientHeight;

    // 表示範囲の計算
    this.visibleRange.start = Math.floor(this.scrollTop / this.itemHeight);
    this.visibleRange.end = Math.ceil((this.scrollTop + containerHeight) / this.itemHeight);

    // バッファ追加（スムーズなスクロール用）
    this.visibleRange.start = Math.max(0, this.visibleRange.start - 5);
    this.visibleRange.end = Math.min(this.items.length, this.visibleRange.end + 5);

    this.render();
  }

  /**
   * 表示範囲のアイテムのみレンダリング
   */
  render() {
    if (!this.container) return;

    const fragment = document.createDocumentFragment();

    for (let i = this.visibleRange.start; i < this.visibleRange.end; i++) {
      const item = this.items[i];
      if (item) {
        const element = this.createItemElement(item, i);
        fragment.appendChild(element);
      }
    }

    // 全要素をクリアして新しい要素をレンダリング
    this.container.innerHTML = '';
    this.container.appendChild(fragment);
  }

  /**
   * アイテムの要素を作成
   */
  createItemElement(item, index) {
    const div = document.createElement('div');
    div.style.height = this.itemHeight + 'px';
    div.style.position = 'absolute';
    div.style.top = (index * this.itemHeight) + 'px';
    div.innerHTML = item.html || '';
    return div;
  }
}

/**
 * 7.3: ネットワーク通信の最適化
 * - Firestoreクエリの最適化
 * - オフライン対応の完全化
 */

/**
 * 7.3.1: Firestoreクエリの最適化
 * - 必要最小限のデータ取得
 * - インデックスの適切な設定
 * - バッチ処理の活用
 */
class FirestoreOptimizer {
  constructor() {
    this.queryCache = new Map();
    this.cacheExpiry = 5 * 60 * 1000; // 5分
    this.batchQueue = [];
    this.batchSize = 25;
    this.batchDelay = 500; // ms
  }

  /**
   * クエリ結果をキャッシュ
   */
  cacheQuery(queryKey, data) {
    this.queryCache.set(queryKey, {
      data,
      timestamp: Date.now()
    });
  }

  /**
   * キャッシュからクエリ結果を取得
   */
  getCachedQuery(queryKey) {
    const cached = this.queryCache.get(queryKey);
    if (cached && Date.now() - cached.timestamp < this.cacheExpiry) {
      return cached.data;
    }
    this.queryCache.delete(queryKey);
    return null;
  }

  /**
   * 必要最小限のフィールドのみ取得
   */
  optimizeFields(data, fieldsNeeded = ['id', 'title', 'dueDate', 'isCompleted']) {
    if (Array.isArray(data)) {
      return data.map(item => {
        const optimized = {};
        fieldsNeeded.forEach(field => {
          if (field in item) optimized[field] = item[field];
        });
        return optimized;
      });
    }
    return data;
  }

  /**
   * バッチ処理のキュー
   */
  queueBatchOperation(operation) {
    this.batchQueue.push(operation);
    if (this.batchQueue.length === this.batchSize) {
      this.executeBatch();
    } else if (this.batchQueue.length === 1) {
      setTimeout(() => this.executeBatch(), this.batchDelay);
    }
  }

  /**
   * バッチを実行
   */
  executeBatch() {
    if (this.batchQueue.length === 0) return;

    const batch = this.batchQueue.splice(0, this.batchSize);
    console.log(`バッチ実行: ${batch.length}件の操作`);

    // FirestoreBridgeでバッチ処理
    if (typeof FirestoreBridge !== 'undefined') {
      FirestoreBridge.executeBatch(JSON.stringify(batch));
    }
  }
}

const firestoreOptimizer = new FirestoreOptimizer();

/**
 * 7.3.2: オフライン動作の完全対応
 * - オフライン時の完全機能提供
 * - 自動同期メカニズム
 * - 競合解決ロジック
 */

class OfflineManager {
  constructor() {
    this.isOnline = navigator.onLine;
    this.pendingChanges = [];
    this.syncInProgress = false;
    this.lastSyncTime = null;
    this.setupNetworkListener();
  }

  /**
   * ネットワーク状態リスナー
   */
  setupNetworkListener() {
    window.addEventListener('online', () => this.handleOnline());
    window.addEventListener('offline', () => this.handleOffline());
  }

  /**
   * オンライン状態に戻ったときの処理
   */
  handleOnline() {
    this.isOnline = true;
    // ユーザーが不要なので通知を表示しない
    // console.log('✓ オンラインに戻りました');

    // UI更新: オフラインバナーを非表示（既に表示されている場合のみ）
    const offlineBanner = document.querySelector('.offline-banner');
    if (offlineBanner && offlineBanner.style.display === 'block') {
      offlineBanner.style.display = 'none';
    }

    // 自動同期を開始
    if (this.pendingChanges.length > 0) {
      this.syncPendingChanges();
    }
  }

  /**
   * オフライン状態になったときの処理
   */
  handleOffline() {
    this.isOnline = false;
    console.log('⚠ オフライン状態です');

    // UI更新: オフラインバナーを表示
    const offlineBanner = document.querySelector('.offline-banner');
    if (offlineBanner) {
      offlineBanner.style.display = 'block';
    }
  }

  /**
   * 変更をローカルキューに追加
   */
  queueChange(change) {
    this.pendingChanges.push({
      ...change,
      timestamp: Date.now(),
      clientId: this.getClientId()
    });

    // ローカルストレージに保存
    this.savePendingChanges();
  }

  /**
   * ペンディング変更を保存
   */
  savePendingChanges() {
    try {
      localStorage.setItem('_pending_changes', JSON.stringify(this.pendingChanges));
    } catch (error) {
      console.error('ペンディング変更の保存失敗:', error);
    }
  }

  /**
   * ペンディング変更を読み込み
   */
  loadPendingChanges() {
    try {
      const data = localStorage.getItem('_pending_changes');
      this.pendingChanges = data ? JSON.parse(data) : [];
    } catch (error) {
      console.error('ペンディング変更の読み込み失敗:', error);
      this.pendingChanges = [];
    }
  }

  /**
   * ペンディング変更を同期
   */
  async syncPendingChanges() {
    if (this.syncInProgress || !this.isOnline || this.pendingChanges.length === 0) {
      return;
    }

    this.syncInProgress = true;

    try {
      this.loadPendingChanges();

      for (const change of this.pendingChanges) {
        await this.syncChange(change);
      }

      // 同期完了後、ペンディングキューをクリア
      this.pendingChanges = [];
      this.savePendingChanges();
      this.lastSyncTime = Date.now();

      console.log('✓ 同期完了');

    } catch (error) {
      console.error('同期エラー:', error);
    } finally {
      this.syncInProgress = false;
    }
  }

  /**
   * 個別の変更を同期
   */
  async syncChange(change) {
    try {
      if (typeof FirestoreBridge !== 'undefined') {
        FirestoreBridge.syncChange(JSON.stringify(change));
      }
    } catch (error) {
      console.error('変更の同期失敗:', error);
      throw error;
    }
  }

  /**
   * クライアントIDの取得/生成
   */
  getClientId() {
    let clientId = localStorage.getItem('_client_id');
    if (!clientId) {
      clientId = generateUUID();
      localStorage.setItem('_client_id', clientId);
    }
    return clientId;
  }

  /**
   * 競合解決: タイムスタンプベースの最後の書き込み勝ち
   */
  resolveConflict(localChange, remoteChange) {
    if (localChange.timestamp > remoteChange.timestamp) {
      return localChange;
    }
    return remoteChange;
  }
}

const offlineManager = new OfflineManager();

/**
 * 初期化時に呼び出す関数
 */
function initializePerformanceOptimization() {
  // メモリ監視を開始
  memoryManager.startMonitoring();

  // オフラインマネージャーの初期化
  offlineManager.loadPendingChanges();

  // Firestore最適化の初期化
  firestoreOptimizer.cacheQuery('initial', loadFromStorage(STORAGE_KEYS.TASKS, []));

  console.log('✓ パフォーマンス最適化を初期化しました');
}

/**
 * ブラウザアイドル時の最適化タスク
 */
if ('requestIdleCallback' in window) {
  requestIdleCallback(() => {
    // Firestoreキャッシュをクリア（古いデータ削除）
    const now = Date.now();
    firestoreOptimizer.queryCache.forEach((value, key) => {
      if (now - value.timestamp > 10 * 60 * 1000) {
        firestoreOptimizer.queryCache.delete(key);
      }
    });
  }, { timeout: 5000 });
}

// パフォーマンスメトリクスの記録
window.addEventListener('load', () => {
  performanceMetrics.loadTime = performance.now() - performanceMetrics.startTime;
  console.log(`📊 ページロード時間: ${Math.round(performanceMetrics.loadTime)}ms`);
});
```

### render.js

```javascript
// ========================================
// レンダリング関数
// ========================================

// グローバル変数（インライン追加中のタスク）
let addingSubtaskForTaskId = null;

// 複数選択モード用グローバル変数
let isSelectionMode = false;
let selectedTaskIds = new Set();

// 日付ごとにタスクをグループ化
function groupTasksByDate(tasks) {
  const groups = {};
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);

  tasks.forEach(task => {
    let dateKey, label;

    if (task.dueDate) {
      const dueDate = new Date(task.dueDate);
      dueDate.setHours(0, 0, 0, 0);

      // 今日、明日、昨日、それ以外で判定
      if (dueDate.getTime() === today.getTime()) {
        dateKey = 'today';
        label = '今日 ' + formatDate(task.dueDate);
      } else if (dueDate.getTime() === tomorrow.getTime()) {
        dateKey = 'tomorrow';
        label = '明日 ' + formatDate(task.dueDate);
      } else if (dueDate.getTime() === yesterday.getTime()) {
        dateKey = 'yesterday';
        label = '昨日 ' + formatDate(task.dueDate);
      } else if (dueDate < today) {
        dateKey = 'overdue_' + dueDate.getTime();
        label = formatDate(task.dueDate) + ' (期限切れ)';
      } else {
        dateKey = 'future_' + dueDate.getTime();
        label = formatDate(task.dueDate);
      }
    } else {
      dateKey = 'no_date';
      label = '期限なし';
    }

    if (!groups[dateKey]) {
      // dateObj はそのグループの日付（午前0時）を保持する。期限なしは null。
      let dateObj = null;
      if (task.dueDate) {
        dateObj = new Date(task.dueDate);
        dateObj.setHours(0, 0, 0, 0);
      }
      groups[dateKey] = { date: dateKey, label, tasks: [], sortOrder: getSortOrder(dateKey, task.dueDate), dateObj };
    }
    groups[dateKey].tasks.push(task);
  });

  // ソート順序: 期限切れ → 昨日 → 今日 → 明日 → 未来 → 期限なし
  return Object.values(groups).sort((a, b) => a.sortOrder - b.sortOrder);
}

function getSortOrder(dateKey, dueDate) {
  if (dateKey.startsWith('overdue_')) return -1000 + new Date(dueDate).getTime();
  if (dateKey === 'yesterday') return -2;
  if (dateKey === 'today') return -1;
  if (dateKey === 'tomorrow') return 0;
  if (dateKey.startsWith('future_')) return 1000 + new Date(dueDate).getTime();
  return 10000; // 期限なし
}

function formatDate(dateStr) {
  if (!dateStr) return '';
  const date = new Date(dateStr);
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const weekdays = ['日', '月', '火', '水', '木', '金', '土'];
  const weekday = weekdays[date.getDay()];
  return `${month}月${day}日 (${weekday})`;
}

// Date オブジェクトを YYYY-MM-DD 形式の文字列に変換（null 安全）
function formatDateISO(dateObj) {
  if (!dateObj) return '';
  const y = dateObj.getFullYear();
  const m = String(dateObj.getMonth() + 1).padStart(2, '0');
  const d = String(dateObj.getDate()).padStart(2, '0');
  return `${y}-${m}-${d}`;
}

// グローバルフィルター状態
let currentFilter = null; // 'urgent' | 'high-priority' | null

// グローバル検索キーワード（ハイライト表示用）
let currentSearchKeyword = '';

// ========================================
// UI バージョン判定ヘルパー
// ========================================
function isNewUIEnabled() {
  const version = localStorage.getItem('ui-version') || 'new';
  return version === 'new';
}

// ========================================
// 新タスクカード レンダリング
// ========================================

/**
 * 新タスクカード用メタ情報を作成
 */
function createNewTaskMeta(task) {
  const meta = document.createElement('div');
  meta.className = 'new-task-meta';

  // 所要時間バッジ
  if (task.duration) {
    const hours = Math.floor(task.duration / 60);
    const minutes = task.duration % 60;
    let durationText = '';
    if (hours > 0) {
      durationText = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
    } else {
      durationText = `${minutes}m`;
    }

    const durationBadge = document.createElement('span');
    durationBadge.className = 'new-duration-badge';
    durationBadge.textContent = `⏰ ${durationText}`;
    meta.appendChild(durationBadge);
  }

  // 緊急バッジ
  if (task.urgent) {
    const urgentBadge = document.createElement('span');
    urgentBadge.className = 'new-urgent-badge';
    urgentBadge.textContent = '🚨 緊急';
    meta.appendChild(urgentBadge);
  }

  return meta;
}

/**
 * 新タスクカード構造を作成
 */
function createNewTaskCard(task, level = 0) {
  const card = document.createElement('div');
  card.className = 'new-task-card' + (task.isCompleted ? ' completed' : '');

  // 優先度に基づくクラスを追加
  if (task.urgent) {
    card.classList.add('urgent');
  } else if (task.priority) {
    card.classList.add(`priority-${task.priority}`);
  }

  // データ属性
  card.dataset.id = task.id;
  card.dataset.taskId = task.id;
  card.dataset.level = level;

  // チェックボックス
  const checkbox = document.createElement('input');
  checkbox.type = 'checkbox';
  checkbox.className = 'new-task-checkbox';
  checkbox.checked = task.isCompleted;
  checkbox.addEventListener('click', (e) => {
    e.stopPropagation();
    if (isSelectionMode) {
      toggleTaskSelection(task.id);
    } else {
      toggleTaskCompletion(task.id);
    }
  });
  card.appendChild(checkbox);

  // ボディ（タイトル + メタ）
  const body = document.createElement('div');
  body.className = 'new-task-body';

  const title = document.createElement('div');
  title.className = 'new-task-title';

  // 検索キーワードハイライト
  if (currentSearchKeyword && typeof window.searchFilter !== 'undefined' && typeof window.searchFilter.highlightSearchResult === 'function') {
    title.innerHTML = window.searchFilter.highlightSearchResult(task.title, currentSearchKeyword);
  } else {
    title.textContent = task.title;
  }

  body.appendChild(title);

  // メタ情報
  const meta = createNewTaskMeta(task);
  if (meta.children.length > 0) {
    body.appendChild(meta);
  }

  card.appendChild(body);

  // アクションボタングループ
  const actions = document.createElement('div');
  actions.className = 'new-task-actions';

  // サブタスク追加ボタン（未完了タスクのみ表示）
  if (!task.isCompleted && typeof canHaveSubtask === 'function' && canHaveSubtask(task.id)) {
    const addSubtaskBtn = document.createElement('button');
    addSubtaskBtn.className = 'new-task-action-btn';
    addSubtaskBtn.innerHTML = '+';
    addSubtaskBtn.title = 'サブタスクを追加';
    addSubtaskBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      if (typeof addingSubtaskForTaskId !== 'undefined' && typeof renderTasks === 'function') {
        addingSubtaskForTaskId = task.id;
        renderTasks();
      }
    });
    actions.appendChild(addSubtaskBtn);
  }

  // メニューボタン
  const menuBtn = document.createElement('button');
  menuBtn.className = 'new-task-menu-btn';
  menuBtn.innerHTML = '⋮';
  menuBtn.title = 'メニュー';
  menuBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    showTaskMenu(e, task);
  });
  actions.appendChild(menuBtn);

  card.appendChild(actions);

  // クリックで編集
  card.addEventListener('click', (e) => {
    if (!e.target.closest('.new-task-checkbox') && !e.target.closest('.new-task-menu-btn') && !e.target.closest('.new-task-action-btn')) {
      openEditModal(task.id);
    }
  });

  return card;
}

// タスクリスト表示
function renderTasks() {
  const tasks = getTasks();

  // 親タスクのみを抽出（サブタスクは親タスクと一緒に表示される）
  const parentTasks = tasks.filter(t => !t.parentId);

  // 検索・フィルター・ソート機能を適用
  let filteredTasks = parentTasks;
  if (typeof window.searchFilter !== 'undefined' && typeof window.searchFilter.apply === 'function') {
    filteredTasks = window.searchFilter.apply(parentTasks);
  }

  // 完了/未完了で分離
  const activeTasks = filteredTasks.filter(t => !t.isCompleted);
  const completedTasks = filteredTasks.filter(t => t.isCompleted);

  // 検索キーワードを取得（ハイライト表示のため）
  const searchKeyword = (typeof window.searchFilter !== 'undefined' && typeof window.searchFilter.getSearchKeyword === 'function')
    ? window.searchFilter.getSearchKeyword()
    : '';

  // グローバル変数に保存（createTaskElement で使用）
  currentSearchKeyword = searchKeyword;

  // ソート設定（日付グループ内でのソートは不要になったが、互換性のため保持）
  const sortPref = (typeof window.searchFilter !== 'undefined' && typeof window.searchFilter.getCurrentSort === 'function')
    ? window.searchFilter.getCurrentSort()
    : 'time';

  // タスクタブ
  const tasksList = document.getElementById('tasks-list');
  const tasksEmpty = document.getElementById('tasks-empty');
  tasksList.innerHTML = '';

  if (activeTasks.length === 0) {
    tasksEmpty.classList.add('show');
  } else {
    tasksEmpty.classList.remove('show');

    // 日付ごとにタスクをグループ化
    const tasksByDate = groupTasksByDate(activeTasks);

    // 昨日以前（期限切れ+昨日）と今日以降に分離
    const pastGroups = tasksByDate.filter(g =>
      g.date.startsWith('overdue_') || g.date === 'yesterday'
    );
    const currentAndFutureGroups = tasksByDate.filter(g =>
      !g.date.startsWith('overdue_') && g.date !== 'yesterday'
    );

    // 昨日以前のタスクセクション
    if (pastGroups.length > 0) {
      const pastTasksCount = pastGroups.reduce((sum, g) => sum + g.tasks.length, 0);

      // 折りたたみトグルボタン（新UI/旧UIで異なるクラスを使用）
      const pastToggle = document.createElement('button');
      const useNewUI = isNewUIEnabled();
      pastToggle.className = useNewUI ? 'new-past-tasks-toggle' : 'past-tasks-toggle';
      pastToggle.id = 'past-tasks-toggle';

      // 開閉状態を localStorage から復元（デフォルトは閉じた状態）
      const isPastOpen = loadFromStorage('nowtask_past_tasks_open', false);

      const toggleIcon = document.createElement('span');
      toggleIcon.className = 'toggle-icon';
      toggleIcon.textContent = isPastOpen ? '▼' : '▶';

      const toggleText = document.createElement('span');
      toggleText.className = 'toggle-text';
      toggleText.textContent = '昨日以前のタスク';

      const pastCount = document.createElement('span');
      pastCount.className = useNewUI ? 'new-past-tasks-count' : 'past-tasks-count';
      pastCount.textContent = `(${pastTasksCount})`;

      pastToggle.appendChild(toggleIcon);
      pastToggle.appendChild(toggleText);
      pastToggle.appendChild(pastCount);

      if (isPastOpen) {
        pastToggle.classList.add('open');
      }

      tasksList.appendChild(pastToggle);

      // 昨日以前のタスクコンテンツ
      const pastContent = document.createElement('div');
      pastContent.className = useNewUI ? 'new-past-tasks-content' : 'past-tasks-content';
      pastContent.id = 'past-tasks-content';
      if (isPastOpen) {
        pastContent.classList.add('open');
      }

      // 昨日以前のグループをレンダリング
      pastGroups.forEach(({ date, label, tasks: dateTasks }) => {
        renderDateGroup(date, label, dateTasks, pastContent, sortPref);
      });

      tasksList.appendChild(pastContent);

      // トグルイベント
      pastToggle.addEventListener('click', () => {
        const isOpen = pastToggle.classList.toggle('open');
        pastContent.classList.toggle('open');
        toggleIcon.textContent = isOpen ? '▼' : '▶';
        saveToStorage('nowtask_past_tasks_open', isOpen);
      });
    }

    // 今日以降のタスクをレンダリング
    currentAndFutureGroups.forEach(({ date, label, tasks: dateTasks }) => {
      renderDateGroup(date, label, dateTasks, tasksList, sortPref);
    });
  }

  // 完了済みセクション
  const completedList = document.getElementById('completed-list');
  const completedCount = document.getElementById('completed-count');
  const completedSection = document.getElementById('completed-section');
  completedList.innerHTML = '';

  // 完了済みタスクの総数を計算
  let totalCompleted = completedTasks.length;
  completedTasks.forEach(task => {
    const subtasks = getSubtasks(task.id);
    totalCompleted += subtasks.filter(st => st.isCompleted).length;
  });

  if (totalCompleted === 0) {
    completedSection.style.display = 'none';
  } else {
    completedSection.style.display = 'block';
    completedCount.textContent = `(${totalCompleted})`;

    completedTasks.forEach(task => {
      renderTaskWithSubtasks(task, completedList, true);
    });
  }

  // 24時間ゲージ更新
  updateTimeGauge();
}

// セクションラベルをレンダリング（新UI対応）
function renderSectionLabel(dateKey, label) {
  const sectionDiv = document.createElement('div');

  if (isNewUIEnabled()) {
    // 新UI: セクションラベル + 追加ボタン
    sectionDiv.className = 'new-section-label';
    sectionDiv.dataset.date = dateKey;

    const title = document.createElement('span');
    title.className = 'new-section-title';
    title.textContent = label;
    sectionDiv.appendChild(title);

    const addBtn = document.createElement('button');
    addBtn.className = 'new-section-add-btn';
    addBtn.innerHTML = '+';
    addBtn.dataset.date = dateKey;
    addBtn.title = 'タスク追加';
    sectionDiv.appendChild(addBtn);
  } else {
    // 旧UI: 従来の日付セパレーター
    sectionDiv.className = 'date-separator';
    sectionDiv.dataset.date = dateKey;
    sectionDiv.innerHTML = `
      <div class="date-separator-line"></div>
      <div class="date-separator-label">${label}</div>
      <div class="date-separator-line"></div>
    `;
  }

  return sectionDiv;
}

// 日付グループをレンダリング（共通関数）
function renderDateGroup(date, label, dateTasks, container, sortPref) {
  // 各日付グループ内でソートを適用
  if (sortPref === 'time') {
    dateTasks.sort((a, b) => {
      // 期限なしは末尾に回す
      if (!a.dueDate && !b.dueDate) return 0;
      if (!a.dueDate) return 1;
      if (!b.dueDate) return -1;
      return new Date(a.dueDate) - new Date(b.dueDate);
    });
  } else if (sortPref === 'created') {
    // 追加順: createdAt の降順（新しいものを上に）
    dateTasks.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
  } else if (sortPref === 'priority') {
    // 優先順位順: 緊急 > 高 > 中 > 低 > 未設定
    const priorityOrder = { high: 1, medium: 2, low: 3, '': 4 };
    dateTasks.sort((a, b) => {
      // 緊急フラグを最優先
      if (a.urgent && !b.urgent) return -1;
      if (!a.urgent && b.urgent) return 1;
      // 優先度で比較
      const aPriority = priorityOrder[a.priority || ''] || 4;
      const bPriority = priorityOrder[b.priority || ''] || 4;
      return aPriority - bPriority;
    });
  }

  // セクションラベルのレンダリング
  const sectionLabel = renderSectionLabel(date, label);
  container.appendChild(sectionLabel);

  // タスクをレンダリング
  dateTasks.forEach(task => {
    renderTaskWithSubtasks(task, container, false);
  });

  // 明日のタスクの場合、追加ボタンを表示
  if (date === 'tomorrow') {
    const addTomorrowBtn = document.createElement('button');
    addTomorrowBtn.className = 'add-tomorrow-task-btn';
    addTomorrowBtn.innerHTML = '+ 明日のタスクを追加';
    addTomorrowBtn.addEventListener('click', () => {
      // 明日の日付を設定してモーダルを開く
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      const tomorrowISO = formatDateISO(tomorrow);
      openCreateModal();
      // モーダルが開いた後に日付を設定
      setTimeout(() => {
        document.getElementById('task-due-date').value = tomorrowISO;
      }, 0);
    });
    container.appendChild(addTomorrowBtn);
  }
}

// タスクとサブタスクを再帰的にレンダリング
function renderTaskWithSubtasks(task, container, isCompletedSection) {
  const level = getTaskLevel(task.id);

  // タスク要素を作成
  container.appendChild(createTaskElement(task, level));

  // サブタスクを再帰的に表示
  const subtasks = getSubtasks(task.id);
  subtasks.forEach(subtask => {
    // 完了状態によってフィルタリング
    if (isCompletedSection) {
      if (subtask.isCompleted) {
        renderTaskWithSubtasks(subtask, container, true);
      }
    } else {
      if (!subtask.isCompleted) {
        renderTaskWithSubtasks(subtask, container, false);
      }
    }
  });

  // インライン入力中の場合
  if (addingSubtaskForTaskId === task.id) {
    const inputDiv = createSubtaskInputInline(task.id, level);
    container.appendChild(inputDiv);
  }
}

// タスク要素作成
function createTaskElement(task, level = 0) {
  // 新UI有効時は新タスクカード構造を使用
  if (isNewUIEnabled() && level === 0) {
    // 親タスクのみ新構造を使用（サブタスクは旧構造）
    const card = createNewTaskCard(task, level);

    // ドラッグ&ドロップ機能を追加
    setupDragAndDrop(card, task);

    return card;
  }

  // 旧UI（デフォルト）
  const div = document.createElement('div');
  div.className = 'task-item' + (task.isCompleted ? ' completed' : '') + (task.isTutorial ? ' tutorial' : '');
  if (level > 0) {
    div.classList.add('subtask');
    div.classList.add(`level-${level}`);
  }
  if (isSelectionMode && selectedTaskIds.has(task.id)) {
    div.classList.add('selected');
  }
  div.dataset.id = task.id;
  div.dataset.taskId = task.id;
  div.dataset.level = level;

  // 選択モード時の選択チェックボックス
  if (isSelectionMode) {
    const selectCheckbox = document.createElement('input');
    selectCheckbox.type = 'checkbox';
    selectCheckbox.className = 'task-select-checkbox';
    selectCheckbox.checked = selectedTaskIds.has(task.id);
    selectCheckbox.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleTaskSelection(task.id);
    });
    div.appendChild(selectCheckbox);
  }

  // チェックボックス
  const checkbox = document.createElement('input');
  checkbox.type = 'checkbox';
  checkbox.className = 'task-checkbox';
  checkbox.checked = task.isCompleted;
  checkbox.addEventListener('click', (e) => {
    e.stopPropagation();
    if (isSelectionMode) {
      toggleTaskSelection(task.id);
    } else {
      toggleTaskCompletion(task.id);
    }
  });

  // コンテンツ部分
  const content = document.createElement('div');
  content.className = 'task-content';

  const title = document.createElement('div');
  title.className = 'task-title';

  // 検索キーワードがある場合はハイライト表示
  if (currentSearchKeyword && typeof window.searchFilter !== 'undefined' && typeof window.searchFilter.highlightSearchResult === 'function') {
    title.innerHTML = window.searchFilter.highlightSearchResult(task.title, currentSearchKeyword);
  } else {
    title.textContent = task.title;
  }

  content.appendChild(title);

  // メタ情報
  const meta = document.createElement('div');
  meta.className = 'task-meta';

  // 緊急ラベル
  if (task.urgent) {
    const urgentLabel = document.createElement('span');
    urgentLabel.className = 'task-urgent-label';
    urgentLabel.textContent = '🚨 緊急';
    meta.appendChild(urgentLabel);
  }

  // 優先順位ラベル
  if (task.priority) {
    const priorityLabel = document.createElement('span');
    priorityLabel.className = `task-priority-label ${task.priority}`;
    const priorityText = {
      high: '優先度: 高',
      medium: '優先度: 中',
      low: '優先度: 低'
    };
    priorityLabel.textContent = priorityText[task.priority] || '';
    meta.appendChild(priorityLabel);
  }

  // 開始時刻・終了時刻
  if (task.startTime || task.endTime) {
    const timeSpan = document.createElement('span');
    timeSpan.className = 'task-duration';
    if (task.startTime && task.endTime) {
      timeSpan.textContent = `🕒 ${task.startTime} ~ ${task.endTime}`;
    } else if (task.startTime) {
      timeSpan.textContent = `🕒 ${task.startTime} ~`;
    } else if (task.endTime) {
      timeSpan.textContent = `🕒 ~ ${task.endTime}`;
    }
    meta.appendChild(timeSpan);
  }

  // サブタスク数表示（子タスクを持つ場合）
  const subtasks = getSubtasks(task.id);
  if (subtasks.length > 0) {
    // 折りたたみトグル（サブタスクを持つ親タスクに表示）
    const collapseToggle = document.createElement('button');
    collapseToggle.className = 'collapse-toggle';
    collapseToggle.title = 'サブタスクを折りたたむ/展開する';
    // 初期は展開状態
    collapseToggle.textContent = '▼';
    // data 属性で開閉状態を管理
    div.dataset.collapsed = 'false';

    collapseToggle.addEventListener('click', (e) => {
      // モーダルや編集イベントを発火させない
      e.stopPropagation();
      const parentLevel = Number(div.dataset.level || 0);
      const isCollapsed = div.dataset.collapsed === 'true';

      // トグル表示
      div.dataset.collapsed = isCollapsed ? 'false' : 'true';
      collapseToggle.textContent = isCollapsed ? '▼' : '▶';

      // 親要素の次の兄弟要素から探索し、親より深いレベルの要素を隠す/表示する
      let sibling = div.nextElementSibling;
      while (sibling) {
        const siblingLevel = Number(sibling.dataset.level || 0);
        // 親より深ければサブタスクとみなす
        if (siblingLevel > parentLevel) {
          if (div.dataset.collapsed === 'true') {
            sibling.classList.add('subtask-hidden');
          } else {
            sibling.classList.remove('subtask-hidden');
          }
        } else {
          // 同レベルかそれ以下に到達したらサブタスク列の終端
          break;
        }
        sibling = sibling.nextElementSibling;
      }
    });

    meta.appendChild(collapseToggle);

    const subtaskCount = document.createElement('span');
    subtaskCount.className = 'subtask-count';
    const completedCount = subtasks.filter(st => st.isCompleted).length;
    subtaskCount.textContent = `📋 ${completedCount}/${subtasks.length}`;
    meta.appendChild(subtaskCount);
  }

  // 所要時間表示
  if (task.duration) {
    const durationSpan = document.createElement('span');
    durationSpan.className = 'task-duration';
    const hours = Math.floor(task.duration / 60);
    const minutes = task.duration % 60;
    if (hours > 0) {
      durationSpan.textContent = minutes > 0 ? `⏰ ${hours}時間${minutes}分` : `⏰ ${hours}時間`;
    } else {
      durationSpan.textContent = `⏰ ${minutes}分`;
    }
    meta.appendChild(durationSpan);
  }

  // 時間ゲージバー（開始時刻と終了時刻がある場合）
  if (task.startTime && task.endTime && !task.isCompleted) {
    const [startHour, startMin] = task.startTime.split(':').map(Number);
    const [endHour, endMin] = task.endTime.split(':').map(Number);
    const startMinutes = startHour * 60 + startMin;
    let endMinutes = endHour * 60 + endMin;

    // 日をまたぐ場合は24時までとして計算
    if (endMinutes < startMinutes) {
      endMinutes = 24 * 60;
    }

    const duration = endMinutes - startMinutes;
    const leftPercent = (startMinutes / (24 * 60)) * 100;
    const widthPercent = (duration / (24 * 60)) * 100;

    const gaugeWrapper = document.createElement('div');
    gaugeWrapper.className = 'task-time-gauge-wrapper';

    const gauge = document.createElement('div');
    gauge.className = 'task-time-gauge';

    const gaugeBg = document.createElement('div');
    gaugeBg.className = 'task-time-gauge-bg';

    const gaugeBar = document.createElement('div');
    gaugeBar.className = 'task-time-gauge-bar';
    gaugeBar.style.left = `${leftPercent}%`;
    gaugeBar.style.width = `${widthPercent}%`;

    gauge.appendChild(gaugeBg);
    gauge.appendChild(gaugeBar);
    gaugeWrapper.appendChild(gauge);
    content.appendChild(gaugeWrapper);
  }

  if (task.dueDate) {
    const dueDate = document.createElement('span');
    dueDate.className = 'task-due-date';
    if (isOverdue(task.dueDate) && !task.isCompleted) {
      dueDate.classList.add('overdue');
    }
    dueDate.textContent = '📅 ' + formatDate(task.dueDate);
    meta.appendChild(dueDate);
  }

  if (task.totalTime > 0 || task.isTimerRunning) {
    const timer = document.createElement('span');
    timer.className = 'task-timer';
    if (task.isTimerRunning) {
      timer.classList.add('running');
      timer.textContent = '⏱️ 計測中...';
    } else {
      timer.textContent = '⏱️ ' + formatTime(task.totalTime);
    }
    meta.appendChild(timer);
  }

  if (meta.children.length > 0) {
    content.appendChild(meta);
  }

  if (task.memo) {
    const memo = document.createElement('div');
    memo.className = 'task-memo';

    // メモを100文字に制限
    const memoText = task.memo.substring(0, 100) + (task.memo.length > 100 ? '...' : '');

    // 検索キーワードがある場合はハイライト表示
    if (currentSearchKeyword && typeof window.searchFilter !== 'undefined' && typeof window.searchFilter.highlightSearchResult === 'function') {
      memo.innerHTML = window.searchFilter.highlightSearchResult(memoText, currentSearchKeyword);
    } else {
      memo.textContent = memoText;
    }

    content.appendChild(memo);
  }

  div.appendChild(checkbox);
  div.appendChild(content);

  // タスクアクション部分
  const actions = document.createElement('div');
  actions.className = 'task-card-actions';

  // 時間記録停止ボタン（タイマー実行中のみ表示）
  if (task.isTimerRunning) {
    const stopBtn = document.createElement('button');
    stopBtn.className = 'timer-stop-btn';
    stopBtn.innerHTML = '⏹';
    stopBtn.title = '時間記録停止';
    stopBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      stopTaskTimer(task.id);
      renderTasks();
    });
    actions.appendChild(stopBtn);
  }

  // サブタスク追加ボタン（タスク内に表示）
  if (!task.isCompleted && canHaveSubtask(task.id)) {
    const addSubtaskIcon = document.createElement('button');
    addSubtaskIcon.className = 'add-subtask-icon';
    addSubtaskIcon.innerHTML = '+';
    addSubtaskIcon.title = 'サブタスクを追加';
    addSubtaskIcon.addEventListener('click', (e) => {
      e.stopPropagation();
      addingSubtaskForTaskId = task.id;
      renderTasks();
    });
    actions.appendChild(addSubtaskIcon);
  }

  // メニューボタン
  const menuBtn = document.createElement('button');
  menuBtn.className = 'task-menu-btn';
  menuBtn.innerHTML = '⋮';
  menuBtn.title = 'メニュー';
  menuBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    showTaskMenu(e, task);
  });
  actions.appendChild(menuBtn);

  div.appendChild(actions);

  // カード全体のクリックで編集（チェックボックスとボタン以外）
  div.addEventListener('click', (e) => {
    if (!e.target.closest('.task-checkbox') && !e.target.closest('.task-card-actions')) {
      openEditModal(task.id);
    }
  });

  // ドラッグ&ドロップ機能
  setupDragAndDrop(div, task);

  return div;
}

// インラインサブタスク入力作成
function createSubtaskInputInline(parentId, parentLevel = 0) {
  const div = document.createElement('div');
  div.className = 'subtask-input-inline';
  div.classList.add(`level-${parentLevel + 1}`);

  const input = document.createElement('input');
  input.type = 'text';
  input.placeholder = 'サブタスク名を入力';
  input.maxLength = 100;

  const saveInlineSubtask = () => {
    const title = input.value.trim();
    if (title) {
      createTask(title, '', null, parentId);
    }
    addingSubtaskForTaskId = null;
    renderTasks();
  };

  input.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      saveInlineSubtask();
    }
  });

  input.addEventListener('blur', () => {
    setTimeout(() => {
      addingSubtaskForTaskId = null;
      renderTasks();
    }, 200);
  });

  div.appendChild(input);

  // 自動フォーカス
  setTimeout(() => input.focus(), 0);

  return div;
}

// ========================================
// ドラッグ&ドロップ機能
// ========================================
let draggedElement = null;
let longPressTimer = null;
let isDragging = false;
let dragStartX = 0;
let dragStartLevel = 0;
let currentDragLevel = 0;

// スワイプジェスチャー用の変数
let isSwiping = false;
let swipeDirection = null; // 'left' | 'right' | null

function setupDragAndDrop(element, task) {
  let startY = 0;
  let startX = 0;
  let swipeStartTime = 0;
  let hasMoved = false; // ドラッグで実際に移動したかどうか
  let dragDistance = 0; // ドラッグした距離
  let longPressTouchX = 0; // 長押し時のタッチ位置X
  let longPressTouchY = 0; // 長押し時のタッチ位置Y

  // タッチデバイス用の長押し検出
  element.addEventListener('touchstart', (e) => {
    // チェックボックスやボタンの場合は無視
    if (e.target.closest('.task-checkbox') || e.target.closest('.task-card-actions') ||
        e.target.closest('.new-task-checkbox') || e.target.closest('.new-task-menu-btn')) {
      return;
    }

    const touch = e.touches[0];
    startY = touch.clientY;
    startX = touch.clientX;
    longPressTouchX = touch.clientX;
    longPressTouchY = touch.clientY;
    swipeStartTime = Date.now();
    isSwiping = false;
    swipeDirection = null;
    hasMoved = false;
    dragDistance = 0;

    // 500ms長押しでコンテキストメニュー表示
    longPressTimer = setTimeout(() => {
      if (!isSwiping) {
        // 振動フィードバック（対応デバイスのみ）
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }

        // コンテキストメニューを表示
        showTaskMenuFromLongPress(longPressTouchX, longPressTouchY, task);

        // 長押しタイマーをクリア
        longPressTimer = null;
      }
    }, 500);
  });

  element.addEventListener('touchmove', (e) => {
    const touch = e.touches[0];
    const moveY = Math.abs(touch.clientY - startY);
    const moveX = touch.clientX - startX;
    const moveXAbs = Math.abs(moveX);

    // スワイプジェスチャー判定（水平方向の移動が垂直方向より大きい場合）
    if (!isDragging && !isSwiping && moveXAbs > 25 && moveXAbs > moveY * 1.5) {
      // 長押しタイマーをキャンセル
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }

      isSwiping = true;
      element.classList.add('swiping');

      // 振動フィードバック
      if (navigator.vibrate) {
        navigator.vibrate(10);
      }
    }

    // スワイプ中の視覚的フィードバック
    if (isSwiping) {
      e.preventDefault(); // 画面スクロールを防止
      e.stopPropagation(); // イベント伝播を停止

      // 真ん中のキャンセルゾーン（±15px以内）
      const CANCEL_ZONE = 15;

      if (moveXAbs <= CANCEL_ZONE) {
        // キャンセルゾーン内：どの方向のスタイルも外す
        swipeDirection = null;
        element.classList.remove('swiping-left', 'swiping-right');
      } else {
        // キャンセルゾーン外：スワイプ方向を判定
        if (moveX > CANCEL_ZONE) {
          swipeDirection = 'right';
          element.classList.remove('swiping-left');
          element.classList.add('swiping-right');
        } else if (moveX < -CANCEL_ZONE) {
          swipeDirection = 'left';
          element.classList.remove('swiping-right');
          element.classList.add('swiping-left');
        }
      }
    }
    // ドラッグ&ドロップ中の処理
    else if (isDragging && draggedElement) {
      e.preventDefault();

      // 移動距離を計算（50px以上移動したら実際に移動したとみなす）
      const totalMoveY = Math.abs(touch.clientY - startY);
      const totalMoveX = Math.abs(touch.clientX - startX);
      dragDistance = Math.max(totalMoveY, totalMoveX);

      if (dragDistance > 50 && !hasMoved) {
        hasMoved = true; // 50px以上移動したら移動判定
        console.log('Drag moved more than 50px - will save position');
      }

      // 水平方向のドラッグで階層を変更
      const deltaX = touch.clientX - dragStartX;
      const indentSize = 40; // 1階層のインデント幅（px）
      const levelChange = Math.floor(deltaX / indentSize);
      const newLevel = Math.max(0, Math.min(4, dragStartLevel + levelChange));

      // レベルが変更された場合、視覚的なフィードバックを提供
      if (newLevel !== currentDragLevel) {
        currentDragLevel = newLevel;
        draggedElement.dataset.level = newLevel;
        // 既存クラスを保持しながらdraggingを追加
        draggedElement.classList.add('dragging');
        // 旧レベルのクラスを削除
        for (let i = 0; i <= 4; i++) {
          draggedElement.classList.remove(`level-${i}`);
        }
        if (newLevel > 0) {
          draggedElement.classList.add('subtask');
          draggedElement.classList.add(`level-${newLevel}`);
        } else {
          draggedElement.classList.remove('subtask');
        }
        // 振動フィードバック
        if (navigator.vibrate) {
          navigator.vibrate(20);
        }
      }

      const afterElement = getDragAfterElement(element.parentElement, touch.clientY);

      if (afterElement == null) {
        element.parentElement.appendChild(draggedElement);
      } else {
        element.parentElement.insertBefore(draggedElement, afterElement);
      }
    }
    // 水平方向の動きを検出したら早めにスクロールを防止
    else if (!isDragging && moveXAbs > 10 && moveXAbs > moveY) {
      e.preventDefault(); // 横方向の動きが優位なら画面スクロールを防止
    }

    // 長押しタイマーをキャンセル（20px以上動いた場合）
    if (longPressTimer && (moveY > 20 || moveXAbs > 20)) {
      if (!isSwiping) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    }
  });

  element.addEventListener('touchend', (e) => {
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }

    // スワイプジェスチャーの処理
    if (isSwiping) {
      e.preventDefault();

      const touch = e.changedTouches[0];
      const moveX = touch.clientX - startX;
      const swipeDuration = Date.now() - swipeStartTime;
      const CANCEL_ZONE = 15;

      // スワイプ判定（キャンセルゾーン外 かつ 1000ms以内）
      if (Math.abs(moveX) > CANCEL_ZONE && swipeDuration < 1000 && swipeDirection) {
        if (swipeDirection === 'right') {
          // 右スワイプ: タスク完了/未完了トグル
          handleSwipeRight(task.id, element);
        } else if (swipeDirection === 'left') {
          // 左スワイプ: タスク削除
          handleSwipeLeft(task.id, element);
        }
      } else {
        // キャンセルゾーン内またはスワイプ不十分な場合、元に戻す
        element.classList.add('swipe-reset');
        setTimeout(() => {
          element.classList.remove('swiping', 'swiping-right', 'swiping-left', 'swipe-reset');
        }, 300);
      }

      isSwiping = false;
      swipeDirection = null;
    }
    // ドラッグ&ドロップの終了処理
    else if (isDragging && draggedElement) {
      e.preventDefault();
      element.classList.remove('dragging');

      console.log(`touchend - isDragging: true, hasMoved: ${hasMoved}, dragDistance: ${dragDistance}px`);

      // 実際に移動した場合のみ新しい順序を保存
      if (hasMoved) {
        console.log('Saving new task order (moved > 50px)');
        saveNewTaskOrder();
      } else {
        console.log('NOT saving - drag distance too small');
      }

      isDragging = false;
      draggedElement = null;
      dragStartX = 0;
      dragStartLevel = 0;
      currentDragLevel = 0;
      hasMoved = false;
      dragDistance = 0;
    }
  });

  // MIUIなどのシステムがタッチをキャンセルした場合の処理
  element.addEventListener('touchcancel', (e) => {
    console.log(`touchcancel - isDragging: ${isDragging}, hasMoved: ${hasMoved}, dragDistance: ${dragDistance}px`);

    if (longPressTimer) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }

    // スワイプ中の場合はリセット
    if (isSwiping) {
      element.classList.add('swipe-reset');
      setTimeout(() => {
        element.classList.remove('swiping', 'swiping-right', 'swiping-left', 'swipe-reset');
      }, 300);
      isSwiping = false;
      swipeDirection = null;
    }

    // ドラッグ中の場合もリセット（保存しない）
    if (isDragging && draggedElement) {
      element.classList.remove('dragging');

      // touchcancelの場合は絶対に保存しない
      console.log('Touch cancelled by system - FORCING not to save position');

      isDragging = false;
      draggedElement = null;
      dragStartX = 0;
      dragStartLevel = 0;
      currentDragLevel = 0;
      hasMoved = false;
      dragDistance = 0;

      // 再レンダリングして元の状態に戻す
      renderTasks();
    }
  });

  // PC用のドラッグ&ドロップ
  element.setAttribute('draggable', 'true');

  element.addEventListener('dragstart', (e) => {
    // チェックボックスやボタンの場合は無視
    if (e.target.closest('.task-checkbox') || e.target.closest('.task-card-actions') ||
        e.target.closest('.new-task-checkbox') || e.target.closest('.new-task-menu-btn')) {
      e.preventDefault();
      return;
    }

    draggedElement = element;
    dragStartX = e.clientX;
    dragStartLevel = Number(element.dataset.level || 0);
    currentDragLevel = dragStartLevel;
    element.classList.add('dragging');
  });

  element.addEventListener('drag', (e) => {
    if (e.clientX === 0 && e.clientY === 0) return; // ドラッグ終了時のイベントを無視

    // 水平方向のドラッグで階層を変更
    const deltaX = e.clientX - dragStartX;
    const indentSize = 40; // 1階層のインデント幅（px）
    const levelChange = Math.floor(deltaX / indentSize);
    const newLevel = Math.max(0, Math.min(4, dragStartLevel + levelChange));

    // レベルが変更された場合、視覚的なフィードバックを提供
    if (newLevel !== currentDragLevel) {
      currentDragLevel = newLevel;
      draggedElement.dataset.level = newLevel;
      // 既存クラスを保持しながらdraggingを追加
      draggedElement.classList.add('dragging');
      // 旧レベルのクラスを削除
      for (let i = 0; i <= 4; i++) {
        draggedElement.classList.remove(`level-${i}`);
      }
      if (newLevel > 0) {
        draggedElement.classList.add('subtask');
        draggedElement.classList.add(`level-${newLevel}`);
      } else {
        draggedElement.classList.remove('subtask');
      }
    }
  });

  element.addEventListener('dragend', () => {
    console.log('dragend event fired');
    element.classList.remove('dragging');

    // 新しい順序を保存（ガードがあるので安全）
    saveNewTaskOrder();

    draggedElement = null;
    dragStartX = 0;
    dragStartLevel = 0;
    currentDragLevel = 0;
  });

  element.addEventListener('dragover', (e) => {
    e.preventDefault();
    const afterElement = getDragAfterElement(element.parentElement, e.clientY);

    if (draggedElement && draggedElement !== element) {
      if (afterElement == null) {
        element.parentElement.appendChild(draggedElement);
      } else {
        element.parentElement.insertBefore(draggedElement, afterElement);
      }
    }
  });
}

function getDragAfterElement(container, y) {
  // 旧カード（.task-item）と新カード（.new-task-card）の両方を選択
  const draggableElements = [...container.querySelectorAll('.task-item:not(.dragging), .new-task-card:not(.dragging)')];

  return draggableElements.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;

    if (offset < 0 && offset > closest.offset) {
      return { offset: offset, element: child };
    } else {
      return closest;
    }
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function saveNewTaskOrder() {
  // ガード: ドラッグ中でない場合は保存しない
  if (!isDragging && !draggedElement) {
    console.log('saveNewTaskOrder called but not dragging - BLOCKING SAVE');
    return;
  }

  const tasks = getTasks();
  // 旧カード（.task-item）と新カード（.new-task-card）の両方を選択
  const taskElements = document.querySelectorAll('.task-item:not(.completed), .new-task-card:not(.completed)');

  // 新しい順序とレベルでタスクIDを取得
  const newOrder = [];
  taskElements.forEach(el => {
    const taskId = el.dataset.taskId;
    if (taskId) {
      newOrder.push({
        id: taskId,
        level: Number(el.dataset.level || 0)
      });
    }
  });

  // ドラッグされたタスクの新しい親を決定
  const draggedTaskId = draggedElement ? draggedElement.dataset.taskId : null;
  if (draggedTaskId) {
    const draggedIndex = newOrder.findIndex(item => item.id === draggedTaskId);
    if (draggedIndex !== -1) {
      const draggedLevel = newOrder[draggedIndex].level;
      let newParentId = null;

      // ドラッグされたタスクの直前のタスクを探す
      for (let i = draggedIndex - 1; i >= 0; i--) {
        const prevTask = newOrder[i];

        // 同じレベルの場合は、同じ親を持つ
        if (prevTask.level === draggedLevel) {
          const prevTaskData = getTaskById(prevTask.id);
          newParentId = prevTaskData ? prevTaskData.parentId : null;
          break;
        }
        // 1つ浅いレベルの場合は、そのタスクを親とする
        else if (prevTask.level === draggedLevel - 1) {
          newParentId = prevTask.id;
          break;
        }
        // より浅いレベルの場合は、そのレベルまで戻って親を探す
        else if (prevTask.level < draggedLevel - 1) {
          const prevTaskData = getTaskById(prevTask.id);
          newParentId = prevTaskData ? prevTaskData.parentId : null;
          break;
        }
      }

      // バリデーション: 新しい親が有効かチェック
      const draggedTask = getTaskById(draggedTaskId);
      let isValidParent = true;

      if (newParentId) {
        // 1. サブタスクを持つタスクは他のタスクのサブタスクにできない
        const draggedSubtasks = getSubtasks(draggedTaskId);
        if (draggedSubtasks.length > 0) {
          // 新しい親が設定される場合（独立タスクからサブタスクになる場合）
          const newParentLevel = getTaskLevel(newParentId);
          if (newParentLevel + draggedSubtasks.length + 1 > 4) {
            isValidParent = false;
          }
        }

        // 2. 5階層制限のチェック
        const newParentLevel = getTaskLevel(newParentId);
        if (newParentLevel >= 4) {
          isValidParent = false;
        }

        // 3. 自分自身や自分の子孫を親にできない
        let ancestor = newParentId;
        while (ancestor) {
          if (ancestor === draggedTaskId) {
            isValidParent = false;
            break;
          }
          const ancestorTask = getTaskById(ancestor);
          ancestor = ancestorTask ? ancestorTask.parentId : null;
        }
      }

      // ドラッグされたタスクの親IDを更新
      if (draggedTask && draggedTask.parentId !== newParentId && isValidParent) {
        updateTask(draggedTaskId, { parentId: newParentId });

        // 元の親タスクの時間を再集計
        if (draggedTask.parentId && typeof aggregateSubtaskTimes === 'function') {
          aggregateSubtaskTimes(draggedTask.parentId);
        }
        // 新しい親タスクの時間を集計
        if (newParentId && typeof aggregateSubtaskTimes === 'function') {
          aggregateSubtaskTimes(newParentId);
        }
      } else if (!isValidParent) {
        // 無効な親の場合は元のレベルに戻す
        console.warn('Invalid parent: Cannot create this hierarchy');
      }

      // 日付を跨ぐドラッグ: ドラッグされたタスクの日付を更新
      // ドラッグされたタスクの直前の日付セパレーターを見つける
      const draggedTaskElement = draggedElement;
      if (draggedTaskElement && draggedTask && draggedLevel === 0) {
        // レベル0（親タスク）の場合のみ日付変更を許可
        let currentElement = draggedTaskElement.previousElementSibling;
        let nearestDateSeparator = null;

        // 直前の日付セパレーターを探す
        while (currentElement) {
          if (currentElement.classList.contains('date-separator')) {
            nearestDateSeparator = currentElement;
            break;
          }
          currentElement = currentElement.previousElementSibling;
        }

        if (nearestDateSeparator) {
          const newDateISO = nearestDateSeparator.dataset.date;
          if (newDateISO) {
            // 新しい日付を設定（ISO形式: YYYY-MM-DD）
            const newDueDate = new Date(newDateISO + 'T00:00:00').toISOString();
            if (draggedTask.dueDate !== newDueDate) {
              updateTask(draggedTaskId, { dueDate: newDueDate });
            }
          } else if (newDateISO === '') {
            // 期限なしセクションにドラッグされた場合
            if (draggedTask.dueDate) {
              updateTask(draggedTaskId, { dueDate: null });
            }
          }
        }
      }
    }
  }

  // タスクの順序を更新（customOrder フィールドを追加）
  tasks.forEach((task, index) => {
    const newIndex = newOrder.findIndex(item => item.id === task.id);
    if (newIndex !== -1) {
      task.customOrder = newIndex;
    }
  });

  // 保存
  saveTasks(tasks);

  // 再レンダリング
  renderTasks();
}

// ========================================
// スワイプジェスチャーハンドラー
// ========================================

/**
 * 右スワイプ: タスク完了/未完了トグル
 */
function handleSwipeRight(taskId, element) {
  const task = getTaskById(taskId);
  if (!task) return;

  // 完了状態をトグル
  const newCompletedState = !task.isCompleted;
  updateTask(taskId, { isCompleted: newCompletedState });

  // 振動フィードバック
  if (navigator.vibrate) {
    navigator.vibrate(30);
  }

  // アニメーションでフェードアウト
  element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
  element.style.opacity = '0';
  element.style.transform = 'translateX(100px)';

  // 300ms後に再レンダリング
  setTimeout(() => {
    renderTasks();
  }, 300);
}

/**
 * 左スワイプ: タスク削除
 */
function handleSwipeLeft(taskId, element) {
  const task = getTaskById(taskId);
  if (!task) return;

  // 確認ダイアログを表示
  const confirmDelete = confirm(`「${task.title}」を削除してもよろしいですか？`);

  if (confirmDelete) {
    // 振動フィードバック
    if (navigator.vibrate) {
      navigator.vibrate([20, 50, 20]);
    }

    // アニメーションでフェードアウト
    element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
    element.style.opacity = '0';
    element.style.transform = 'translateX(-100px)';

    // 300ms後にタスクを削除して再レンダリング
    setTimeout(() => {
      deleteTask(taskId);
      renderTasks();
    }, 300);
  } else {
    // キャンセルした場合は元に戻す
    element.classList.add('swipe-reset');
    setTimeout(() => {
      element.classList.remove('swiping', 'swiping-left', 'swipe-reset');
    }, 300);
  }
}

// ========================================
// タスクメニュー
// ========================================

/**
 * 長押しからコンテキストメニューを表示
 */
function showTaskMenuFromLongPress(touchX, touchY, task) {
  // 既存のメニューを削除
  const existingMenu = document.querySelector('.task-context-menu');
  if (existingMenu) {
    existingMenu.remove();
  }

  // メニューを作成
  const menu = createTaskMenuElement(task);

  // メニューの位置を設定（タッチ位置の下に表示）
  menu.style.position = 'fixed';

  // 画面サイズを取得
  const windowWidth = window.innerWidth;
  const windowHeight = window.innerHeight;

  // メニューを一時的に表示して高さを取得
  menu.style.visibility = 'hidden';
  document.body.appendChild(menu);
  const menuHeight = menu.offsetHeight;
  const menuWidth = menu.offsetWidth;

  // 位置を計算（画面外に出ないように調整）
  let top = touchY + 10;
  let left = touchX - menuWidth / 2;

  // 下にはみ出る場合は上に表示
  if (top + menuHeight > windowHeight) {
    top = touchY - menuHeight - 10;
  }

  // 左にはみ出る場合
  if (left < 10) {
    left = 10;
  }

  // 右にはみ出る場合
  if (left + menuWidth > windowWidth - 10) {
    left = windowWidth - menuWidth - 10;
  }

  menu.style.top = `${top}px`;
  menu.style.left = `${left}px`;
  menu.style.visibility = 'visible';

  // メニュー外をタップで閉じる
  setTimeout(() => {
    document.addEventListener('click', function closeMenu(e) {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    });

    // タッチイベントでも閉じる
    document.addEventListener('touchstart', function closeTouchMenu(e) {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('touchstart', closeTouchMenu);
      }
    });
  }, 0);
}

/**
 * ボタンクリックからコンテキストメニューを表示
 */
function showTaskMenu(event, task) {
  // 既存のメニューを削除
  const existingMenu = document.querySelector('.task-context-menu');
  if (existingMenu) {
    existingMenu.remove();
  }

  // メニューを作成
  const menu = createTaskMenuElement(task);

  // メニューの位置を設定
  const rect = event.target.getBoundingClientRect();
  menu.style.position = 'fixed';
  menu.style.top = `${rect.bottom + 5}px`;
  menu.style.left = `${rect.left}px`;

  document.body.appendChild(menu);

  // メニュー外をクリックで閉じる
  setTimeout(() => {
    document.addEventListener('click', function closeMenu(e) {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    });
  }, 0);
}

/**
 * タスクメニュー要素を作成（共通関数）
 */
function createTaskMenuElement(task) {
  const menu = document.createElement('div');
  menu.className = 'task-context-menu';

  // 編集ボタン
  const editItem = document.createElement('div');
  editItem.className = 'menu-item';
  editItem.textContent = '✏️ 編集';
  editItem.addEventListener('click', () => {
    openEditModal(task.id);
    menu.remove();
  });
  menu.appendChild(editItem);

  // 移動ボタン
  const moveItem = document.createElement('div');
  moveItem.className = 'menu-item';
  moveItem.textContent = '📅 移動';
  moveItem.addEventListener('click', () => {
    showMoveDateMenu(task, menu);
  });
  menu.appendChild(moveItem);

  // 時間記録開始/停止ボタン
  const timerItem = document.createElement('div');
  timerItem.className = 'menu-item';
  if (task.isTimerRunning) {
    timerItem.textContent = '⏸️ 時間記録停止';
    timerItem.addEventListener('click', () => {
      stopTaskTimer(task.id);
      menu.remove();
      renderTasks();
    });
  } else {
    timerItem.textContent = '▶️ 時間記録開始';
    timerItem.addEventListener('click', () => {
      startTaskTimer(task.id);
      menu.remove();
      renderTasks();
    });
  }
  menu.appendChild(timerItem);

  // 複製ボタン
  const duplicateItem = document.createElement('div');
  duplicateItem.className = 'menu-item';
  duplicateItem.textContent = '📋 複製';
  duplicateItem.addEventListener('click', () => {
    duplicateTask(task.id);
    menu.remove();
    renderTasks();
  });
  menu.appendChild(duplicateItem);

  // 削除ボタン
  const deleteItem = document.createElement('div');
  deleteItem.className = 'menu-item delete-item';
  deleteItem.textContent = '🗑️ 削除';
  deleteItem.addEventListener('click', () => {
    if (confirm(`「${task.title}」を削除してもよろしいですか？`)) {
      deleteTask(task.id);
      menu.remove();
      renderTasks();
    }
  });
  menu.appendChild(deleteItem);

  return menu;
}

/**
 * 日付移動サブメニューを表示
 */
function showMoveDateMenu(task, parentMenu) {
  // サブメニューを作成
  const submenu = document.createElement('div');
  submenu.className = 'task-context-menu';
  submenu.style.position = 'fixed';

  // 親メニューの位置を基準に配置
  const parentRect = parentMenu.getBoundingClientRect();
  submenu.style.left = `${parentRect.left}px`;
  submenu.style.top = `${parentRect.top}px`;

  // 今日
  const todayItem = document.createElement('div');
  todayItem.className = 'menu-item';
  todayItem.textContent = '📅 今日';
  todayItem.addEventListener('click', () => {
    const today = new Date();
    today.setHours(12, 0, 0, 0);
    updateTask(task.id, { dueDate: today.toISOString() });
    parentMenu.remove();
    submenu.remove();
    renderTasks();
  });
  submenu.appendChild(todayItem);

  // 明日
  const tomorrowItem = document.createElement('div');
  tomorrowItem.className = 'menu-item';
  tomorrowItem.textContent = '📅 明日';
  tomorrowItem.addEventListener('click', () => {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(12, 0, 0, 0);
    updateTask(task.id, { dueDate: tomorrow.toISOString() });
    parentMenu.remove();
    submenu.remove();
    renderTasks();
  });
  submenu.appendChild(tomorrowItem);

  // 来週
  const nextWeekItem = document.createElement('div');
  nextWeekItem.className = 'menu-item';
  nextWeekItem.textContent = '📅 来週';
  nextWeekItem.addEventListener('click', () => {
    const nextWeek = new Date();
    nextWeek.setDate(nextWeek.getDate() + 7);
    nextWeek.setHours(12, 0, 0, 0);
    updateTask(task.id, { dueDate: nextWeek.toISOString() });
    parentMenu.remove();
    submenu.remove();
    renderTasks();
  });
  submenu.appendChild(nextWeekItem);

  // 期限なし
  const noDateItem = document.createElement('div');
  noDateItem.className = 'menu-item';
  noDateItem.textContent = '📅 期限なし';
  noDateItem.addEventListener('click', () => {
    updateTask(task.id, { dueDate: null });
    parentMenu.remove();
    submenu.remove();
    renderTasks();
  });
  submenu.appendChild(noDateItem);

  // 戻る
  const backItem = document.createElement('div');
  backItem.className = 'menu-item';
  backItem.textContent = '← 戻る';
  backItem.addEventListener('click', () => {
    submenu.remove();
  });
  submenu.appendChild(backItem);

  // 親メニューを非表示にして、サブメニューを表示
  parentMenu.style.display = 'none';
  document.body.appendChild(submenu);

  // サブメニュー外をクリック/タッチで両方閉じる
  setTimeout(() => {
    const closeHandler = (e) => {
      if (!submenu.contains(e.target)) {
        submenu.remove();
        parentMenu.remove();
        document.removeEventListener('click', closeHandler);
        document.removeEventListener('touchstart', closeHandler);
      }
    };
    document.addEventListener('click', closeHandler);
    document.addEventListener('touchstart', closeHandler);
  }, 0);
}

// ========================================
// 複数選択モード
// ========================================

// 選択モードのトグル
function toggleSelectionMode() {
  isSelectionMode = !isSelectionMode;

  if (isSelectionMode) {
    // 選択モード開始
    selectedTaskIds.clear();
    document.body.classList.add('selection-mode');
    const toolbar = document.getElementById('bulk-actions-toolbar');
    if (toolbar) toolbar.style.display = 'flex';

    // 複数選択ボタンをアクティブ状態にする（旧UI）
    const bulkSelectToggleBtn = document.getElementById('bulk-select-toggle-btn');
    if (bulkSelectToggleBtn) bulkSelectToggleBtn.classList.add('active');

    // 複数選択ボタンをアクティブ状態にする（新UI）
    const newBulkSelectToggleBtn = document.getElementById('new-bulk-select-toggle-btn');
    if (newBulkSelectToggleBtn) newBulkSelectToggleBtn.classList.add('active');

    updateBulkActionsCount();
  } else {
    // 選択モード終了
    selectedTaskIds.clear();
    document.body.classList.remove('selection-mode');
    const toolbar = document.getElementById('bulk-actions-toolbar');
    if (toolbar) toolbar.style.display = 'none';

    // 複数選択ボタンを非アクティブ状態にする（旧UI）
    const bulkSelectToggleBtn = document.getElementById('bulk-select-toggle-btn');
    if (bulkSelectToggleBtn) bulkSelectToggleBtn.classList.remove('active');

    // 複数選択ボタンを非アクティブ状態にする（新UI）
    const newBulkSelectToggleBtn = document.getElementById('new-bulk-select-toggle-btn');
    if (newBulkSelectToggleBtn) newBulkSelectToggleBtn.classList.remove('active');
  }

  renderTasks();
}

// タスク選択のトグル
function toggleTaskSelection(taskId) {
  if (selectedTaskIds.has(taskId)) {
    selectedTaskIds.delete(taskId);
  } else {
    selectedTaskIds.add(taskId);
  }

  updateBulkActionsCount();

  // 選択状態を視覚的に更新
  const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
  if (taskElement) {
    taskElement.classList.toggle('selected', selectedTaskIds.has(taskId));
    const checkbox = taskElement.querySelector('.task-select-checkbox');
    if (checkbox) checkbox.checked = selectedTaskIds.has(taskId);
  }
}

// 選択数の更新
function updateBulkActionsCount() {
  const countEl = document.getElementById('bulk-selection-count');
  if (countEl) {
    countEl.textContent = `${selectedTaskIds.size}個選択中`;
  }
}

// 一括完了
function bulkCompleteActions() {
  if (selectedTaskIds.size === 0) return;

  selectedTaskIds.forEach(taskId => {
    const task = getTaskById(taskId);
    if (task && !task.isCompleted) {
      updateTask(taskId, { isCompleted: true });
    }
  });

  toggleSelectionMode(); // 選択モードを終了
}

// 一括削除
function bulkDeleteTasks() {
  if (selectedTaskIds.size === 0) return;

  if (!confirm(`${selectedTaskIds.size}個のタスクを削除してもよろしいですか？`)) {
    return;
  }

  selectedTaskIds.forEach(taskId => {
    deleteTask(taskId);
  });

  toggleSelectionMode(); // 選択モードを終了
}

// 全選択/全解除
function bulkSelectAll() {
  // 現在表示されているすべてのタスクを取得
  const allVisibleTaskIds = [];
  // 旧カード（.task-item）と新カード（.new-task-card）の両方を選択
  document.querySelectorAll('.task-item:not(.completed), .new-task-card:not(.completed)').forEach(el => {
    const taskId = el.dataset.taskId;
    if (taskId) {
      allVisibleTaskIds.push(taskId);
    }
  });

  // すべて選択されている場合は全解除、そうでない場合は全選択
  if (selectedTaskIds.size === allVisibleTaskIds.length && allVisibleTaskIds.length > 0) {
    // 全解除
    selectedTaskIds.clear();
  } else {
    // 全選択
    selectedTaskIds.clear();
    allVisibleTaskIds.forEach(taskId => {
      selectedTaskIds.add(taskId);
    });
  }

  updateBulkActionsCount();
  renderTasks();
}

// 一括日付変更
function bulkChangeDateTasks(event) {
  if (selectedTaskIds.size === 0) {
    alert('タスクを選択してください');
    return;
  }

  // 既存のメニューを削除
  const existingMenu = document.querySelector('.bulk-date-menu');
  if (existingMenu) {
    existingMenu.remove();
    return; // トグル動作
  }

  // メニューを作成
  const menu = document.createElement('div');
  menu.className = 'task-context-menu bulk-date-menu';
  menu.style.position = 'fixed';

  // ボタンの位置を基準に配置
  const rect = event.target.closest('button').getBoundingClientRect();
  menu.style.top = `${rect.bottom + 5}px`;
  menu.style.left = `${rect.left}px`;

  // 今日
  const todayItem = document.createElement('div');
  todayItem.className = 'menu-item';
  todayItem.textContent = '📅 今日';
  todayItem.addEventListener('click', () => {
    const today = new Date();
    today.setHours(12, 0, 0, 0);
    bulkUpdateDate(today.toISOString());
    menu.remove();
  });
  menu.appendChild(todayItem);

  // 明日
  const tomorrowItem = document.createElement('div');
  tomorrowItem.className = 'menu-item';
  tomorrowItem.textContent = '📅 明日';
  tomorrowItem.addEventListener('click', () => {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(12, 0, 0, 0);
    bulkUpdateDate(tomorrow.toISOString());
    menu.remove();
  });
  menu.appendChild(tomorrowItem);

  // 来週
  const nextWeekItem = document.createElement('div');
  nextWeekItem.className = 'menu-item';
  nextWeekItem.textContent = '📅 来週';
  nextWeekItem.addEventListener('click', () => {
    const nextWeek = new Date();
    nextWeek.setDate(nextWeek.getDate() + 7);
    nextWeek.setHours(12, 0, 0, 0);
    bulkUpdateDate(nextWeek.toISOString());
    menu.remove();
  });
  menu.appendChild(nextWeekItem);

  // 期限なし
  const noDateItem = document.createElement('div');
  noDateItem.className = 'menu-item';
  noDateItem.textContent = '📅 期限なし';
  noDateItem.addEventListener('click', () => {
    bulkUpdateDate(null);
    menu.remove();
  });
  menu.appendChild(noDateItem);

  document.body.appendChild(menu);

  // メニュー外をクリックで閉じる
  setTimeout(() => {
    const closeHandler = (e) => {
      if (!menu.contains(e.target) && !event.target.closest('button').contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeHandler);
        document.removeEventListener('touchstart', closeHandler);
      }
    };
    document.addEventListener('click', closeHandler);
    document.addEventListener('touchstart', closeHandler);
  }, 0);
}

// 日付の一括更新
function bulkUpdateDate(dueDate) {
  selectedTaskIds.forEach(taskId => {
    updateTask(taskId, { dueDate: dueDate });
  });

  // 振動フィードバック
  if (navigator.vibrate) {
    navigator.vibrate(30);
  }

  renderTasks();
}

// 一括優先度変更
function bulkChangePriorityTasks(event) {
  if (selectedTaskIds.size === 0) {
    alert('タスクを選択してください');
    return;
  }

  // 既存のメニューを削除
  const existingMenu = document.querySelector('.bulk-priority-menu');
  if (existingMenu) {
    existingMenu.remove();
    return; // トグル動作
  }

  // メニューを作成
  const menu = document.createElement('div');
  menu.className = 'task-context-menu bulk-priority-menu';
  menu.style.position = 'fixed';

  // ボタンの位置を基準に配置
  const rect = event.target.closest('button').getBoundingClientRect();
  menu.style.top = `${rect.bottom + 5}px`;
  menu.style.left = `${rect.left}px`;

  // 緊急フラグ
  const urgentItem = document.createElement('div');
  urgentItem.className = 'menu-item';
  urgentItem.textContent = '🚨 緊急';
  urgentItem.addEventListener('click', () => {
    bulkUpdatePriority({ urgent: true });
    menu.remove();
  });
  menu.appendChild(urgentItem);

  // 優先度: 高
  const highItem = document.createElement('div');
  highItem.className = 'menu-item';
  highItem.textContent = '⬆️ 優先度: 高';
  highItem.addEventListener('click', () => {
    bulkUpdatePriority({ priority: 'high', urgent: false });
    menu.remove();
  });
  menu.appendChild(highItem);

  // 優先度: 中
  const mediumItem = document.createElement('div');
  mediumItem.className = 'menu-item';
  mediumItem.textContent = '➡️ 優先度: 中';
  mediumItem.addEventListener('click', () => {
    bulkUpdatePriority({ priority: 'medium', urgent: false });
    menu.remove();
  });
  menu.appendChild(mediumItem);

  // 優先度: 低
  const lowItem = document.createElement('div');
  lowItem.className = 'menu-item';
  lowItem.textContent = '⬇️ 優先度: 低';
  lowItem.addEventListener('click', () => {
    bulkUpdatePriority({ priority: 'low', urgent: false });
    menu.remove();
  });
  menu.appendChild(lowItem);

  // 優先度なし
  const noPriorityItem = document.createElement('div');
  noPriorityItem.className = 'menu-item';
  noPriorityItem.textContent = '❌ 優先度なし';
  noPriorityItem.addEventListener('click', () => {
    bulkUpdatePriority({ priority: '', urgent: false });
    menu.remove();
  });
  menu.appendChild(noPriorityItem);

  document.body.appendChild(menu);

  // メニュー外をクリックで閉じる
  setTimeout(() => {
    const closeHandler = (e) => {
      if (!menu.contains(e.target) && !event.target.closest('button').contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeHandler);
        document.removeEventListener('touchstart', closeHandler);
      }
    };
    document.addEventListener('click', closeHandler);
    document.addEventListener('touchstart', closeHandler);
  }, 0);
}

// 優先度の一括更新
function bulkUpdatePriority(updates) {
  selectedTaskIds.forEach(taskId => {
    updateTask(taskId, updates);
  });

  // 振動フィードバック
  if (navigator.vibrate) {
    navigator.vibrate(30);
  }

  renderTasks();
}

// ========================================
// クイックアクション
// ========================================

/**
 * 今日のタスクを一括完了
 */
function quickCompleteToday() {
  const tasks = getTasks();
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  let completedCount = 0;

  tasks.forEach(task => {
    if (!task.isCompleted && task.dueDate) {
      const taskDate = new Date(task.dueDate);
      taskDate.setHours(0, 0, 0, 0);

      if (taskDate.getTime() === today.getTime()) {
        updateTask(task.id, { isCompleted: true });
        completedCount++;
      }
    }
  });

  if (completedCount > 0) {
    alert(`今日のタスク ${completedCount}個を完了しました`);
    renderTasks();

    // 振動フィードバック
    if (navigator.vibrate) {
      navigator.vibrate(50);
    }
  } else {
    alert('今日の未完了タスクはありません');
  }
}

/**
 * 期限切れタスクを明日に移動
 */
function quickMoveOverdueToTomorrow() {
  const tasks = getTasks();
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);
  tomorrow.setHours(12, 0, 0, 0);

  let movedCount = 0;

  tasks.forEach(task => {
    if (!task.isCompleted && task.dueDate) {
      const taskDate = new Date(task.dueDate);
      taskDate.setHours(0, 0, 0, 0);

      if (taskDate.getTime() < today.getTime()) {
        updateTask(task.id, { dueDate: tomorrow.toISOString() });
        movedCount++;
      }
    }
  });

  if (movedCount > 0) {
    alert(`期限切れタスク ${movedCount}個を明日に移動しました`);
    renderTasks();

    // 振動フィードバック
    if (navigator.vibrate) {
      navigator.vibrate(50);
    }
  } else {
    alert('期限切れのタスクはありません');
  }
}

/**
 * 完了タスクをアーカイブ（削除）
 */
function quickArchiveCompleted() {
  const tasks = getTasks();
  const completedTasks = tasks.filter(t => t.isCompleted);

  if (completedTasks.length === 0) {
    alert('完了済みのタスクはありません');
    return;
  }

  if (!confirm(`完了済みタスク ${completedTasks.length}個をアーカイブしてもよろしいですか？\n（ゴミ箱に移動されます）`)) {
    return;
  }

  let archivedCount = 0;
  completedTasks.forEach(task => {
    deleteTask(task.id);
    archivedCount++;
  });

  alert(`${archivedCount}個のタスクをアーカイブしました`);
  renderTasks();

  // 振動フィードバック
  if (navigator.vibrate) {
    navigator.vibrate(50);
  }
}

/**
 * 今日の未完了タスクを明日にコピー
 */
function quickCopyTodayToTomorrow() {
  const tasks = getTasks();
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);
  tomorrow.setHours(12, 0, 0, 0);

  const todayTasks = tasks.filter(task => {
    if (task.isCompleted || !task.dueDate) return false;
    const taskDate = new Date(task.dueDate);
    taskDate.setHours(0, 0, 0, 0);
    return taskDate.getTime() === today.getTime();
  });

  if (todayTasks.length === 0) {
    alert('今日の未完了タスクはありません');
    return;
  }

  if (!confirm(`今日の未完了タスク ${todayTasks.length}個を明日にコピーしてもよろしいですか？`)) {
    return;
  }

  const allTasks = getTasks();
  const now = new Date().toISOString();

  todayTasks.forEach(task => {
    const copiedTask = {
      ...task,
      id: generateUUID(),
      dueDate: tomorrow.toISOString(),
      isCompleted: false,
      createdAt: now,
      updatedAt: now
    };
    allTasks.unshift(copiedTask);
  });

  saveTasks(allTasks);
  alert(`${todayTasks.length}個のタスクを明日にコピーしました`);
  renderTasks();

  // 振動フィードバック
  if (navigator.vibrate) {
    navigator.vibrate(50);
  }
}

// ========================================
// クイック入力バー＆完了済みセクション（新UI）
// ========================================

/**
 * クイック入力バーを初期化（新UI用）
 */
function initQuickInput() {
  // Note: クイック入力フォームのイベントリスナーはevents.jsで既に設定されているため、ここでは何もしない
  // events.js の initEventListeners() 内で quickAddForm の submit イベントを設定している
  console.log('initQuickInput: Quick input already initialized in events.js');
}

/**
 * クイック入力を送信
 */
function submitQuickInput() {
  const quickInput = document.getElementById('new-quick-input');
  const title = quickInput ? quickInput.value.trim() : '';

  if (!title) {
    alert('タスク名を入力してください');
    return;
  }

  // 今日の日付を期限として設定
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayISO = new Date(today.getTime() - today.getTimezoneOffset() * 60000).toISOString();

  // タスク作成
  createTask(title, '', todayISO, null);

  // 入力フィールドをクリア
  if (quickInput) {
    quickInput.value = '';
    quickInput.focus();
  }

  // 振動フィードバック
  if (navigator.vibrate) {
    navigator.vibrate(30);
  }

  // 再レンダリング
  renderTasks();
}

/**
 * 完了済みセクションのトグル初期化（新UI用）
 */
function initCompletedToggle() {
  // Note: 完了済みセクションのトグルのイベントリスナーはevents.jsで既に設定されているため、ここでは何もしない
  // events.js の initEventListeners() 内で completedToggle のクリックイベントを設定している
  console.log('initCompletedToggle: Completed toggle already initialized in events.js');
}
```

### render-01-helpers.js

```javascript
// ========================================
// レンダリング関数
// ========================================

// グローバル変数（インライン追加中のタスク）
let addingSubtaskForTaskId = null;

// 複数選択モード用グローバル変数
let isSelectionMode = false;
let selectedTaskIds = new Set();

// 日付ごとにタスクをグループ化
function groupTasksByDate(tasks) {
  const groups = {};
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);

  tasks.forEach(task => {
    let dateKey, label;

    if (task.dueDate) {
      const dueDate = new Date(task.dueDate);
      dueDate.setHours(0, 0, 0, 0);

      // 今日、明日、昨日、それ以外で判定
      if (dueDate.getTime() === today.getTime()) {
        dateKey = 'today';
        label = '今日 ' + formatDate(task.dueDate);
      } else if (dueDate.getTime() === tomorrow.getTime()) {
        dateKey = 'tomorrow';
        label = '明日 ' + formatDate(task.dueDate);
      } else if (dueDate.getTime() === yesterday.getTime()) {
        dateKey = 'yesterday';
        label = '昨日 ' + formatDate(task.dueDate);
      } else if (dueDate < today) {
        dateKey = 'overdue_' + dueDate.getTime();
        label = formatDate(task.dueDate) + ' (期限切れ)';
      } else {
        dateKey = 'future_' + dueDate.getTime();
        label = formatDate(task.dueDate);
      }
    } else {
      dateKey = 'no_date';
      label = '期限なし';
    }

    if (!groups[dateKey]) {
      // dateObj はそのグループの日付（午前0時）を保持する。期限なしは null。
      let dateObj = null;
      if (task.dueDate) {
        dateObj = new Date(task.dueDate);
        dateObj.setHours(0, 0, 0, 0);
      }
      groups[dateKey] = { date: dateKey, label, tasks: [], sortOrder: getSortOrder(dateKey, task.dueDate), dateObj };
    }
    groups[dateKey].tasks.push(task);
  });

  // ソート順序: 期限切れ → 昨日 → 今日 → 明日 → 未来 → 期限なし
  return Object.values(groups).sort((a, b) => a.sortOrder - b.sortOrder);
}

function getSortOrder(dateKey, dueDate) {
  if (dateKey.startsWith('overdue_')) return -1000 + new Date(dueDate).getTime();
  if (dateKey === 'yesterday') return -2;
  if (dateKey === 'today') return -1;
  if (dateKey === 'tomorrow') return 0;
  if (dateKey.startsWith('future_')) return 1000 + new Date(dueDate).getTime();
  return 10000; // 期限なし
}

function formatDate(dateStr) {
  if (!dateStr) return '';
  const date = new Date(dateStr);
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const weekdays = ['日', '月', '火', '水', '木', '金', '土'];
  const weekday = weekdays[date.getDay()];
  return `${month}月${day}日 (${weekday})`;
}

// Date オブジェクトを YYYY-MM-DD 形式の文字列に変換（null 安全）
function formatDateISO(dateObj) {
  if (!dateObj) return '';
  const y = dateObj.getFullYear();
  const m = String(dateObj.getMonth() + 1).padStart(2, '0');
  const d = String(dateObj.getDate()).padStart(2, '0');
  return `${y}-${m}-${d}`;
}

// グローバルフィルター状態
let currentFilter = null; // 'urgent' | 'high-priority' | null

// グローバル検索キーワード（ハイライト表示用）
let currentSearchKeyword = '';

// ========================================
// UI バージョン判定ヘルパー
// ========================================
function isNewUIEnabled() {
  const version = localStorage.getItem('ui-version') || 'new';
  return version === 'new';
}

// ========================================
// 新タスクカード レンダリング
// ========================================

/**
 * 新タスクカード用メタ情報を作成
 */
function createNewTaskMeta(task) {
  const meta = document.createElement('div');
  meta.className = 'new-task-meta';

  // 所要時間バッジ
  if (task.duration) {
    const hours = Math.floor(task.duration / 60);
    const minutes = task.duration % 60;
    let durationText = '';
    if (hours > 0) {
      durationText = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
    } else {
      durationText = `${minutes}m`;
    }

    const durationBadge = document.createElement('span');
    durationBadge.className = 'new-duration-badge';
    durationBadge.textContent = `⏰ ${durationText}`;
    meta.appendChild(durationBadge);
  }

  // 緊急バッジ
  if (task.urgent) {
    const urgentBadge = document.createElement('span');
    urgentBadge.className = 'new-urgent-badge';
    urgentBadge.textContent = '🚨 緊急';
    meta.appendChild(urgentBadge);
  }

  return meta;
}

/**
 * 新タスクカード構造を作成
 */
```

### render-02a-task-card.js

```javascript
function createNewTaskCard(task, level = 0) {
  const card = document.createElement('div');
  card.className = 'new-task-card' + (task.isCompleted ? ' completed' : '');

  // 優先度に基づくクラスを追加
  if (task.urgent) {
    card.classList.add('urgent');
  } else if (task.priority) {
    card.classList.add(`priority-${task.priority}`);
  }

  // データ属性
  card.dataset.id = task.id;
  card.dataset.taskId = task.id;
  card.dataset.level = level;

  // チェックボックス
  const checkbox = document.createElement('input');
  checkbox.type = 'checkbox';
  checkbox.className = 'new-task-checkbox';
  checkbox.checked = task.isCompleted;
  checkbox.addEventListener('click', (e) => {
    e.stopPropagation();
    if (isSelectionMode) {
      toggleTaskSelection(task.id);
    } else {
      toggleTaskCompletion(task.id);
    }
  });
  card.appendChild(checkbox);

  // ボディ（タイトル + メタ）
  const body = document.createElement('div');
  body.className = 'new-task-body';

  const title = document.createElement('div');
  title.className = 'new-task-title';

  // 検索キーワードハイライト
  if (currentSearchKeyword && typeof window.searchFilter !== 'undefined' && typeof window.searchFilter.highlightSearchResult === 'function') {
    title.innerHTML = window.searchFilter.highlightSearchResult(task.title, currentSearchKeyword);
  } else {
    title.textContent = task.title;
  }

  body.appendChild(title);

  // メタ情報
  const meta = createNewTaskMeta(task);
  if (meta.children.length > 0) {
    body.appendChild(meta);
  }

  card.appendChild(body);

  // アクションボタングループ
  const actions = document.createElement('div');
  actions.className = 'new-task-actions';

  // サブタスク追加ボタン（未完了タスクのみ表示）
  if (!task.isCompleted && typeof canHaveSubtask === 'function' && canHaveSubtask(task.id)) {
    const addSubtaskBtn = document.createElement('button');
    addSubtaskBtn.className = 'new-task-action-btn';
    addSubtaskBtn.innerHTML = '+';
    addSubtaskBtn.title = 'サブタスクを追加';
    addSubtaskBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      if (typeof addingSubtaskForTaskId !== 'undefined' && typeof renderTasks === 'function') {
        addingSubtaskForTaskId = task.id;
        renderTasks();
      }
    });
    actions.appendChild(addSubtaskBtn);
  }

  // メニューボタン
  const menuBtn = document.createElement('button');
  menuBtn.className = 'new-task-menu-btn';
  menuBtn.innerHTML = '⋮';
  menuBtn.title = 'メニュー';
  menuBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    showTaskMenu(e, task);
  });
  actions.appendChild(menuBtn);

  card.appendChild(actions);

  // クリックで編集
  card.addEventListener('click', (e) => {
    if (!e.target.closest('.new-task-checkbox') && !e.target.closest('.new-task-menu-btn') && !e.target.closest('.new-task-action-btn')) {
      openEditModal(task.id);
    }
  });

  return card;
}

// タスクリスト表示
```

### render-02b-render-core.js

```javascript
function renderTasks() {
  const tasks = getTasks();

  // 親タスクのみを抽出（サブタスクは親タスクと一緒に表示される）
  const parentTasks = tasks.filter(t => !t.parentId);

  // 検索・フィルター・ソート機能を適用
  let filteredTasks = parentTasks;
  if (typeof window.searchFilter !== 'undefined' && typeof window.searchFilter.apply === 'function') {
    filteredTasks = window.searchFilter.apply(parentTasks);
  }

  // 完了/未完了で分離
  const activeTasks = filteredTasks.filter(t => !t.isCompleted);
  const completedTasks = filteredTasks.filter(t => t.isCompleted);

  // 検索キーワードを取得（ハイライト表示のため）
  const searchKeyword = (typeof window.searchFilter !== 'undefined' && typeof window.searchFilter.getSearchKeyword === 'function')
    ? window.searchFilter.getSearchKeyword()
    : '';

  // グローバル変数に保存（createTaskElement で使用）
  currentSearchKeyword = searchKeyword;

  // ソート設定（日付グループ内でのソートは不要になったが、互換性のため保持）
  const sortPref = (typeof window.searchFilter !== 'undefined' && typeof window.searchFilter.getCurrentSort === 'function')
    ? window.searchFilter.getCurrentSort()
    : 'time';

  // タスクタブ
  const tasksList = document.getElementById('tasks-list');
  const tasksEmpty = document.getElementById('tasks-empty');
  tasksList.innerHTML = '';

  if (activeTasks.length === 0) {
    tasksEmpty.classList.add('show');
  } else {
    tasksEmpty.classList.remove('show');

    // 日付ごとにタスクをグループ化
    const tasksByDate = groupTasksByDate(activeTasks);

    // 昨日以前（期限切れ+昨日）と今日以降に分離
    const pastGroups = tasksByDate.filter(g =>
      g.date.startsWith('overdue_') || g.date === 'yesterday'
    );
    const currentAndFutureGroups = tasksByDate.filter(g =>
      !g.date.startsWith('overdue_') && g.date !== 'yesterday'
    );

    // 昨日以前のタスクセクション
    if (pastGroups.length > 0) {
      const pastTasksCount = pastGroups.reduce((sum, g) => sum + g.tasks.length, 0);

      // 折りたたみトグルボタン（新UI/旧UIで異なるクラスを使用）
      const pastToggle = document.createElement('button');
      const useNewUI = isNewUIEnabled();
      pastToggle.className = useNewUI ? 'new-past-tasks-toggle' : 'past-tasks-toggle';
      pastToggle.id = 'past-tasks-toggle';

      // 開閉状態を localStorage から復元（デフォルトは閉じた状態）
      const isPastOpen = loadFromStorage('nowtask_past_tasks_open', false);

      const toggleIcon = document.createElement('span');
      toggleIcon.className = 'toggle-icon';
      toggleIcon.textContent = isPastOpen ? '▼' : '▶';

      const toggleText = document.createElement('span');
      toggleText.className = 'toggle-text';
      toggleText.textContent = '昨日以前のタスク';

      const pastCount = document.createElement('span');
      pastCount.className = useNewUI ? 'new-past-tasks-count' : 'past-tasks-count';
      pastCount.textContent = `(${pastTasksCount})`;

      pastToggle.appendChild(toggleIcon);
      pastToggle.appendChild(toggleText);
      pastToggle.appendChild(pastCount);

      if (isPastOpen) {
        pastToggle.classList.add('open');
      }

      tasksList.appendChild(pastToggle);

      // 昨日以前のタスクコンテンツ
      const pastContent = document.createElement('div');
      pastContent.className = useNewUI ? 'new-past-tasks-content' : 'past-tasks-content';
      pastContent.id = 'past-tasks-content';
      if (isPastOpen) {
        pastContent.classList.add('open');
      }

      // 昨日以前のグループをレンダリング
      pastGroups.forEach(({ date, label, tasks: dateTasks }) => {
        renderDateGroup(date, label, dateTasks, pastContent, sortPref);
      });

      tasksList.appendChild(pastContent);

      // トグルイベント
      pastToggle.addEventListener('click', () => {
        const isOpen = pastToggle.classList.toggle('open');
        pastContent.classList.toggle('open');
        toggleIcon.textContent = isOpen ? '▼' : '▶';
        saveToStorage('nowtask_past_tasks_open', isOpen);
      });
    }

    // 今日以降のタスクをレンダリング
    currentAndFutureGroups.forEach(({ date, label, tasks: dateTasks }) => {
      renderDateGroup(date, label, dateTasks, tasksList, sortPref);
    });
  }

  // 完了済みセクション
  const completedList = document.getElementById('completed-list');
  const completedCount = document.getElementById('completed-count');
  const completedSection = document.getElementById('completed-section');
  completedList.innerHTML = '';

  // 完了済みタスクの総数を計算
  let totalCompleted = completedTasks.length;
  completedTasks.forEach(task => {
    const subtasks = getSubtasks(task.id);
    totalCompleted += subtasks.filter(st => st.isCompleted).length;
  });

  if (totalCompleted === 0) {
    completedSection.style.display = 'none';
  } else {
    completedSection.style.display = 'block';
    completedCount.textContent = `(${totalCompleted})`;

    completedTasks.forEach(task => {
      renderTaskWithSubtasks(task, completedList, true);
    });
  }

  // 24時間ゲージ更新
  updateTimeGauge();
}

// セクションラベルをレンダリング（新UI対応）
function renderSectionLabel(dateKey, label) {
  const sectionDiv = document.createElement('div');

  if (isNewUIEnabled()) {
    // 新UI: セクションラベル + 追加ボタン
    sectionDiv.className = 'new-section-label';
    sectionDiv.dataset.date = dateKey;

    const title = document.createElement('span');
    title.className = 'new-section-title';
    title.textContent = label;
    sectionDiv.appendChild(title);

    const addBtn = document.createElement('button');
    addBtn.className = 'new-section-add-btn';
    addBtn.innerHTML = '+';
    addBtn.dataset.date = dateKey;
    addBtn.title = 'タスク追加';
    sectionDiv.appendChild(addBtn);
  } else {
    // 旧UI: 従来の日付セパレーター
    sectionDiv.className = 'date-separator';
    sectionDiv.dataset.date = dateKey;
    sectionDiv.innerHTML = `
      <div class="date-separator-line"></div>
      <div class="date-separator-label">${label}</div>
      <div class="date-separator-line"></div>
    `;
  }

  return sectionDiv;
}

// 日付グループをレンダリング（共通関数）
```

### render-02c-date-section.js

```javascript
function renderDateGroup(date, label, dateTasks, container, sortPref) {
  // 各日付グループ内でソートを適用
  if (sortPref === 'time') {
    dateTasks.sort((a, b) => {
      // 期限なしは末尾に回す
      if (!a.dueDate && !b.dueDate) return 0;
      if (!a.dueDate) return 1;
      if (!b.dueDate) return -1;
      return new Date(a.dueDate) - new Date(b.dueDate);
    });
  } else if (sortPref === 'created') {
    // 追加順: createdAt の降順（新しいものを上に）
    dateTasks.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
  } else if (sortPref === 'priority') {
    // 優先順位順: 緊急 > 高 > 中 > 低 > 未設定
    const priorityOrder = { high: 1, medium: 2, low: 3, '': 4 };
    dateTasks.sort((a, b) => {
      // 緊急フラグを最優先
      if (a.urgent && !b.urgent) return -1;
      if (!a.urgent && b.urgent) return 1;
      // 優先度で比較
      const aPriority = priorityOrder[a.priority || ''] || 4;
      const bPriority = priorityOrder[b.priority || ''] || 4;
      return aPriority - bPriority;
    });
  }

  // セクションラベルのレンダリング
  const sectionLabel = renderSectionLabel(date, label);
  container.appendChild(sectionLabel);

  // タスクをレンダリング
  dateTasks.forEach(task => {
    renderTaskWithSubtasks(task, container, false);
  });

  // 明日のタスクの場合、追加ボタンを表示
  if (date === 'tomorrow') {
    const addTomorrowBtn = document.createElement('button');
    addTomorrowBtn.className = 'add-tomorrow-task-btn';
    addTomorrowBtn.innerHTML = '+ 明日のタスクを追加';
    addTomorrowBtn.addEventListener('click', () => {
      // 明日の日付を設定してモーダルを開く
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      const tomorrowISO = formatDateISO(tomorrow);
      openCreateModal();
      // モーダルが開いた後に日付を設定
      setTimeout(() => {
        document.getElementById('task-due-date').value = tomorrowISO;
      }, 0);
    });
    container.appendChild(addTomorrowBtn);
  }
}

// タスクとサブタスクを再帰的にレンダリング
function renderTaskWithSubtasks(task, container, isCompletedSection) {
  const level = getTaskLevel(task.id);

  // タスク要素を作成
  container.appendChild(createTaskElement(task, level));

  // サブタスクを再帰的に表示
  const subtasks = getSubtasks(task.id);
  subtasks.forEach(subtask => {
    // 完了状態によってフィルタリング
    if (isCompletedSection) {
      if (subtask.isCompleted) {
        renderTaskWithSubtasks(subtask, container, true);
      }
    } else {
      if (!subtask.isCompleted) {
        renderTaskWithSubtasks(subtask, container, false);
      }
    }
  });

  // インライン入力中の場合
  if (addingSubtaskForTaskId === task.id) {
    const inputDiv = createSubtaskInputInline(task.id, level);
    container.appendChild(inputDiv);
  }
}

// タスク要素作成
```

### render-02d-task-element.js

```javascript
function createTaskElement(task, level = 0) {
  // 新UI有効時は新タスクカード構造を使用
  if (isNewUIEnabled() && level === 0) {
    // 親タスクのみ新構造を使用（サブタスクは旧構造）
    const card = createNewTaskCard(task, level);

    // ドラッグ&ドロップ機能を追加
    setupDragAndDrop(card, task);

    return card;
  }

  // 旧UI（デフォルト）
  const div = document.createElement('div');
  div.className = 'task-item' + (task.isCompleted ? ' completed' : '') + (task.isTutorial ? ' tutorial' : '');
  if (level > 0) {
    div.classList.add('subtask');
    div.classList.add(`level-${level}`);
  }
  if (isSelectionMode && selectedTaskIds.has(task.id)) {
    div.classList.add('selected');
  }
  div.dataset.id = task.id;
  div.dataset.taskId = task.id;
  div.dataset.level = level;

  // 選択モード時の選択チェックボックス
  if (isSelectionMode) {
    const selectCheckbox = document.createElement('input');
    selectCheckbox.type = 'checkbox';
    selectCheckbox.className = 'task-select-checkbox';
    selectCheckbox.checked = selectedTaskIds.has(task.id);
    selectCheckbox.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleTaskSelection(task.id);
    });
    div.appendChild(selectCheckbox);
  }

  // チェックボックス
  const checkbox = document.createElement('input');
  checkbox.type = 'checkbox';
  checkbox.className = 'task-checkbox';
  checkbox.checked = task.isCompleted;
  checkbox.addEventListener('click', (e) => {
    e.stopPropagation();
    if (isSelectionMode) {
      toggleTaskSelection(task.id);
    } else {
      toggleTaskCompletion(task.id);
    }
  });

  // コンテンツ部分
  const content = document.createElement('div');
  content.className = 'task-content';

  const title = document.createElement('div');
  title.className = 'task-title';

  // 検索キーワードがある場合はハイライト表示
  if (currentSearchKeyword && typeof window.searchFilter !== 'undefined' && typeof window.searchFilter.highlightSearchResult === 'function') {
    title.innerHTML = window.searchFilter.highlightSearchResult(task.title, currentSearchKeyword);
  } else {
    title.textContent = task.title;
  }

  content.appendChild(title);

  // メタ情報
  const meta = document.createElement('div');
  meta.className = 'task-meta';

  // 緊急ラベル
  if (task.urgent) {
    const urgentLabel = document.createElement('span');
    urgentLabel.className = 'task-urgent-label';
    urgentLabel.textContent = '🚨 緊急';
    meta.appendChild(urgentLabel);
  }

  // 優先順位ラベル
  if (task.priority) {
    const priorityLabel = document.createElement('span');
    priorityLabel.className = `task-priority-label ${task.priority}`;
    const priorityText = {
      high: '優先度: 高',
      medium: '優先度: 中',
      low: '優先度: 低'
    };
    priorityLabel.textContent = priorityText[task.priority] || '';
    meta.appendChild(priorityLabel);
  }

  // 開始時刻・終了時刻
  if (task.startTime || task.endTime) {
    const timeSpan = document.createElement('span');
    timeSpan.className = 'task-duration';
    if (task.startTime && task.endTime) {
      timeSpan.textContent = `🕒 ${task.startTime} ~ ${task.endTime}`;
    } else if (task.startTime) {
      timeSpan.textContent = `🕒 ${task.startTime} ~`;
    } else if (task.endTime) {
      timeSpan.textContent = `🕒 ~ ${task.endTime}`;
    }
    meta.appendChild(timeSpan);
  }

  // サブタスク数表示（子タスクを持つ場合）
  const subtasks = getSubtasks(task.id);
  if (subtasks.length > 0) {
    // 折りたたみトグル（サブタスクを持つ親タスクに表示）
    const collapseToggle = document.createElement('button');
    collapseToggle.className = 'collapse-toggle';
    collapseToggle.title = 'サブタスクを折りたたむ/展開する';
    // 初期は展開状態
    collapseToggle.textContent = '▼';
    // data 属性で開閉状態を管理
    div.dataset.collapsed = 'false';

    collapseToggle.addEventListener('click', (e) => {
      // モーダルや編集イベントを発火させない
      e.stopPropagation();
      const parentLevel = Number(div.dataset.level || 0);
      const isCollapsed = div.dataset.collapsed === 'true';

      // トグル表示
      div.dataset.collapsed = isCollapsed ? 'false' : 'true';
      collapseToggle.textContent = isCollapsed ? '▼' : '▶';

      // 親要素の次の兄弟要素から探索し、親より深いレベルの要素を隠す/表示する
      let sibling = div.nextElementSibling;
      while (sibling) {
        const siblingLevel = Number(sibling.dataset.level || 0);
        // 親より深ければサブタスクとみなす
        if (siblingLevel > parentLevel) {
          if (div.dataset.collapsed === 'true') {
            sibling.classList.add('subtask-hidden');
          } else {
            sibling.classList.remove('subtask-hidden');
          }
        } else {
          // 同レベルかそれ以下に到達したらサブタスク列の終端
          break;
        }
        sibling = sibling.nextElementSibling;
      }
    });

    meta.appendChild(collapseToggle);

    const subtaskCount = document.createElement('span');
    subtaskCount.className = 'subtask-count';
    const completedCount = subtasks.filter(st => st.isCompleted).length;
    subtaskCount.textContent = `📋 ${completedCount}/${subtasks.length}`;
    meta.appendChild(subtaskCount);
  }
```

### render-02e-subtask-input.js

```javascript

  // 所要時間表示
  if (task.duration) {
    const durationSpan = document.createElement('span');
    durationSpan.className = 'task-duration';
    const hours = Math.floor(task.duration / 60);
    const minutes = task.duration % 60;
    if (hours > 0) {
      durationSpan.textContent = minutes > 0 ? `⏰ ${hours}時間${minutes}分` : `⏰ ${hours}時間`;
    } else {
      durationSpan.textContent = `⏰ ${minutes}分`;
    }
    meta.appendChild(durationSpan);
  }

  // 時間ゲージバー（開始時刻と終了時刻がある場合）
  if (task.startTime && task.endTime && !task.isCompleted) {
    const [startHour, startMin] = task.startTime.split(':').map(Number);
    const [endHour, endMin] = task.endTime.split(':').map(Number);
    const startMinutes = startHour * 60 + startMin;
    let endMinutes = endHour * 60 + endMin;

    // 日をまたぐ場合は24時までとして計算
    if (endMinutes < startMinutes) {
      endMinutes = 24 * 60;
    }

    const duration = endMinutes - startMinutes;
    const leftPercent = (startMinutes / (24 * 60)) * 100;
    const widthPercent = (duration / (24 * 60)) * 100;

    const gaugeWrapper = document.createElement('div');
    gaugeWrapper.className = 'task-time-gauge-wrapper';

    const gauge = document.createElement('div');
    gauge.className = 'task-time-gauge';

    const gaugeBg = document.createElement('div');
    gaugeBg.className = 'task-time-gauge-bg';

    const gaugeBar = document.createElement('div');
    gaugeBar.className = 'task-time-gauge-bar';
    gaugeBar.style.left = `${leftPercent}%`;
    gaugeBar.style.width = `${widthPercent}%`;

    gauge.appendChild(gaugeBg);
    gauge.appendChild(gaugeBar);
    gaugeWrapper.appendChild(gauge);
    content.appendChild(gaugeWrapper);
  }

  if (task.dueDate) {
    const dueDate = document.createElement('span');
    dueDate.className = 'task-due-date';
    if (isOverdue(task.dueDate) && !task.isCompleted) {
      dueDate.classList.add('overdue');
    }
    dueDate.textContent = '📅 ' + formatDate(task.dueDate);
    meta.appendChild(dueDate);
  }

  if (task.totalTime > 0 || task.isTimerRunning) {
    const timer = document.createElement('span');
    timer.className = 'task-timer';
    if (task.isTimerRunning) {
      timer.classList.add('running');
      timer.textContent = '⏱️ 計測中...';
    } else {
      timer.textContent = '⏱️ ' + formatTime(task.totalTime);
    }
    meta.appendChild(timer);
  }

  if (meta.children.length > 0) {
    content.appendChild(meta);
  }

  if (task.memo) {
    const memo = document.createElement('div');
    memo.className = 'task-memo';

    // メモを100文字に制限
    const memoText = task.memo.substring(0, 100) + (task.memo.length > 100 ? '...' : '');

    // 検索キーワードがある場合はハイライト表示
    if (currentSearchKeyword && typeof window.searchFilter !== 'undefined' && typeof window.searchFilter.highlightSearchResult === 'function') {
      memo.innerHTML = window.searchFilter.highlightSearchResult(memoText, currentSearchKeyword);
    } else {
      memo.textContent = memoText;
    }

    content.appendChild(memo);
  }

  div.appendChild(checkbox);
  div.appendChild(content);

  // タスクアクション部分
  const actions = document.createElement('div');
  actions.className = 'task-card-actions';

  // 時間記録停止ボタン（タイマー実行中のみ表示）
  if (task.isTimerRunning) {
    const stopBtn = document.createElement('button');
    stopBtn.className = 'timer-stop-btn';
    stopBtn.innerHTML = '⏹';
    stopBtn.title = '時間記録停止';
    stopBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      stopTaskTimer(task.id);
      renderTasks();
    });
    actions.appendChild(stopBtn);
  }

  // サブタスク追加ボタン（タスク内に表示）
  if (!task.isCompleted && canHaveSubtask(task.id)) {
    const addSubtaskIcon = document.createElement('button');
    addSubtaskIcon.className = 'add-subtask-icon';
    addSubtaskIcon.innerHTML = '+';
    addSubtaskIcon.title = 'サブタスクを追加';
    addSubtaskIcon.addEventListener('click', (e) => {
      e.stopPropagation();
      addingSubtaskForTaskId = task.id;
      renderTasks();
    });
    actions.appendChild(addSubtaskIcon);
  }

  // メニューボタン
  const menuBtn = document.createElement('button');
  menuBtn.className = 'task-menu-btn';
  menuBtn.innerHTML = '⋮';
  menuBtn.title = 'メニュー';
  menuBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    showTaskMenu(e, task);
  });
  actions.appendChild(menuBtn);

  div.appendChild(actions);

  // カード全体のクリックで編集（チェックボックスとボタン以外）
  div.addEventListener('click', (e) => {
    if (!e.target.closest('.task-checkbox') && !e.target.closest('.task-card-actions')) {
      openEditModal(task.id);
    }
  });

  // ドラッグ&ドロップ機能
  setupDragAndDrop(div, task);

  return div;
}

// インラインサブタスク入力作成
function createSubtaskInputInline(parentId, parentLevel = 0) {
```

### render-03a-subtask-input.js

```javascript
function createSubtaskInputInline(parentId, parentLevel = 0) {
  const div = document.createElement('div');
  div.className = 'subtask-input-inline';
  div.classList.add(`level-${parentLevel + 1}`);

  const input = document.createElement('input');
  input.type = 'text';
  input.placeholder = 'サブタスク名を入力';
  input.maxLength = 100;

  const saveInlineSubtask = () => {
    const title = input.value.trim();
    if (title) {
      createTask(title, '', null, parentId);
    }
    addingSubtaskForTaskId = null;
    renderTasks();
  };

  input.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      saveInlineSubtask();
    }
  });

  input.addEventListener('blur', () => {
    setTimeout(() => {
      addingSubtaskForTaskId = null;
      renderTasks();
    }, 200);
  });

  div.appendChild(input);

  // 自動フォーカス
  setTimeout(() => input.focus(), 0);

  return div;
}

// ========================================
// ドラッグ&ドロップ機能
// ========================================
let draggedElement = null;
let longPressTimer = null;
let isDragging = false;
let dragStartX = 0;
let dragStartLevel = 0;
let currentDragLevel = 0;

// スワイプジェスチャー用の変数
let isSwiping = false;
let swipeDirection = null; // 'left' | 'right' | null

```

### render-03b-drag-events.js

```javascript
function setupDragAndDrop(element, task) {
  let startY = 0;
  let startX = 0;
  let swipeStartTime = 0;
  let hasMoved = false; // ドラッグで実際に移動したかどうか
  let dragDistance = 0; // ドラッグした距離
  let longPressTouchX = 0; // 長押し時のタッチ位置X
  let longPressTouchY = 0; // 長押し時のタッチ位置Y

  // タッチデバイス用の長押し検出
  element.addEventListener('touchstart', (e) => {
    // チェックボックスやボタンの場合は無視
    if (e.target.closest('.task-checkbox') || e.target.closest('.task-card-actions') ||
        e.target.closest('.new-task-checkbox') || e.target.closest('.new-task-menu-btn')) {
      return;
    }

    const touch = e.touches[0];
    startY = touch.clientY;
    startX = touch.clientX;
    longPressTouchX = touch.clientX;
    longPressTouchY = touch.clientY;
    swipeStartTime = Date.now();
    isSwiping = false;
    swipeDirection = null;
    hasMoved = false;
    dragDistance = 0;

    // 500ms長押しでコンテキストメニュー表示
    longPressTimer = setTimeout(() => {
      if (!isSwiping) {
        // 振動フィードバック（対応デバイスのみ）
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }

        // コンテキストメニューを表示
        showTaskMenuFromLongPress(longPressTouchX, longPressTouchY, task);

        // 長押しタイマーをクリア
        longPressTimer = null;
      }
    }, 500);
  });

  element.addEventListener('touchmove', (e) => {
    const touch = e.touches[0];
    const moveY = Math.abs(touch.clientY - startY);
    const moveX = touch.clientX - startX;
    const moveXAbs = Math.abs(moveX);

    // スワイプジェスチャー判定（水平方向の移動が垂直方向より大きい場合）
    if (!isDragging && !isSwiping && moveXAbs > 25 && moveXAbs > moveY * 1.5) {
      // 長押しタイマーをキャンセル
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }

      isSwiping = true;
      element.classList.add('swiping');

      // 振動フィードバック
      if (navigator.vibrate) {
        navigator.vibrate(10);
      }
    }

    // スワイプ中の視覚的フィードバック
    if (isSwiping) {
      e.preventDefault(); // 画面スクロールを防止
      e.stopPropagation(); // イベント伝播を停止

      // 真ん中のキャンセルゾーン（±15px以内）
      const CANCEL_ZONE = 15;

      if (moveXAbs <= CANCEL_ZONE) {
        // キャンセルゾーン内：どの方向のスタイルも外す
        swipeDirection = null;
        element.classList.remove('swiping-left', 'swiping-right');
      } else {
        // キャンセルゾーン外：スワイプ方向を判定
        if (moveX > CANCEL_ZONE) {
          swipeDirection = 'right';
          element.classList.remove('swiping-left');
          element.classList.add('swiping-right');
        } else if (moveX < -CANCEL_ZONE) {
          swipeDirection = 'left';
          element.classList.remove('swiping-right');
          element.classList.add('swiping-left');
        }
      }
    }
    // ドラッグ&ドロップ中の処理
    else if (isDragging && draggedElement) {
      e.preventDefault();

      // 移動距離を計算（50px以上移動したら実際に移動したとみなす）
      const totalMoveY = Math.abs(touch.clientY - startY);
      const totalMoveX = Math.abs(touch.clientX - startX);
      dragDistance = Math.max(totalMoveY, totalMoveX);

      if (dragDistance > 50 && !hasMoved) {
        hasMoved = true; // 50px以上移動したら移動判定
        console.log('Drag moved more than 50px - will save position');
      }

      // 水平方向のドラッグで階層を変更
      const deltaX = touch.clientX - dragStartX;
      const indentSize = 40; // 1階層のインデント幅（px）
      const levelChange = Math.floor(deltaX / indentSize);
      const newLevel = Math.max(0, Math.min(4, dragStartLevel + levelChange));

      // レベルが変更された場合、視覚的なフィードバックを提供
      if (newLevel !== currentDragLevel) {
        currentDragLevel = newLevel;
        draggedElement.dataset.level = newLevel;
        // 既存クラスを保持しながらdraggingを追加
        draggedElement.classList.add('dragging');
        // 旧レベルのクラスを削除
        for (let i = 0; i <= 4; i++) {
          draggedElement.classList.remove(`level-${i}`);
        }
        if (newLevel > 0) {
          draggedElement.classList.add('subtask');
          draggedElement.classList.add(`level-${newLevel}`);
        } else {
          draggedElement.classList.remove('subtask');
        }
        // 振動フィードバック
        if (navigator.vibrate) {
          navigator.vibrate(20);
        }
      }

      const afterElement = getDragAfterElement(element.parentElement, touch.clientY);

      if (afterElement == null) {
        element.parentElement.appendChild(draggedElement);
      } else {
        element.parentElement.insertBefore(draggedElement, afterElement);
      }
    }
    // 水平方向の動きを検出したら早めにスクロールを防止
    else if (!isDragging && moveXAbs > 10 && moveXAbs > moveY) {
      e.preventDefault(); // 横方向の動きが優位なら画面スクロールを防止
    }

    // 長押しタイマーをキャンセル（20px以上動いた場合）
    if (longPressTimer && (moveY > 20 || moveXAbs > 20)) {
      if (!isSwiping) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    }
  });

  element.addEventListener('touchend', (e) => {
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }

    // スワイプジェスチャーの処理
    if (isSwiping) {
      e.preventDefault();
```

### render-03c-drag-handlers.js

```javascript

      const touch = e.changedTouches[0];
      const moveX = touch.clientX - startX;
      const swipeDuration = Date.now() - swipeStartTime;
      const CANCEL_ZONE = 15;

      // スワイプ判定（キャンセルゾーン外 かつ 1000ms以内）
      if (Math.abs(moveX) > CANCEL_ZONE && swipeDuration < 1000 && swipeDirection) {
        if (swipeDirection === 'right') {
          // 右スワイプ: タスク完了/未完了トグル
          handleSwipeRight(task.id, element);
        } else if (swipeDirection === 'left') {
          // 左スワイプ: タスク削除
          handleSwipeLeft(task.id, element);
        }
      } else {
        // キャンセルゾーン内またはスワイプ不十分な場合、元に戻す
        element.classList.add('swipe-reset');
        setTimeout(() => {
          element.classList.remove('swiping', 'swiping-right', 'swiping-left', 'swipe-reset');
        }, 300);
      }

      isSwiping = false;
      swipeDirection = null;
    }
    // ドラッグ&ドロップの終了処理
    else if (isDragging && draggedElement) {
      e.preventDefault();
      element.classList.remove('dragging');

      console.log(`touchend - isDragging: true, hasMoved: ${hasMoved}, dragDistance: ${dragDistance}px`);

      // 実際に移動した場合のみ新しい順序を保存
      if (hasMoved) {
        console.log('Saving new task order (moved > 50px)');
        saveNewTaskOrder();
      } else {
        console.log('NOT saving - drag distance too small');
      }

      isDragging = false;
      draggedElement = null;
      dragStartX = 0;
      dragStartLevel = 0;
      currentDragLevel = 0;
      hasMoved = false;
      dragDistance = 0;
    }
  });

  // MIUIなどのシステムがタッチをキャンセルした場合の処理
  element.addEventListener('touchcancel', (e) => {
    console.log(`touchcancel - isDragging: ${isDragging}, hasMoved: ${hasMoved}, dragDistance: ${dragDistance}px`);

    if (longPressTimer) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }

    // スワイプ中の場合はリセット
    if (isSwiping) {
      element.classList.add('swipe-reset');
      setTimeout(() => {
        element.classList.remove('swiping', 'swiping-right', 'swiping-left', 'swipe-reset');
      }, 300);
      isSwiping = false;
      swipeDirection = null;
    }

    // ドラッグ中の場合もリセット（保存しない）
    if (isDragging && draggedElement) {
      element.classList.remove('dragging');

      // touchcancelの場合は絶対に保存しない
      console.log('Touch cancelled by system - FORCING not to save position');

      isDragging = false;
      draggedElement = null;
      dragStartX = 0;
      dragStartLevel = 0;
      currentDragLevel = 0;
      hasMoved = false;
      dragDistance = 0;

      // 再レンダリングして元の状態に戻す
      renderTasks();
    }
  });

  // PC用のドラッグ&ドロップ
  element.setAttribute('draggable', 'true');

  element.addEventListener('dragstart', (e) => {
    // チェックボックスやボタンの場合は無視
    if (e.target.closest('.task-checkbox') || e.target.closest('.task-card-actions') ||
        e.target.closest('.new-task-checkbox') || e.target.closest('.new-task-menu-btn')) {
      e.preventDefault();
      return;
    }

    draggedElement = element;
    dragStartX = e.clientX;
    dragStartLevel = Number(element.dataset.level || 0);
    currentDragLevel = dragStartLevel;
    element.classList.add('dragging');
  });

  element.addEventListener('drag', (e) => {
    if (e.clientX === 0 && e.clientY === 0) return; // ドラッグ終了時のイベントを無視

    // 水平方向のドラッグで階層を変更
    const deltaX = e.clientX - dragStartX;
    const indentSize = 40; // 1階層のインデント幅（px）
    const levelChange = Math.floor(deltaX / indentSize);
    const newLevel = Math.max(0, Math.min(4, dragStartLevel + levelChange));

    // レベルが変更された場合、視覚的なフィードバックを提供
    if (newLevel !== currentDragLevel) {
      currentDragLevel = newLevel;
      draggedElement.dataset.level = newLevel;
      // 既存クラスを保持しながらdraggingを追加
      draggedElement.classList.add('dragging');
      // 旧レベルのクラスを削除
      for (let i = 0; i <= 4; i++) {
        draggedElement.classList.remove(`level-${i}`);
      }
      if (newLevel > 0) {
        draggedElement.classList.add('subtask');
        draggedElement.classList.add(`level-${newLevel}`);
      } else {
        draggedElement.classList.remove('subtask');
      }
    }
  });

  element.addEventListener('dragend', () => {
    console.log('dragend event fired');
    element.classList.remove('dragging');

    // 新しい順序を保存（ガードがあるので安全）
    saveNewTaskOrder();

    draggedElement = null;
    dragStartX = 0;
    dragStartLevel = 0;
    currentDragLevel = 0;
  });

  element.addEventListener('dragover', (e) => {
    e.preventDefault();
    const afterElement = getDragAfterElement(element.parentElement, e.clientY);

    if (draggedElement && draggedElement !== element) {
      if (afterElement == null) {
        element.parentElement.appendChild(draggedElement);
      } else {
        element.parentElement.insertBefore(draggedElement, afterElement);
      }
    }
  });
}

```

### render-03d-drag-utils.js

```javascript
function getDragAfterElement(container, y) {
  // 旧カード（.task-item）と新カード（.new-task-card）の両方を選択
  const draggableElements = [...container.querySelectorAll('.task-item:not(.dragging), .new-task-card:not(.dragging)')];

  return draggableElements.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;

    if (offset < 0 && offset > closest.offset) {
      return { offset: offset, element: child };
    } else {
      return closest;
    }
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function saveNewTaskOrder() {
  // ガード: ドラッグ中でない場合は保存しない
  if (!isDragging && !draggedElement) {
    console.log('saveNewTaskOrder called but not dragging - BLOCKING SAVE');
    return;
  }

  const tasks = getTasks();
  // 旧カード（.task-item）と新カード（.new-task-card）の両方を選択
  const taskElements = document.querySelectorAll('.task-item:not(.completed), .new-task-card:not(.completed)');

  // 新しい順序とレベルでタスクIDを取得
  const newOrder = [];
  taskElements.forEach(el => {
    const taskId = el.dataset.taskId;
    if (taskId) {
      newOrder.push({
        id: taskId,
        level: Number(el.dataset.level || 0)
      });
    }
  });

  // ドラッグされたタスクの新しい親を決定
  const draggedTaskId = draggedElement ? draggedElement.dataset.taskId : null;
  if (draggedTaskId) {
    const draggedIndex = newOrder.findIndex(item => item.id === draggedTaskId);
    if (draggedIndex !== -1) {
      const draggedLevel = newOrder[draggedIndex].level;
      let newParentId = null;

      // ドラッグされたタスクの直前のタスクを探す
      for (let i = draggedIndex - 1; i >= 0; i--) {
        const prevTask = newOrder[i];

        // 同じレベルの場合は、同じ親を持つ
        if (prevTask.level === draggedLevel) {
          const prevTaskData = getTaskById(prevTask.id);
          newParentId = prevTaskData ? prevTaskData.parentId : null;
          break;
        }
        // 1つ浅いレベルの場合は、そのタスクを親とする
        else if (prevTask.level === draggedLevel - 1) {
          newParentId = prevTask.id;
          break;
        }
        // より浅いレベルの場合は、そのレベルまで戻って親を探す
        else if (prevTask.level < draggedLevel - 1) {
          const prevTaskData = getTaskById(prevTask.id);
          newParentId = prevTaskData ? prevTaskData.parentId : null;
          break;
        }
      }

      // バリデーション: 新しい親が有効かチェック
      const draggedTask = getTaskById(draggedTaskId);
      let isValidParent = true;

      if (newParentId) {
        // 1. サブタスクを持つタスクは他のタスクのサブタスクにできない
        const draggedSubtasks = getSubtasks(draggedTaskId);
        if (draggedSubtasks.length > 0) {
          // 新しい親が設定される場合（独立タスクからサブタスクになる場合）
          const newParentLevel = getTaskLevel(newParentId);
          if (newParentLevel + draggedSubtasks.length + 1 > 4) {
            isValidParent = false;
          }
        }

        // 2. 5階層制限のチェック
        const newParentLevel = getTaskLevel(newParentId);
        if (newParentLevel >= 4) {
          isValidParent = false;
        }

        // 3. 自分自身や自分の子孫を親にできない
        let ancestor = newParentId;
        while (ancestor) {
          if (ancestor === draggedTaskId) {
            isValidParent = false;
            break;
          }
          const ancestorTask = getTaskById(ancestor);
          ancestor = ancestorTask ? ancestorTask.parentId : null;
        }
      }

      // ドラッグされたタスクの親IDを更新
      if (draggedTask && draggedTask.parentId !== newParentId && isValidParent) {
        updateTask(draggedTaskId, { parentId: newParentId });

        // 元の親タスクの時間を再集計
        if (draggedTask.parentId && typeof aggregateSubtaskTimes === 'function') {
          aggregateSubtaskTimes(draggedTask.parentId);
        }
        // 新しい親タスクの時間を集計
        if (newParentId && typeof aggregateSubtaskTimes === 'function') {
          aggregateSubtaskTimes(newParentId);
        }
      } else if (!isValidParent) {
        // 無効な親の場合は元のレベルに戻す
        console.warn('Invalid parent: Cannot create this hierarchy');
      }

      // 日付を跨ぐドラッグ: ドラッグされたタスクの日付を更新
      // ドラッグされたタスクの直前の日付セパレーターを見つける
      const draggedTaskElement = draggedElement;
      if (draggedTaskElement && draggedTask && draggedLevel === 0) {
        // レベル0（親タスク）の場合のみ日付変更を許可
        let currentElement = draggedTaskElement.previousElementSibling;
        let nearestDateSeparator = null;

        // 直前の日付セパレーターを探す
        while (currentElement) {
          if (currentElement.classList.contains('date-separator')) {
            nearestDateSeparator = currentElement;
            break;
          }
          currentElement = currentElement.previousElementSibling;
        }

        if (nearestDateSeparator) {
          const newDateISO = nearestDateSeparator.dataset.date;
          if (newDateISO) {
            // 新しい日付を設定（ISO形式: YYYY-MM-DD）
            const newDueDate = new Date(newDateISO + 'T00:00:00').toISOString();
            if (draggedTask.dueDate !== newDueDate) {
              updateTask(draggedTaskId, { dueDate: newDueDate });
            }
          } else if (newDateISO === '') {
            // 期限なしセクションにドラッグされた場合
            if (draggedTask.dueDate) {
              updateTask(draggedTaskId, { dueDate: null });
            }
          }
        }
      }
    }
  }

  // タスクの順序を更新（customOrder フィールドを追加）
  tasks.forEach((task, index) => {
    const newIndex = newOrder.findIndex(item => item.id === task.id);
    if (newIndex !== -1) {
      task.customOrder = newIndex;
    }
  });

  // 保存
  saveTasks(tasks);

  // 再レンダリング
  renderTasks();
}

// ========================================
```

### render-04-interactions.js

```javascript
// ========================================
// スワイプジェスチャーハンドラー
// ========================================

/**
 * 右スワイプ: タスク完了/未完了トグル
 */
function handleSwipeRight(taskId, element) {
  const task = getTaskById(taskId);
  if (!task) return;

  // 完了状態をトグル
  const newCompletedState = !task.isCompleted;
  updateTask(taskId, { isCompleted: newCompletedState });

  // 振動フィードバック
  if (navigator.vibrate) {
    navigator.vibrate(30);
  }

  // アニメーションでフェードアウト
  element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
  element.style.opacity = '0';
  element.style.transform = 'translateX(100px)';

  // 300ms後に再レンダリング
  setTimeout(() => {
    renderTasks();
  }, 300);
}

/**
 * 左スワイプ: タスク削除
 */
function handleSwipeLeft(taskId, element) {
  const task = getTaskById(taskId);
  if (!task) return;

  // 確認ダイアログを表示
  const confirmDelete = confirm(`「${task.title}」を削除してもよろしいですか？`);

  if (confirmDelete) {
    // 振動フィードバック
    if (navigator.vibrate) {
      navigator.vibrate([20, 50, 20]);
    }

    // アニメーションでフェードアウト
    element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
    element.style.opacity = '0';
    element.style.transform = 'translateX(-100px)';

    // 300ms後にタスクを削除して再レンダリング
    setTimeout(() => {
      deleteTask(taskId);
      renderTasks();
    }, 300);
  } else {
    // キャンセルした場合は元に戻す
    element.classList.add('swipe-reset');
    setTimeout(() => {
      element.classList.remove('swiping', 'swiping-left', 'swipe-reset');
    }, 300);
  }
}

// ========================================
// タスクメニュー
// ========================================

/**
 * 長押しからコンテキストメニューを表示
 */
function showTaskMenuFromLongPress(touchX, touchY, task) {
  // 既存のメニューを削除
  const existingMenu = document.querySelector('.task-context-menu');
  if (existingMenu) {
    existingMenu.remove();
  }

  // メニューを作成
  const menu = createTaskMenuElement(task);

  // メニューの位置を設定（タッチ位置の下に表示）
  menu.style.position = 'fixed';

  // 画面サイズを取得
  const windowWidth = window.innerWidth;
  const windowHeight = window.innerHeight;

  // メニューを一時的に表示して高さを取得
  menu.style.visibility = 'hidden';
  document.body.appendChild(menu);
  const menuHeight = menu.offsetHeight;
  const menuWidth = menu.offsetWidth;

  // 位置を計算（画面外に出ないように調整）
  let top = touchY + 10;
  let left = touchX - menuWidth / 2;

  // 下にはみ出る場合は上に表示
  if (top + menuHeight > windowHeight) {
    top = touchY - menuHeight - 10;
  }

  // 左にはみ出る場合
  if (left < 10) {
    left = 10;
  }

  // 右にはみ出る場合
  if (left + menuWidth > windowWidth - 10) {
    left = windowWidth - menuWidth - 10;
  }

  menu.style.top = `${top}px`;
  menu.style.left = `${left}px`;
  menu.style.visibility = 'visible';

  // メニュー外をタップで閉じる
  setTimeout(() => {
    document.addEventListener('click', function closeMenu(e) {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    });

    // タッチイベントでも閉じる
    document.addEventListener('touchstart', function closeTouchMenu(e) {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('touchstart', closeTouchMenu);
      }
    });
  }, 0);
}

/**
 * ボタンクリックからコンテキストメニューを表示
 */
function showTaskMenu(event, task) {
  // 既存のメニューを削除
  const existingMenu = document.querySelector('.task-context-menu');
  if (existingMenu) {
    existingMenu.remove();
  }

  // メニューを作成
  const menu = createTaskMenuElement(task);

  // メニューの位置を設定
  const rect = event.target.getBoundingClientRect();
  menu.style.position = 'fixed';
  menu.style.top = `${rect.bottom + 5}px`;
  menu.style.left = `${rect.left}px`;

  document.body.appendChild(menu);

  // メニュー外をクリックで閉じる
  setTimeout(() => {
    document.addEventListener('click', function closeMenu(e) {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    });
  }, 0);
}

/**
 * タスクメニュー要素を作成（共通関数）
 */
function createTaskMenuElement(task) {
  const menu = document.createElement('div');
  menu.className = 'task-context-menu';

  // 編集ボタン
  const editItem = document.createElement('div');
  editItem.className = 'menu-item';
  editItem.textContent = '✏️ 編集';
  editItem.addEventListener('click', () => {
    openEditModal(task.id);
    menu.remove();
  });
  menu.appendChild(editItem);

  // 移動ボタン
  const moveItem = document.createElement('div');
  moveItem.className = 'menu-item';
  moveItem.textContent = '📅 移動';
  moveItem.addEventListener('click', () => {
    showMoveDateMenu(task, menu);
  });
  menu.appendChild(moveItem);

  // 時間記録開始/停止ボタン
  const timerItem = document.createElement('div');
  timerItem.className = 'menu-item';
  if (task.isTimerRunning) {
    timerItem.textContent = '⏸️ 時間記録停止';
    timerItem.addEventListener('click', () => {
      stopTaskTimer(task.id);
      menu.remove();
      renderTasks();
    });
  } else {
    timerItem.textContent = '▶️ 時間記録開始';
    timerItem.addEventListener('click', () => {
      startTaskTimer(task.id);
      menu.remove();
      renderTasks();
    });
  }
  menu.appendChild(timerItem);

  // 複製ボタン
  const duplicateItem = document.createElement('div');
  duplicateItem.className = 'menu-item';
  duplicateItem.textContent = '📋 複製';
  duplicateItem.addEventListener('click', () => {
    duplicateTask(task.id);
    menu.remove();
    renderTasks();
  });
  menu.appendChild(duplicateItem);

  // 削除ボタン
  const deleteItem = document.createElement('div');
  deleteItem.className = 'menu-item delete-item';
  deleteItem.textContent = '🗑️ 削除';
  deleteItem.addEventListener('click', () => {
    if (confirm(`「${task.title}」を削除してもよろしいですか？`)) {
      deleteTask(task.id);
      menu.remove();
      renderTasks();
    }
  });
  menu.appendChild(deleteItem);

  return menu;
}

/**
 * 日付移動サブメニューを表示
 */
function showMoveDateMenu(task, parentMenu) {
  // サブメニューを作成
  const submenu = document.createElement('div');
  submenu.className = 'task-context-menu';
  submenu.style.position = 'fixed';

  // 親メニューの位置を基準に配置
  const parentRect = parentMenu.getBoundingClientRect();
  submenu.style.left = `${parentRect.left}px`;
  submenu.style.top = `${parentRect.top}px`;

  // 今日
  const todayItem = document.createElement('div');
  todayItem.className = 'menu-item';
  todayItem.textContent = '📅 今日';
  todayItem.addEventListener('click', () => {
    const today = new Date();
    today.setHours(12, 0, 0, 0);
    updateTask(task.id, { dueDate: today.toISOString() });
    parentMenu.remove();
    submenu.remove();
    renderTasks();
  });
  submenu.appendChild(todayItem);

  // 明日
  const tomorrowItem = document.createElement('div');
  tomorrowItem.className = 'menu-item';
  tomorrowItem.textContent = '📅 明日';
  tomorrowItem.addEventListener('click', () => {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(12, 0, 0, 0);
    updateTask(task.id, { dueDate: tomorrow.toISOString() });
    parentMenu.remove();
    submenu.remove();
    renderTasks();
  });
  submenu.appendChild(tomorrowItem);

  // 来週
  const nextWeekItem = document.createElement('div');
  nextWeekItem.className = 'menu-item';
  nextWeekItem.textContent = '📅 来週';
  nextWeekItem.addEventListener('click', () => {
    const nextWeek = new Date();
    nextWeek.setDate(nextWeek.getDate() + 7);
    nextWeek.setHours(12, 0, 0, 0);
    updateTask(task.id, { dueDate: nextWeek.toISOString() });
    parentMenu.remove();
    submenu.remove();
    renderTasks();
  });
  submenu.appendChild(nextWeekItem);

  // 期限なし
  const noDateItem = document.createElement('div');
  noDateItem.className = 'menu-item';
  noDateItem.textContent = '📅 期限なし';
  noDateItem.addEventListener('click', () => {
    updateTask(task.id, { dueDate: null });
    parentMenu.remove();
    submenu.remove();
    renderTasks();
  });
  submenu.appendChild(noDateItem);

  // 戻る
  const backItem = document.createElement('div');
  backItem.className = 'menu-item';
  backItem.textContent = '← 戻る';
  backItem.addEventListener('click', () => {
    submenu.remove();
  });
  submenu.appendChild(backItem);

  // 親メニューを非表示にして、サブメニューを表示
  parentMenu.style.display = 'none';
  document.body.appendChild(submenu);

  // サブメニュー外をクリック/タッチで両方閉じる
  setTimeout(() => {
    const closeHandler = (e) => {
      if (!submenu.contains(e.target)) {
        submenu.remove();
        parentMenu.remove();
        document.removeEventListener('click', closeHandler);
        document.removeEventListener('touchstart', closeHandler);
      }
    };
    document.addEventListener('click', closeHandler);
    document.addEventListener('touchstart', closeHandler);
  }, 0);
}

// ========================================
```

### render-05-selection-bulk.js

```javascript
// ========================================
// 複数選択モード
// ========================================

// 選択モードのトグル
function toggleSelectionMode() {
  isSelectionMode = !isSelectionMode;

  if (isSelectionMode) {
    // 選択モード開始
    selectedTaskIds.clear();
    document.body.classList.add('selection-mode');
    const toolbar = document.getElementById('bulk-actions-toolbar');
    if (toolbar) toolbar.style.display = 'flex';

    // 複数選択ボタンをアクティブ状態にする（旧UI）
    const bulkSelectToggleBtn = document.getElementById('bulk-select-toggle-btn');
    if (bulkSelectToggleBtn) bulkSelectToggleBtn.classList.add('active');

    // 複数選択ボタンをアクティブ状態にする（新UI）
    const newBulkSelectToggleBtn = document.getElementById('new-bulk-select-toggle-btn');
    if (newBulkSelectToggleBtn) newBulkSelectToggleBtn.classList.add('active');

    updateBulkActionsCount();
  } else {
    // 選択モード終了
    selectedTaskIds.clear();
    document.body.classList.remove('selection-mode');
    const toolbar = document.getElementById('bulk-actions-toolbar');
    if (toolbar) toolbar.style.display = 'none';

    // 複数選択ボタンを非アクティブ状態にする（旧UI）
    const bulkSelectToggleBtn = document.getElementById('bulk-select-toggle-btn');
    if (bulkSelectToggleBtn) bulkSelectToggleBtn.classList.remove('active');

    // 複数選択ボタンを非アクティブ状態にする（新UI）
    const newBulkSelectToggleBtn = document.getElementById('new-bulk-select-toggle-btn');
    if (newBulkSelectToggleBtn) newBulkSelectToggleBtn.classList.remove('active');
  }

  renderTasks();
}

// タスク選択のトグル
function toggleTaskSelection(taskId) {
  if (selectedTaskIds.has(taskId)) {
    selectedTaskIds.delete(taskId);
  } else {
    selectedTaskIds.add(taskId);
  }

  updateBulkActionsCount();

  // 選択状態を視覚的に更新
  const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
  if (taskElement) {
    taskElement.classList.toggle('selected', selectedTaskIds.has(taskId));
    const checkbox = taskElement.querySelector('.task-select-checkbox');
    if (checkbox) checkbox.checked = selectedTaskIds.has(taskId);
  }
}

// 選択数の更新
function updateBulkActionsCount() {
  const countEl = document.getElementById('bulk-selection-count');
  if (countEl) {
    countEl.textContent = `${selectedTaskIds.size}個選択中`;
  }
}

// 一括完了
function bulkCompleteActions() {
  if (selectedTaskIds.size === 0) return;

  selectedTaskIds.forEach(taskId => {
    const task = getTaskById(taskId);
    if (task && !task.isCompleted) {
      updateTask(taskId, { isCompleted: true });
    }
  });

  toggleSelectionMode(); // 選択モードを終了
}

// 一括削除
function bulkDeleteTasks() {
  if (selectedTaskIds.size === 0) return;

  if (!confirm(`${selectedTaskIds.size}個のタスクを削除してもよろしいですか？`)) {
    return;
  }

  selectedTaskIds.forEach(taskId => {
    deleteTask(taskId);
  });

  toggleSelectionMode(); // 選択モードを終了
}

// 全選択/全解除
function bulkSelectAll() {
  // 現在表示されているすべてのタスクを取得
  const allVisibleTaskIds = [];
  // 旧カード（.task-item）と新カード（.new-task-card）の両方を選択
  document.querySelectorAll('.task-item:not(.completed), .new-task-card:not(.completed)').forEach(el => {
    const taskId = el.dataset.taskId;
    if (taskId) {
      allVisibleTaskIds.push(taskId);
    }
  });

  // すべて選択されている場合は全解除、そうでない場合は全選択
  if (selectedTaskIds.size === allVisibleTaskIds.length && allVisibleTaskIds.length > 0) {
    // 全解除
    selectedTaskIds.clear();
  } else {
    // 全選択
    selectedTaskIds.clear();
    allVisibleTaskIds.forEach(taskId => {
      selectedTaskIds.add(taskId);
    });
  }

  updateBulkActionsCount();
  renderTasks();
}

// 一括日付変更
function bulkChangeDateTasks(event) {
  if (selectedTaskIds.size === 0) {
    alert('タスクを選択してください');
    return;
  }

  // 既存のメニューを削除
  const existingMenu = document.querySelector('.bulk-date-menu');
  if (existingMenu) {
    existingMenu.remove();
    return; // トグル動作
  }

  // メニューを作成
  const menu = document.createElement('div');
  menu.className = 'task-context-menu bulk-date-menu';
  menu.style.position = 'fixed';

  // ボタンの位置を基準に配置
  const rect = event.target.closest('button').getBoundingClientRect();
  menu.style.top = `${rect.bottom + 5}px`;
  menu.style.left = `${rect.left}px`;

  // 今日
  const todayItem = document.createElement('div');
  todayItem.className = 'menu-item';
  todayItem.textContent = '📅 今日';
  todayItem.addEventListener('click', () => {
    const today = new Date();
    today.setHours(12, 0, 0, 0);
    bulkUpdateDate(today.toISOString());
    menu.remove();
  });
  menu.appendChild(todayItem);

  // 明日
  const tomorrowItem = document.createElement('div');
  tomorrowItem.className = 'menu-item';
  tomorrowItem.textContent = '📅 明日';
  tomorrowItem.addEventListener('click', () => {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(12, 0, 0, 0);
    bulkUpdateDate(tomorrow.toISOString());
    menu.remove();
  });
  menu.appendChild(tomorrowItem);

  // 来週
  const nextWeekItem = document.createElement('div');
  nextWeekItem.className = 'menu-item';
  nextWeekItem.textContent = '📅 来週';
  nextWeekItem.addEventListener('click', () => {
    const nextWeek = new Date();
    nextWeek.setDate(nextWeek.getDate() + 7);
    nextWeek.setHours(12, 0, 0, 0);
    bulkUpdateDate(nextWeek.toISOString());
    menu.remove();
  });
  menu.appendChild(nextWeekItem);

  // 期限なし
  const noDateItem = document.createElement('div');
  noDateItem.className = 'menu-item';
  noDateItem.textContent = '📅 期限なし';
  noDateItem.addEventListener('click', () => {
    bulkUpdateDate(null);
    menu.remove();
  });
  menu.appendChild(noDateItem);

  document.body.appendChild(menu);

  // メニュー外をクリックで閉じる
  setTimeout(() => {
    const closeHandler = (e) => {
      if (!menu.contains(e.target) && !event.target.closest('button').contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeHandler);
        document.removeEventListener('touchstart', closeHandler);
      }
    };
    document.addEventListener('click', closeHandler);
    document.addEventListener('touchstart', closeHandler);
  }, 0);
}

// 日付の一括更新
function bulkUpdateDate(dueDate) {
  selectedTaskIds.forEach(taskId => {
    updateTask(taskId, { dueDate: dueDate });
  });

  // 振動フィードバック
  if (navigator.vibrate) {
    navigator.vibrate(30);
  }

  renderTasks();
}

// 一括優先度変更
function bulkChangePriorityTasks(event) {
  if (selectedTaskIds.size === 0) {
    alert('タスクを選択してください');
    return;
  }

  // 既存のメニューを削除
  const existingMenu = document.querySelector('.bulk-priority-menu');
  if (existingMenu) {
    existingMenu.remove();
    return; // トグル動作
  }

  // メニューを作成
  const menu = document.createElement('div');
  menu.className = 'task-context-menu bulk-priority-menu';
  menu.style.position = 'fixed';

  // ボタンの位置を基準に配置
  const rect = event.target.closest('button').getBoundingClientRect();
  menu.style.top = `${rect.bottom + 5}px`;
  menu.style.left = `${rect.left}px`;

  // 緊急フラグ
  const urgentItem = document.createElement('div');
  urgentItem.className = 'menu-item';
  urgentItem.textContent = '🚨 緊急';
  urgentItem.addEventListener('click', () => {
    bulkUpdatePriority({ urgent: true });
    menu.remove();
  });
  menu.appendChild(urgentItem);

  // 優先度: 高
  const highItem = document.createElement('div');
  highItem.className = 'menu-item';
  highItem.textContent = '⬆️ 優先度: 高';
  highItem.addEventListener('click', () => {
    bulkUpdatePriority({ priority: 'high', urgent: false });
    menu.remove();
  });
  menu.appendChild(highItem);

  // 優先度: 中
  const mediumItem = document.createElement('div');
  mediumItem.className = 'menu-item';
  mediumItem.textContent = '➡️ 優先度: 中';
  mediumItem.addEventListener('click', () => {
    bulkUpdatePriority({ priority: 'medium', urgent: false });
    menu.remove();
  });
  menu.appendChild(mediumItem);

  // 優先度: 低
  const lowItem = document.createElement('div');
  lowItem.className = 'menu-item';
  lowItem.textContent = '⬇️ 優先度: 低';
  lowItem.addEventListener('click', () => {
    bulkUpdatePriority({ priority: 'low', urgent: false });
    menu.remove();
  });
  menu.appendChild(lowItem);

  // 優先度なし
  const noPriorityItem = document.createElement('div');
  noPriorityItem.className = 'menu-item';
  noPriorityItem.textContent = '❌ 優先度なし';
  noPriorityItem.addEventListener('click', () => {
    bulkUpdatePriority({ priority: '', urgent: false });
    menu.remove();
  });
  menu.appendChild(noPriorityItem);

  document.body.appendChild(menu);

  // メニュー外をクリックで閉じる
  setTimeout(() => {
    const closeHandler = (e) => {
      if (!menu.contains(e.target) && !event.target.closest('button').contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeHandler);
        document.removeEventListener('touchstart', closeHandler);
      }
    };
    document.addEventListener('click', closeHandler);
    document.addEventListener('touchstart', closeHandler);
  }, 0);
}

// 優先度の一括更新
function bulkUpdatePriority(updates) {
  selectedTaskIds.forEach(taskId => {
    updateTask(taskId, updates);
  });

  // 振動フィードバック
  if (navigator.vibrate) {
    navigator.vibrate(30);
  }

  renderTasks();
}

// ========================================
```

### render-06-quick-actions.js

```javascript
// ========================================
// クイックアクション
// ========================================

/**
 * 今日のタスクを一括完了
 */
function quickCompleteToday() {
  const tasks = getTasks();
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  let completedCount = 0;

  tasks.forEach(task => {
    if (!task.isCompleted && task.dueDate) {
      const taskDate = new Date(task.dueDate);
      taskDate.setHours(0, 0, 0, 0);

      if (taskDate.getTime() === today.getTime()) {
        updateTask(task.id, { isCompleted: true });
        completedCount++;
      }
    }
  });

  if (completedCount > 0) {
    alert(`今日のタスク ${completedCount}個を完了しました`);
    renderTasks();

    // 振動フィードバック
    if (navigator.vibrate) {
      navigator.vibrate(50);
    }
  } else {
    alert('今日の未完了タスクはありません');
  }
}

/**
 * 期限切れタスクを明日に移動
 */
function quickMoveOverdueToTomorrow() {
  const tasks = getTasks();
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);
  tomorrow.setHours(12, 0, 0, 0);

  let movedCount = 0;

  tasks.forEach(task => {
    if (!task.isCompleted && task.dueDate) {
      const taskDate = new Date(task.dueDate);
      taskDate.setHours(0, 0, 0, 0);

      if (taskDate.getTime() < today.getTime()) {
        updateTask(task.id, { dueDate: tomorrow.toISOString() });
        movedCount++;
      }
    }
  });

  if (movedCount > 0) {
    alert(`期限切れタスク ${movedCount}個を明日に移動しました`);
    renderTasks();

    // 振動フィードバック
    if (navigator.vibrate) {
      navigator.vibrate(50);
    }
  } else {
    alert('期限切れのタスクはありません');
  }
}

/**
 * 完了タスクをアーカイブ（削除）
 */
function quickArchiveCompleted() {
  const tasks = getTasks();
  const completedTasks = tasks.filter(t => t.isCompleted);

  if (completedTasks.length === 0) {
    alert('完了済みのタスクはありません');
    return;
  }

  if (!confirm(`完了済みタスク ${completedTasks.length}個をアーカイブしてもよろしいですか？\n（ゴミ箱に移動されます）`)) {
    return;
  }

  let archivedCount = 0;
  completedTasks.forEach(task => {
    deleteTask(task.id);
    archivedCount++;
  });

  alert(`${archivedCount}個のタスクをアーカイブしました`);
  renderTasks();

  // 振動フィードバック
  if (navigator.vibrate) {
    navigator.vibrate(50);
  }
}

/**
 * 今日の未完了タスクを明日にコピー
 */
function quickCopyTodayToTomorrow() {
  const tasks = getTasks();
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);
  tomorrow.setHours(12, 0, 0, 0);

  const todayTasks = tasks.filter(task => {
    if (task.isCompleted || !task.dueDate) return false;
    const taskDate = new Date(task.dueDate);
    taskDate.setHours(0, 0, 0, 0);
    return taskDate.getTime() === today.getTime();
  });

  if (todayTasks.length === 0) {
    alert('今日の未完了タスクはありません');
    return;
  }

  if (!confirm(`今日の未完了タスク ${todayTasks.length}個を明日にコピーしてもよろしいですか？`)) {
    return;
  }

  const allTasks = getTasks();
  const now = new Date().toISOString();

  todayTasks.forEach(task => {
    const copiedTask = {
      ...task,
      id: generateUUID(),
      dueDate: tomorrow.toISOString(),
      isCompleted: false,
      createdAt: now,
      updatedAt: now
    };
    allTasks.unshift(copiedTask);
  });

  saveTasks(allTasks);
  alert(`${todayTasks.length}個のタスクを明日にコピーしました`);
  renderTasks();

  // 振動フィードバック
  if (navigator.vibrate) {
    navigator.vibrate(50);
  }
}

// ========================================
// クイック入力バー＆完了済みセクション（新UI）
// ========================================

/**
 * クイック入力バーを初期化（新UI用）
 */
function initQuickInput() {
  // Note: クイック入力フォームのイベントリスナーはevents.jsで既に設定されているため、ここでは何もしない
  // events.js の initEventListeners() 内で quickAddForm の submit イベントを設定している
  console.log('initQuickInput: Quick input already initialized in events.js');
}

/**
 * クイック入力を送信
 */
function submitQuickInput() {
  const quickInput = document.getElementById('new-quick-input');
  const title = quickInput ? quickInput.value.trim() : '';

  if (!title) {
    alert('タスク名を入力してください');
    return;
  }

  // 今日の日付を期限として設定
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayISO = new Date(today.getTime() - today.getTimezoneOffset() * 60000).toISOString();

  // タスク作成
  createTask(title, '', todayISO, null);

  // 入力フィールドをクリア
  if (quickInput) {
    quickInput.value = '';
    quickInput.focus();
  }

  // 振動フィードバック
  if (navigator.vibrate) {
    navigator.vibrate(30);
  }

  // 再レンダリング
  renderTasks();
}

/**
 * 完了済みセクションのトグル初期化（新UI用）
 */
function initCompletedToggle() {
  // Note: 完了済みセクションのトグルのイベントリスナーはevents.jsで既に設定されているため、ここでは何もしない
  // events.js の initEventListeners() 内で completedToggle のクリックイベントを設定している
  console.log('initCompletedToggle: Completed toggle already initialized in events.js');
}
```

### search-filter.js

```javascript
// ========================================
// 検索・フィルター・ソート機能
// ========================================

// グローバル変数
let searchKeyword = '';
let activeFilters = new Set();
let currentSort = 'time'; // デフォルトはtime順
let searchHistory = [];

// ========================================
// 初期化
// ========================================

function initSearchFilter() {
  // LocalStorageから設定を復元
  loadSearchFilterSettings();

  // イベントリスナーの設定
  setupSearchListeners();
  setupFilterListeners();
  setupSortListeners();
  setupModalListeners();

  // UIの初期状態を反映
  updateSortUI();
  updateFilterUI();
}

// 設定の読み込み
function loadSearchFilterSettings() {
  try {
    // ソート順の復元
    const savedSort = localStorage.getItem('nowtask_sort');
    if (savedSort) {
      currentSort = savedSort;
    }

    // 検索履歴の復元
    const savedHistory = localStorage.getItem('nowtask_search_history');
    if (savedHistory) {
      searchHistory = JSON.parse(savedHistory);
    }
  } catch (e) {
    console.warn('Failed to load search filter settings:', e);
  }
}

// 設定の保存
function saveSearchFilterSettings() {
  try {
    localStorage.setItem('nowtask_sort', currentSort);
    localStorage.setItem('nowtask_search_history', JSON.stringify(searchHistory));
  } catch (e) {
    console.warn('Failed to save search filter settings:', e);
  }
}

// ========================================
// 検索機能
// ========================================

function setupSearchListeners() {
  const searchInput = document.getElementById('search-input');
  const searchClearBtn = document.getElementById('search-clear-btn');
  const searchHistoryDiv = document.getElementById('search-history');

  if (!searchInput) return;

  // リアルタイム検索
  searchInput.addEventListener('input', (e) => {
    searchKeyword = e.target.value.trim();

    // クリアボタンの表示/非表示
    if (searchKeyword) {
      searchClearBtn.style.display = 'flex';
    } else {
      searchClearBtn.style.display = 'none';
    }

    // タスクを再レンダリング
    if (typeof renderTasks === 'function') {
      renderTasks();
    }
  });

  // フォーカス時に検索履歴を表示
  searchInput.addEventListener('focus', () => {
    if (searchHistory.length > 0 && !searchKeyword) {
      renderSearchHistory();
      searchHistoryDiv.style.display = 'block';
    }
  });

  // フォーカスが外れたら検索履歴を隠す（少し遅延）
  searchInput.addEventListener('blur', () => {
    setTimeout(() => {
      searchHistoryDiv.style.display = 'none';
    }, 200);
  });

  // クリアボタンのクリック
  if (searchClearBtn) {
    searchClearBtn.addEventListener('click', () => {
      searchInput.value = '';
      searchKeyword = '';
      searchClearBtn.style.display = 'none';

      if (typeof renderTasks === 'function') {
        renderTasks();
      }
    });
  }

  // Enterキーで検索履歴に追加
  searchInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && searchKeyword) {
      addToSearchHistory(searchKeyword);
    }
  });
}

// 検索履歴に追加
function addToSearchHistory(keyword) {
  // 既存の履歴から削除（重複を避ける）
  searchHistory = searchHistory.filter(item => item !== keyword);

  // 先頭に追加
  searchHistory.unshift(keyword);

  // 最大10件まで保持
  searchHistory = searchHistory.slice(0, 10);

  // 保存
  saveSearchFilterSettings();
}

// 検索履歴の表示
function renderSearchHistory() {
  const searchHistoryDiv = document.getElementById('search-history');
  if (!searchHistoryDiv) return;

  searchHistoryDiv.innerHTML = '';

  searchHistory.forEach(keyword => {
    const item = document.createElement('div');
    item.className = 'search-history-item';

    const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    icon.setAttribute('width', '16');
    icon.setAttribute('height', '16');
    icon.setAttribute('viewBox', '0 0 24 24');
    icon.setAttribute('fill', 'none');
    icon.setAttribute('stroke', 'currentColor');
    icon.setAttribute('stroke-width', '2');
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', '12');
    circle.setAttribute('cy', '12');
    circle.setAttribute('r', '10');
    const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
    polyline.setAttribute('points', '12 6 12 12 16 14');
    icon.appendChild(circle);
    icon.appendChild(polyline);

    const text = document.createTextNode(keyword);

    item.appendChild(icon);
    item.appendChild(text);

    item.addEventListener('click', () => {
      document.getElementById('search-input').value = keyword;
      searchKeyword = keyword;
      document.getElementById('search-clear-btn').style.display = 'flex';
      searchHistoryDiv.style.display = 'none';

      if (typeof renderTasks === 'function') {
        renderTasks();
      }
    });

    searchHistoryDiv.appendChild(item);
  });
}

// 検索結果のハイライト表示
function highlightSearchResult(text, keyword) {
  if (!keyword || !text) return text;

  const regex = new RegExp(`(${escapeRegex(keyword)})`, 'gi');
  return text.replace(regex, '<span class="search-highlight">$1</span>');
}

function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// ========================================
// フィルター機能
// ========================================

function setupFilterListeners() {
  // 全てのフィルターボタン
  const filterButtons = document.querySelectorAll('.filter-btn[data-filter]');

  filterButtons.forEach(button => {
    button.addEventListener('click', () => {
      const filterType = button.getAttribute('data-filter');

      if (activeFilters.has(filterType)) {
        // 既にアクティブなら解除
        activeFilters.delete(filterType);
        button.classList.remove('active');
      } else {
        // アクティブでなければ追加
        activeFilters.add(filterType);
        button.classList.add('active');
      }

      // タスクを再レンダリング
      if (typeof renderTasks === 'function') {
        renderTasks();
      }
    });
  });

  // クリアボタン
  const clearButton = document.getElementById('filter-clear');
  if (clearButton) {
    clearButton.addEventListener('click', () => {
      clearAllFilters();

      if (typeof renderTasks === 'function') {
        renderTasks();
      }
    });
  }
}

function clearAllFilters() {
  activeFilters.clear();
  updateFilterUI();
}

function updateFilterUI() {
  const filterButtons = document.querySelectorAll('.filter-btn[data-filter]');
  filterButtons.forEach(button => {
    const filterType = button.getAttribute('data-filter');
    if (activeFilters.has(filterType)) {
      button.classList.add('active');
    } else {
      button.classList.remove('active');
    }
  });
}

// タスクがフィルター条件に一致するかチェック
function matchesFilters(task) {
  // フィルターが何もない場合はすべて表示
  if (activeFilters.size === 0) return true;

  // 各フィルターをチェック
  for (const filter of activeFilters) {
    if (!matchesFilter(task, filter)) {
      return false; // 1つでも一致しなければfalse
    }
  }

  return true; // すべてのフィルターに一致
}

function matchesFilter(task, filter) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);

  const weekEnd = new Date(today);
  weekEnd.setDate(weekEnd.getDate() + 7);

  switch (filter) {
    // 優先度フィルター
    case 'urgent':
      return task.urgent === true;
    case 'priority-high':
      return task.priority === 'high';
    case 'priority-medium':
      return task.priority === 'medium';
    case 'priority-low':
      return task.priority === 'low';

    // 期限フィルター
    case 'today':
      if (!task.dueDate) return false;
      const taskDate = new Date(task.dueDate);
      taskDate.setHours(0, 0, 0, 0);
      return taskDate.getTime() === today.getTime();

    case 'tomorrow':
      if (!task.dueDate) return false;
      const taskDateTmr = new Date(task.dueDate);
      taskDateTmr.setHours(0, 0, 0, 0);
      return taskDateTmr.getTime() === tomorrow.getTime();

    case 'this-week':
      if (!task.dueDate) return false;
      const taskDateWeek = new Date(task.dueDate);
      taskDateWeek.setHours(0, 0, 0, 0);
      return taskDateWeek >= today && taskDateWeek < weekEnd;

    case 'overdue':
      if (!task.dueDate || task.isCompleted) return false;
      const taskDateOverdue = new Date(task.dueDate);
      taskDateOverdue.setHours(0, 0, 0, 0);
      return taskDateOverdue < today;

    // 状態フィルター
    case 'incomplete':
      return !task.isCompleted;

    case 'completed':
      return task.isCompleted === true;

    case 'routine':
      return task.routineId !== undefined && task.routineId !== null;

    default:
      return true;
  }
}

// ========================================
// ソート機能
// ========================================

function setupSortListeners() {
  const sortSelect = document.getElementById('sort-select');

  if (sortSelect) {
    sortSelect.addEventListener('change', (e) => {
      currentSort = e.target.value;

      // 設定を保存
      saveSearchFilterSettings();

      // タスクを再レンダリング
      if (typeof renderTasks === 'function') {
        renderTasks();
      }
    });
  }
}

function updateSortUI() {
  const sortSelect = document.getElementById('sort-select');
  if (sortSelect) {
    sortSelect.value = currentSort;
  }
}

// タスクリストのソート
function sortTasks(tasks) {
  const sorted = [...tasks]; // コピーを作成

  switch (currentSort) {
    case 'time': // 期限が近い順
      sorted.sort((a, b) => {
        if (!a.dueDate && !b.dueDate) return 0;
        if (!a.dueDate) return 1;
        if (!b.dueDate) return -1;
        return new Date(a.dueDate) - new Date(b.dueDate);
      });
      break;

    case 'time-desc': // 期限が遠い順
      sorted.sort((a, b) => {
        if (!a.dueDate && !b.dueDate) return 0;
        if (!a.dueDate) return -1;
        if (!b.dueDate) return 1;
        return new Date(b.dueDate) - new Date(a.dueDate);
      });
      break;

    case 'created': // 追加順（新しい順）
      sorted.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
      break;

    case 'created-desc': // 追加順（古い順）
      sorted.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
      break;

    case 'priority': // 優先順位順
      const priorityOrder = { 'high': 1, 'medium': 2, 'low': 3, '': 4 };
      sorted.sort((a, b) => {
        // 緊急フラグが優先
        if (a.urgent && !b.urgent) return -1;
        if (!a.urgent && b.urgent) return 1;

        // 次に優先順位
        const aPriority = priorityOrder[a.priority || ''];
        const bPriority = priorityOrder[b.priority || ''];
        return aPriority - bPriority;
      });
      break;

    case 'title': // タスク名順（A→Z）
      sorted.sort((a, b) => {
        const titleA = (a.title || '').toLowerCase();
        const titleB = (b.title || '').toLowerCase();
        return titleA.localeCompare(titleB, 'ja');
      });
      break;

    default:
      // デフォルトは時間順
      sorted.sort((a, b) => {
        if (!a.dueDate && !b.dueDate) return 0;
        if (!a.dueDate) return 1;
        if (!b.dueDate) return -1;
        return new Date(a.dueDate) - new Date(b.dueDate);
      });
  }

  return sorted;
}

// ========================================
// 検索・フィルター・ソートの統合処理
// ========================================

// タスクリストに検索・フィルター・ソートを適用
function applySearchFilterSort(tasks) {
  let filteredTasks = tasks;

  // 1. 検索でフィルター
  if (searchKeyword) {
    filteredTasks = filteredTasks.filter(task => {
      const title = (task.title || '').toLowerCase();
      const memo = (task.memo || '').toLowerCase();
      const keyword = searchKeyword.toLowerCase();
      return title.includes(keyword) || memo.includes(keyword);
    });
  }

  // 2. フィルターを適用
  if (activeFilters.size > 0) {
    filteredTasks = filteredTasks.filter(task => matchesFilters(task));
  }

  // 3. ソート
  filteredTasks = sortTasks(filteredTasks);

  return filteredTasks;
}

// ========================================
// モーダル機能
// ========================================

function setupModalListeners() {
  const modal = document.getElementById('search-filter-modal');
  const closeBtn = document.getElementById('close-search-filter-btn');
  const applyBtn = document.getElementById('search-filter-apply-btn');
  const clearAllBtn = document.getElementById('search-filter-clear-all-btn');
  const modalSearchInput = document.getElementById('modal-search-input');
  const modalSearchClearBtn = document.getElementById('modal-search-clear-btn');
  const modalSortSelect = document.getElementById('modal-sort-select');

  // モーダルを閉じる
  if (closeBtn) {
    closeBtn.addEventListener('click', closeSearchFilterModal);
  }

  // モーダル外クリックで閉じる
  if (modal) {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeSearchFilterModal();
      }
    });
  }

  // 適用ボタン
  if (applyBtn) {
    applyBtn.addEventListener('click', () => {
      closeSearchFilterModal();
      if (typeof renderTasks === 'function') {
        renderTasks();
      }
    });
  }

  // すべてクリア
  if (clearAllBtn) {
    clearAllBtn.addEventListener('click', () => {
      // 検索キーワードクリア
      searchKeyword = '';
      if (modalSearchInput) {
        modalSearchInput.value = '';
        modalSearchClearBtn.style.display = 'none';
      }

      // フィルタークリア
      activeFilters.clear();
      updateModalFilterUI();

      // ソートをデフォルトに戻す
      currentSort = 'time';
      if (modalSortSelect) {
        modalSortSelect.value = 'time';
      }

      // タスクを再レンダリング
      if (typeof renderTasks === 'function') {
        renderTasks();
      }
    });
  }

  // モーダル内検索入力
  if (modalSearchInput) {
    modalSearchInput.addEventListener('input', (e) => {
      searchKeyword = e.target.value.trim();

      if (searchKeyword) {
        modalSearchClearBtn.style.display = 'block';
      } else {
        modalSearchClearBtn.style.display = 'none';
      }
    });

    // Enterキーで検索履歴に追加
    modalSearchInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && searchKeyword) {
        addToSearchHistory(searchKeyword);
      }
    });
  }

  // モーダル内検索クリアボタン
  if (modalSearchClearBtn) {
    modalSearchClearBtn.addEventListener('click', () => {
      modalSearchInput.value = '';
      searchKeyword = '';
      modalSearchClearBtn.style.display = 'none';
    });
  }

  // モーダル内ソート
  if (modalSortSelect) {
    modalSortSelect.addEventListener('change', (e) => {
      currentSort = e.target.value;
      saveSearchFilterSettings();
    });
  }

  // モーダル内フィルターボタン
  const modalFilterButtons = modal.querySelectorAll('.filter-btn[data-filter]');
  modalFilterButtons.forEach(button => {
    button.addEventListener('click', () => {
      const filterType = button.getAttribute('data-filter');

      if (activeFilters.has(filterType)) {
        activeFilters.delete(filterType);
        button.classList.remove('active');
      } else {
        activeFilters.add(filterType);
        button.classList.add('active');
      }
    });
  });
}

function openSearchFilterModal() {
  const modal = document.getElementById('search-filter-modal');
  const modalSearchInput = document.getElementById('modal-search-input');
  const modalSearchClearBtn = document.getElementById('modal-search-clear-btn');
  const modalSortSelect = document.getElementById('modal-sort-select');

  if (!modal) return;

  // 現在の設定をモーダルに反映
  if (modalSearchInput) {
    modalSearchInput.value = searchKeyword;
    modalSearchClearBtn.style.display = searchKeyword ? 'block' : 'none';
  }

  if (modalSortSelect) {
    modalSortSelect.value = currentSort;
  }

  updateModalFilterUI();

  // モーダルを表示
  modal.style.display = 'flex';
}

function closeSearchFilterModal() {
  const modal = document.getElementById('search-filter-modal');
  if (modal) {
    modal.style.display = 'none';
  }
}

function updateModalFilterUI() {
  const modal = document.getElementById('search-filter-modal');
  if (!modal) return;

  const filterButtons = modal.querySelectorAll('.filter-btn[data-filter]');
  filterButtons.forEach(button => {
    const filterType = button.getAttribute('data-filter');
    if (activeFilters.has(filterType)) {
      button.classList.add('active');
    } else {
      button.classList.remove('active');
    }
  });
}

// ========================================
// エクスポート（グローバル変数として公開）
// ========================================

// グローバルスコープに公開
window.searchFilter = {
  init: initSearchFilter,
  apply: applySearchFilterSort,
  highlightSearchResult: highlightSearchResult,
  getSearchKeyword: () => searchKeyword,
  getActiveFilters: () => activeFilters,
  getCurrentSort: () => currentSort
};

// モーダルを開く関数をグローバルに公開
window.openSearchFilterModal = openSearchFilterModal;
```

### share.js

```javascript
// ========================================
// X共有機能
// ========================================

/**
 * 今日のタスクデータを取得して共有用のテキストを生成
 */
function generateShareData() {
  const tasks = getTasks();
  const today = new Date();
  const todayDateStr = today.toISOString().split('T')[0];

  const baseDate = new Date();
  baseDate.setHours(0, 0, 0, 0);

  const tomorrow = new Date(baseDate);
  tomorrow.setDate(tomorrow.getDate() + 1);

  // 今日のタスクを抽出（完了済みを除く）
  const todayTasks = tasks.filter(task => {
    if (task.isCompleted || task.parentId) return false;
    if (!task.dueDate) return false;
    const dueDate = new Date(task.dueDate);
    return dueDate >= baseDate && dueDate < tomorrow;
  });

  // 全てのタスク（完了済みを含む）
  const allTodayTasks = tasks.filter(task => {
    if (task.parentId) return false;
    if (!task.dueDate) return false;
    const dueDate = new Date(task.dueDate);
    return dueDate >= baseDate && dueDate < tomorrow;
  });

  // 完了済みと未完了を分ける
  const completedTasks = allTodayTasks.filter(t => t.isCompleted);
  const incompleteTasks = allTodayTasks.filter(t => !t.isCompleted);

  // 現在時刻（分単位）
  const now = new Date();
  const currentMinutes = now.getHours() * 60 + now.getMinutes();

  // これから先のタスク時間を計算（重複を考慮）
  const timeSlots = [];

  todayTasks.forEach(task => {
    if (task.startTime && task.endTime) {
      const [startHour, startMin] = task.startTime.split(':').map(Number);
      const [endHour, endMin] = task.endTime.split(':').map(Number);
      let startMinutes = startHour * 60 + startMin;
      let endMinutes = endHour * 60 + endMin;

      // 日をまたぐ場合の処理
      if (endMinutes < startMinutes) {
        startMinutes = Math.max(startMinutes, currentMinutes);
        endMinutes = 24 * 60;
      } else {
        if (endMinutes <= currentMinutes) return;
        if (startMinutes < currentMinutes) {
          startMinutes = currentMinutes;
        }
      }

      timeSlots.push({ start: startMinutes, end: endMinutes });

    } else if (task.duration) {
      timeSlots.push({
        start: currentMinutes,
        end: Math.min(currentMinutes + task.duration, 24 * 60)
      });
    }
  });

  // タイムスロットを統合（重複を排除）
  let totalDurationMinutes = 0;
  if (timeSlots.length > 0) {
    timeSlots.sort((a, b) => a.start - b.start);

    const mergedSlots = [timeSlots[0]];
    for (let i = 1; i < timeSlots.length; i++) {
      const current = timeSlots[i];
      const last = mergedSlots[mergedSlots.length - 1];

      if (current.start <= last.end) {
        last.end = Math.max(last.end, current.end);
      } else {
        mergedSlots.push(current);
      }
    }

    totalDurationMinutes = mergedSlots.reduce((sum, slot) => {
      return sum + (slot.end - slot.start);
    }, 0);
  }

  // 残り時間から空き時間を計算
  const totalMinutesInDay = 24 * 60;
  const remainingTimeInDay = totalMinutesInDay - currentMinutes;
  const freeMinutes = remainingTimeInDay - totalDurationMinutes;
  const freeHours = Math.floor(freeMinutes / 60);
  const freeMinutesRemainder = freeMinutes % 60;

  return {
    todayTasks: allTodayTasks,
    completedTasks,
    incompleteTasks,
    freeHours,
    freeMinutes: freeMinutesRemainder,
    totalScheduledMinutes: totalDurationMinutes
  };
}

/**
 * 共有用のHTML要素を生成
 */
function createShareElement() {
  const data = generateShareData();
  const today = new Date();
  const dateStr = `${today.getFullYear()}年${today.getMonth() + 1}月${today.getDate()}日`;

  // 共有用のコンテナを作成
  const shareContainer = document.createElement('div');
  shareContainer.id = 'share-container';
  shareContainer.style.cssText = `
    position: fixed;
    top: -9999px;
    left: -9999px;
    width: 600px;
    background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
    padding: 40px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    border-radius: 16px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
  `;

  // ヘッダー部分
  const header = document.createElement('div');
  header.style.cssText = `
    text-align: center;
    margin-bottom: 32px;
  `;
  header.innerHTML = `
    <h1 style="font-size: 32px; font-weight: 700; color: #000; margin: 0 0 8px 0;">nowtask</h1>
    <p style="font-size: 16px; color: #666; margin: 0;">${dateStr}</p>
  `;

  // 空き時間カード
  const freeTimeCard = document.createElement('div');
  freeTimeCard.style.cssText = `
    background: white;
    border-radius: 12px;
    padding: 24px;
    margin-bottom: 24px;
    text-align: center;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
  `;
  freeTimeCard.innerHTML = `
    <p style="font-size: 14px; color: #666; margin: 0 0 8px 0;">今日の空き時間</p>
    <p style="font-size: 48px; font-weight: 700; color: #000; margin: 0;">
      ${data.freeHours}<span style="font-size: 24px;">時間</span>${data.freeMinutes}<span style="font-size: 24px;">分</span>
    </p>
  `;

  // タスク統計カード
  const statsCard = document.createElement('div');
  statsCard.style.cssText = `
    background: white;
    border-radius: 12px;
    padding: 24px;
    margin-bottom: 24px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
  `;
  statsCard.innerHTML = `
    <div style="display: flex; justify-content: space-around; text-align: center;">
      <div>
        <p style="font-size: 32px; font-weight: 700; color: #000; margin: 0 0 4px 0;">${data.todayTasks.length}</p>
        <p style="font-size: 12px; color: #666; margin: 0;">総タスク数</p>
      </div>
      <div style="width: 1px; background: #e0e0e0;"></div>
      <div>
        <p style="font-size: 32px; font-weight: 700; color: #4caf50; margin: 0 0 4px 0;">${data.completedTasks.length}</p>
        <p style="font-size: 12px; color: #666; margin: 0;">完了</p>
      </div>
      <div style="width: 1px; background: #e0e0e0;"></div>
      <div>
        <p style="font-size: 32px; font-weight: 700; color: #ff9800; margin: 0 0 4px 0;">${data.incompleteTasks.length}</p>
        <p style="font-size: 12px; color: #666; margin: 0;">未完了</p>
      </div>
    </div>
  `;

  // タスクリストカード（未完了タスクのみ、最大5件）
  const taskListCard = document.createElement('div');
  taskListCard.style.cssText = `
    background: white;
    border-radius: 12px;
    padding: 24px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
  `;

  const taskListTitle = document.createElement('h3');
  taskListTitle.style.cssText = `
    font-size: 16px;
    font-weight: 600;
    color: #000;
    margin: 0 0 16px 0;
  `;
  taskListTitle.textContent = '今日の予定';

  const taskList = document.createElement('div');
  const displayTasks = data.incompleteTasks.slice(0, 5);

  if (displayTasks.length === 0) {
    taskList.innerHTML = `<p style="color: #999; text-align: center; font-size: 14px;">未完了タスクはありません</p>`;
  } else {
    displayTasks.forEach((task, index) => {
      const taskItem = document.createElement('div');
      taskItem.style.cssText = `
        padding: 12px 0;
        border-bottom: ${index < displayTasks.length - 1 ? '1px solid #f0f0f0' : 'none'};
        display: flex;
        justify-content: space-between;
        align-items: center;
      `;

      const taskTitle = document.createElement('span');
      taskTitle.style.cssText = `
        font-size: 14px;
        color: #333;
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      `;
      taskTitle.textContent = task.title;

      const taskTime = document.createElement('span');
      taskTime.style.cssText = `
        font-size: 12px;
        color: #999;
        margin-left: 12px;
      `;
      if (task.startTime) {
        taskTime.textContent = task.startTime.substring(0, 5);
      } else if (task.duration) {
        const hours = Math.floor(task.duration / 60);
        const minutes = task.duration % 60;
        if (hours > 0) {
          taskTime.textContent = `${hours}時間${minutes > 0 ? minutes + '分' : ''}`;
        } else {
          taskTime.textContent = `${minutes}分`;
        }
      }

      taskItem.appendChild(taskTitle);
      taskItem.appendChild(taskTime);
      taskList.appendChild(taskItem);
    });

    if (data.incompleteTasks.length > 5) {
      const moreText = document.createElement('p');
      moreText.style.cssText = `
        text-align: center;
        color: #999;
        font-size: 12px;
        margin: 12px 0 0 0;
      `;
      moreText.textContent = `他 ${data.incompleteTasks.length - 5} 件`;
      taskList.appendChild(moreText);
    }
  }

  taskListCard.appendChild(taskListTitle);
  taskListCard.appendChild(taskList);

  // フッター
  const footer = document.createElement('div');
  footer.style.cssText = `
    text-align: center;
    margin-top: 24px;
    padding-top: 24px;
    border-top: 1px solid #ddd;
  `;
  footer.innerHTML = `<p style="font-size: 12px; color: #999; margin: 0;">Generated by nowtask</p>`;

  // すべての要素を追加
  shareContainer.appendChild(header);
  shareContainer.appendChild(freeTimeCard);
  shareContainer.appendChild(statsCard);
  shareContainer.appendChild(taskListCard);
  shareContainer.appendChild(footer);

  return shareContainer;
}

/**
 * 共有画像を生成してダウンロード
 */
async function generateAndShareImage() {
  try {
    // 共有用の要素を作成してDOMに追加
    const shareElement = createShareElement();
    document.body.appendChild(shareElement);

    // html2canvasで画像化
    const canvas = await html2canvas(shareElement, {
      backgroundColor: null,
      scale: 2,
      logging: false
    });

    // 要素を削除
    document.body.removeChild(shareElement);

    // Canvasを画像に変換
    canvas.toBlob(async (blob) => {
      if (!blob) {
        alert('画像の生成に失敗しました');
        return;
      }

      // Web Share APIが使用可能かチェック
      if (navigator.share && navigator.canShare) {
        try {
          const file = new File([blob], 'nowtask-share.png', { type: 'image/png' });

          // 共有可能かチェック
          if (navigator.canShare({ files: [file] })) {
            await navigator.share({
              files: [file],
              text: '今日のタスク管理 #nowtask'
            });
          } else {
            // ファイル共有が使えない場合は画像をダウンロード
            downloadImage(blob);
          }
        } catch (err) {
          // キャンセルされた場合やエラーの場合
          if (err.name !== 'AbortError') {
            console.error('共有エラー:', err);
            downloadImage(blob);
          }
        }
      } else {
        // Web Share APIが使えない場合は画像をダウンロード
        downloadImage(blob);
      }
    }, 'image/png');
  } catch (error) {
    console.error('画像生成エラー:', error);
    alert('画像の生成に失敗しました');
  }
}

/**
 * 画像をダウンロード
 */
function downloadImage(blob) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `nowtask-${new Date().toISOString().split('T')[0]}.png`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);

  alert('画像をダウンロードしました。Xにアップロードしてください。');
}
```

### tasks.js

```javascript
// ========================================
// タスク管理関数
// ========================================

// タスク取得
function getTasks() {
  return loadFromStorage(STORAGE_KEYS.TASKS, []);
}

// タスク保存
function saveTasks(tasks) {
  return saveToStorage(STORAGE_KEYS.TASKS, tasks);
}

// ID指定でタスク取得
function getTaskById(id) {
  const tasks = getTasks();
  return tasks.find(task => task.id === id);
}

// 子タスク取得
function getSubtasks(parentId) {
  const tasks = getTasks();
  return tasks.filter(task => task.parentId === parentId);
}

// タスクの階層レベルを取得（最大5階層）
function getTaskLevel(taskId) {
  let level = 0;
  let currentId = taskId;
  const maxLevel = 5;

  while (level < maxLevel) {
    const task = getTaskById(currentId);
    if (!task || !task.parentId) break;
    level++;
    currentId = task.parentId;
  }

  return level;
}

// タスクが子タスクを持てるかチェック（5階層制限）
function canHaveSubtask(taskId) {
  return getTaskLevel(taskId) < 4; // 0-4まで（5階層）
}

// タスク作成
function createTask(title, memo = '', dueDate = null, parentId = null, isTutorial = false, duration = null, startTime = null, endTime = null) {
  if (!title || title.trim().length === 0) {
    return null;
  }

  const now = new Date().toISOString();
  const task = {
    id: generateUUID(),
    title: title.trim(),
    memo: memo.trim(),
    dueDate: dueDate,
    isCompleted: false,
    createdAt: now,
    updatedAt: now,
    parentId: parentId,
    isTutorial: isTutorial,
    totalTime: 0,
    isTimerRunning: false,
    timerStartTime: null,
    duration: duration, // 所要時間（分） - 廃止予定
    startTime: startTime, // 開始時刻 (HH:MM)
    endTime: endTime, // 終了時刻 (HH:MM)
    urgent: false, // 緊急フラグ
    priority: '' // 優先順位 (high, medium, low, '')
  };

  const tasks = getTasks();
  tasks.unshift(task);
  saveTasks(tasks);
  // タスク情報を履歴に追加（core.js の addToTaskHistory を使用）
  if (typeof addToTaskHistory === 'function') {
    addToTaskHistory(task.title, task.startTime, task.endTime, 20);
    // 履歴が更新されたことを通知するカスタムイベント
    try {
      document.dispatchEvent(new CustomEvent('task:history:updated'));
    } catch (e) {
      // 古いブラウザでは CustomEvent が機能しない場合があるが、致命的ではない
      console.warn('CustomEvent dispatch failed for task:history:updated', e);
    }
  }

  // サブタスクの場合、親タスクの時間を集計
  if (parentId && typeof aggregateSubtaskTimes === 'function') {
    aggregateSubtaskTimes(parentId);
  }

  return task;
}

// サブタスクの時間をメインタスクに集計
function aggregateSubtaskTimes(taskId) {
  const task = getTaskById(taskId);
  if (!task) return false;

  // メインタスクに時間が設定されている場合はスキップ
  if (task.startTime || task.endTime) return false;

  const subtasks = getSubtasks(taskId);
  if (subtasks.length === 0) return false;

  // サブタスクの中で時間が設定されているものを探す
  const subtasksWithTime = subtasks.filter(st => st.startTime || st.endTime);
  if (subtasksWithTime.length === 0) return false;

  // 最も早い開始時刻と最も遅い終了時刻を見つける
  let earliestStart = null;
  let latestEnd = null;

  subtasksWithTime.forEach(subtask => {
    if (subtask.startTime) {
      if (!earliestStart || subtask.startTime < earliestStart) {
        earliestStart = subtask.startTime;
      }
    }
    if (subtask.endTime) {
      if (!latestEnd || subtask.endTime > latestEnd) {
        latestEnd = subtask.endTime;
      }
    }
  });

  // メインタスクに時間を設定
  if (earliestStart || latestEnd) {
    updateTask(taskId, {
      startTime: earliestStart,
      endTime: latestEnd
    });
    return true;
  }

  return false;
}

// タスク更新
function updateTask(id, updates) {
  const tasks = getTasks();
  const index = tasks.findIndex(task => task.id === id);

  if (index === -1) return false;

  const task = tasks[index];
  tasks[index] = {
    ...task,
    ...updates,
    updatedAt: new Date().toISOString()
  };

  saveTasks(tasks);

  // サブタスクの場合、親タスクの時間を集計
  if (task.parentId && typeof aggregateSubtaskTimes === 'function') {
    aggregateSubtaskTimes(task.parentId);
  }

  return true;
}

// タスク削除（ゴミ箱へ移動）
function deleteTask(id) {
  const tasks = getTasks();
  const index = tasks.findIndex(task => task.id === id);

  if (index === -1) return false;

  const deletedTask = tasks.splice(index, 1)[0];

  // ゴミ箱に追加
  const trash = loadFromStorage(STORAGE_KEYS.TRASH, []);
  trash.unshift({
    ...deletedTask,
    deletedAt: new Date().toISOString()
  });
  saveToStorage(STORAGE_KEYS.TRASH, trash);

  saveTasks(tasks);
  return true;
}

// タスク複製
function duplicateTask(id) {
  const task = getTaskById(id);
  if (!task) return false;

  const now = new Date().toISOString();
  const duplicatedTask = {
    ...task,
    id: generateUUID(),
    title: task.title + ' (コピー)',
    isCompleted: false,
    createdAt: now,
    updatedAt: now,
    totalTime: 0,
    isTimerRunning: false,
    timerStartTime: null,
    isTutorial: false
  };

  const tasks = getTasks();
  tasks.unshift(duplicatedTask);
  saveTasks(tasks);

  // タスク情報を履歴に追加
  if (typeof addToTaskHistory === 'function') {
    addToTaskHistory(duplicatedTask.title, duplicatedTask.startTime, duplicatedTask.endTime, 20);
    try {
      document.dispatchEvent(new CustomEvent('task:history:updated'));
    } catch (e) {
      console.warn('CustomEvent dispatch failed for task:history:updated', e);
    }
  }

  return true;
}

// タスク復元
function restoreTask(id) {
  const trash = loadFromStorage(STORAGE_KEYS.TRASH, []);
  const index = trash.findIndex(task => task.id === id);

  if (index === -1) return false;

  const restoredTask = trash.splice(index, 1)[0];
  delete restoredTask.deletedAt;

  const tasks = getTasks();
  tasks.unshift(restoredTask);

  saveToStorage(STORAGE_KEYS.TRASH, trash);
  saveTasks(tasks);
  return true;
}

// ゴミ箱から完全削除
function permanentDelete(id) {
  const trash = loadFromStorage(STORAGE_KEYS.TRASH, []);
  const filtered = trash.filter(task => task.id !== id);
  saveToStorage(STORAGE_KEYS.TRASH, filtered);
  return true;
}

// タスクを棚上げ
function shelveTask(id) {
  const tasks = getTasks();
  const index = tasks.findIndex(task => task.id === id);

  if (index === -1) return false;

  const shelvedTask = tasks.splice(index, 1)[0];

  // 棚上げリストに追加
  const shelved = loadFromStorage(STORAGE_KEYS.SHELVED, []);
  shelved.unshift({
    ...shelvedTask,
    shelvedAt: new Date().toISOString()
  });
  saveToStorage(STORAGE_KEYS.SHELVED, shelved);

  saveTasks(tasks);
  return true;
}

// 棚上げから復帰
function unshelveTask(id) {
  const shelved = loadFromStorage(STORAGE_KEYS.SHELVED, []);
  const index = shelved.findIndex(task => task.id === id);

  if (index === -1) return false;

  const restoredTask = shelved.splice(index, 1)[0];
  delete restoredTask.shelvedAt;

  const tasks = getTasks();
  tasks.unshift(restoredTask);

  saveToStorage(STORAGE_KEYS.SHELVED, shelved);
  saveTasks(tasks);
  return true;
}

// ゴミ箱クリーンアップ（30日以上経過したタスクを削除）
function cleanupTrash() {
  const trash = loadFromStorage(STORAGE_KEYS.TRASH, []);
  const now = new Date();
  const cutoffDate = new Date(now.getTime() - TRASH_RETENTION_DAYS * 24 * 60 * 60 * 1000);

  const filtered = trash.filter(task => {
    return new Date(task.deletedAt) > cutoffDate;
  });

  saveToStorage(STORAGE_KEYS.TRASH, filtered);
}

// 完了/未完了切り替え
function toggleTaskCompletion(id) {
  const task = getTaskById(id);
  if (!task) return;

  // タイマー実行中の場合は停止
  if (task.isTimerRunning) {
    stopTimer(id);
  }

  const wasCompleted = task.isCompleted;
  updateTask(id, { isCompleted: !task.isCompleted });

  // アニメーション付きで再レンダリング
  const taskElement = document.querySelector(`[data-task-id="${id}"]`);
  if (taskElement && !wasCompleted) {
    // 完了にする場合のアニメーション
    taskElement.style.transition = 'all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
    taskElement.style.opacity = '0.5';
    taskElement.style.transform = 'scale(0.98)';
    setTimeout(() => {
      renderTasks();
      // 完了後に「元に戻す」ボタンを表示
      showUndoButton(id, task.title);
    }, 400);
  } else {
    renderTasks();
  }
}

// 元に戻すボタンを表示
function showUndoButton(taskId, taskTitle) {
  // 既存の元に戻すボタンを削除
  const existingUndo = document.querySelector('.undo-toast');
  if (existingUndo) {
    existingUndo.remove();
  }

  // 元に戻すトーストを作成
  const toast = document.createElement('div');
  toast.className = 'undo-toast';
  toast.innerHTML = `
    <div class="undo-toast-content">
      <span class="undo-toast-text">「${taskTitle}」を完了しました</span>
      <button class="undo-btn">元に戻す</button>
    </div>
  `;

  document.body.appendChild(toast);

  // ボタンクリックイベント
  const undoBtn = toast.querySelector('.undo-btn');
  undoBtn.addEventListener('click', () => {
    toggleTaskCompletion(taskId);
    toast.remove();
  });

  // アニメーション表示
  setTimeout(() => {
    toast.classList.add('show');
  }, 10);

  // 5秒後に自動的に非表示
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => {
      toast.remove();
    }, 300);
  }, 5000);
}

// ========================================
// チュートリアル
// ========================================
function initTutorial() {
  const tasks = getTasks();

  // 既にタスクがある場合はチュートリアルをスキップ
  if (tasks.length > 0) return;

  const tutorialTasks = [
    {
      title: 'nowtaskへようこそ！',
      memo: 'このアプリでタスクを管理しましょう。\nまずはこのチュートリアルを進めてください。'
    },
    {
      title: 'タスクをタップして詳細を確認',
      memo: 'タスクをクリックすると、詳細を編集できます。'
    },
    {
      title: 'チェックボックスで完了/未完了を切り替え',
      memo: '完了したタスクは「完了済み」タブで確認できます。'
    },
    {
      title: '期限を設定してみよう',
      memo: 'タスクに期限を設定すると、期限切れの場合は赤く表示されます。',
      dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()
    },
    {
      title: 'タスクを削除してみよう',
      memo: 'タスクを開いて削除ボタンを押すと、ゴミ箱に移動します。'
    },
    {
      title: '右下の＋ボタンで新規タスク作成',
      memo: 'チュートリアルを完了したら、自分のタスクを作成してみましょう！'
    }
  ];

  tutorialTasks.forEach((taskData, index) => {
    createTask(
      taskData.title,
      taskData.memo,
      taskData.dueDate || null,
      null,
      true
    );
  });
}

// ========================================
// タイマー機能
// ========================================

// タイマー開始
function startTimer(taskId) {
  const task = getTaskById(taskId);
  if (!task || task.isTimerRunning) return false;

  updateTask(taskId, {
    isTimerRunning: true,
    timerStartTime: new Date().toISOString()
  });

  return true;
}

// タイマー停止
function stopTimer(taskId) {
  const task = getTaskById(taskId);
  if (!task || !task.isTimerRunning) return false;

  const startTime = new Date(task.timerStartTime);
  const now = new Date();
  const elapsedSeconds = Math.floor((now - startTime) / 1000);

  updateTask(taskId, {
    isTimerRunning: false,
    timerStartTime: null,
    totalTime: task.totalTime + elapsedSeconds
  });

  return true;
}

// タスク時間記録開始（render.jsから呼び出し用）
function startTaskTimer(taskId) {
  return startTimer(taskId);
}

// タスク時間記録停止（render.jsから呼び出し用）
function stopTaskTimer(taskId) {
  return stopTimer(taskId);
}

// タイマー表示更新
function updateTimerDisplay(taskId) {
  const task = getTaskById(taskId);
  if (!task) return;

  let displayTime = task.totalTime;

  if (task.isTimerRunning && task.timerStartTime) {
    const startTime = new Date(task.timerStartTime);
    const now = new Date();
    const elapsedSeconds = Math.floor((now - startTime) / 1000);
    displayTime = task.totalTime + elapsedSeconds;
  }

  const timerDisplay = document.getElementById('timer-display');
  if (timerDisplay) {
    timerDisplay.textContent = formatTime(displayTime);
  }

  // タイマーボタンの状態更新
  const timerBtn = document.getElementById('timer-toggle-btn');
  if (timerBtn) {
    if (task.isTimerRunning) {
      timerBtn.textContent = '停止';
      timerBtn.classList.add('running');
    } else {
      timerBtn.textContent = '開始';
      timerBtn.classList.remove('running');
    }
  }
}

// ========================================
// デイリールーティン
// ========================================

// ルーティン設定取得
function getRoutines() {
  return loadFromStorage(STORAGE_KEYS.ROUTINES, []);
}

// ルーティン設定保存
function saveRoutines(routines) {
  return saveToStorage(STORAGE_KEYS.ROUTINES, routines);
}

// ルーティンタスクを作成（複数日対応）
// 期日なしの場合: 過去7日 + 今日 + 未来14日（計22日分）
// 期間設定の場合: 開始日から終了日までの全日
function createRoutineTasks() {
  const routines = getRoutines();

  // 配列でない場合（旧形式）はスキップ
  if (!Array.isArray(routines)) {
    console.warn('Routines is not an array, skipping routine task creation');
    return;
  }

  routines.forEach((routine) => {
    if (!routine || !routine.name || !routine.duration) return;

    // 期間設定を取得（デフォルトは期日なし）
    const dateRange = routine.dateRange || { type: 'none' };
    let dates = [];

    if (dateRange.type === 'period' && dateRange.startDate && dateRange.endDate) {
      // 期間設定: 開始日から終了日までの全日
      const start = new Date(dateRange.startDate);
      const end = new Date(dateRange.endDate);
      start.setHours(0, 0, 0, 0);
      end.setHours(0, 0, 0, 0);

      for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
        dates.push(new Date(d));
      }
    } else {
      // 期日なし: 過去7日 + 今日 + 未来14日（計22日分）
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      for (let i = -7; i <= 14; i++) {
        const date = new Date(today);
        date.setDate(date.getDate() + i);
        dates.push(date);
      }
    }

    // 各日付に対してルーティンタスクを作成
    dates.forEach(targetDate => {
      createRoutineTaskForDate(routine, targetDate);
    });
  });
}

// 指定日のルーティンタスクを作成（内部関数）
function createRoutineTaskForDate(routine, targetDate) {
  const tasks = getTasks();
  const trash = loadFromStorage(STORAGE_KEYS.TRASH, []);
  const target = new Date(targetDate);
  target.setHours(0, 0, 0, 0);

  // 対象日のこのルーティンタスクが既に存在するかチェック（完了・未完了、ゴミ箱も含む）
  const existsInTasks = tasks.some(task => {
    if (!task.isRoutine || task.routineId !== routine.id) return false;
    if (!task.dueDate) return false;
    const taskDueDate = new Date(task.dueDate);
    taskDueDate.setHours(0, 0, 0, 0);
    return taskDueDate.getTime() === target.getTime();
  });

  const existsInTrash = trash.some(task => {
    if (!task.isRoutine || task.routineId !== routine.id) return false;
    if (!task.dueDate) return false;
    const taskDueDate = new Date(task.dueDate);
    taskDueDate.setHours(0, 0, 0, 0);
    return taskDueDate.getTime() === target.getTime();
  });

  // タスクリストまたはゴミ箱に既に存在する場合はスキップ
  if (existsInTasks || existsInTrash) return;

  // ルーティンタスクを作成
  const targetISO = new Date(target.getTime() - target.getTimezoneOffset() * 60000).toISOString();

  const task = {
    id: generateUUID(),
    title: routine.name,
    memo: '',
    dueDate: targetISO, // 対象日の日付を自動設定
    isCompleted: false,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    parentId: null,
    isTutorial: false,
    totalTime: 0,
    isTimerRunning: false,
    timerStartTime: null,
    duration: routine.duration,
    startTime: routine.startTime || null, // ルーティンの開始時刻
    endTime: routine.endTime || null, // ルーティンの終了時刻
    urgent: routine.urgent || false, // ルーティンの緊急フラグ
    priority: routine.priority || '', // ルーティンの優先順位
    isRoutine: true,
    routineId: routine.id
  };

  const allTasks = getTasks();
  allTasks.unshift(task);
  saveTasks(allTasks);
}

// 後方互換性のため、旧関数名も残す
function createDailyRoutineTasks(targetDate) {
  if (targetDate) {
    // 特定の日付が指定された場合は、その日だけ作成
    const routines = getRoutines();
    if (!Array.isArray(routines)) return;
    routines.forEach(routine => {
      if (routine && routine.name && routine.duration) {
        createRoutineTaskForDate(routine, targetDate);
      }
    });
  } else {
    // 日付未指定の場合は、新しいロジックを使用
    createRoutineTasks();
  }
}

// ルーティン更新時に既存タスクに変更を反映
function updateRoutineTasks(routine) {
  if (!routine || !routine.id) return;

  const tasks = getTasks();
  let updated = false;

  tasks.forEach((task, index) => {
    // このルーティンに属する未完了タスクのみ更新
    if (task.isRoutine && task.routineId === routine.id && !task.isCompleted) {
      tasks[index] = {
        ...task,
        title: routine.name,
        duration: routine.duration,
        startTime: routine.startTime || null,
        endTime: routine.endTime || null,
        urgent: routine.urgent || false,
        priority: routine.priority || '',
        updatedAt: new Date().toISOString()
      };
      updated = true;
    }
  });

  if (updated) {
    saveTasks(tasks);
  }
}
```

### templates.js

```javascript
// ========================================
// テンプレート管理機能
// ========================================

/**
 * テンプレート一覧を取得
 */
function getTemplates() {
  return loadFromStorage(STORAGE_KEYS.TEMPLATES, []);
}

/**
 * テンプレートを保存
 */
function saveTemplates(templates) {
  return saveToStorage(STORAGE_KEYS.TEMPLATES, templates);
}

/**
 * テンプレートを追加
 */
function addTemplate(name, duration, startTime, endTime, memo) {
  const templates = getTemplates();

  const newTemplate = {
    id: generateUUID(),
    name: name || '',
    duration: duration || null,
    startTime: startTime || null,
    endTime: endTime || null,
    memo: memo || '',
    createdAt: new Date().toISOString()
  };

  templates.push(newTemplate);
  saveTemplates(templates);
  return newTemplate;
}

/**
 * テンプレートを削除
 */
function deleteTemplate(templateId) {
  const templates = getTemplates();
  const filtered = templates.filter(t => t.id !== templateId);
  saveTemplates(filtered);
}

/**
 * テンプレート選択モーダルを開く
 */
function openTemplateModal() {
  const modal = document.getElementById('template-modal');
  if (!modal) return;

  renderTemplatesList();
  modal.style.display = 'flex';
  modal.classList.add('show');
}

/**
 * テンプレート選択モーダルを閉じる
 */
function closeTemplateModal() {
  const modal = document.getElementById('template-modal');
  if (!modal) return;

  modal.style.display = 'none';
  modal.classList.remove('show');
}

/**
 * テンプレート一覧を描画
 */
function renderTemplatesList() {
  const container = document.getElementById('templates-list');
  if (!container) return;

  const templates = getTemplates();
  container.innerHTML = '';

  if (templates.length === 0) {
    container.innerHTML = '<p style="text-align: center; color: #999; padding: 40px 20px;">テンプレートがありません<br>タスク作成画面で入力後、「現在の入力内容をテンプレートとして保存」ボタンを押してください</p>';
    return;
  }

  templates.forEach(template => {
    const item = createTemplateItem(template);
    container.appendChild(item);
  });
}

/**
 * テンプレートアイテムを作成
 */
function createTemplateItem(template) {
  const item = document.createElement('div');
  item.className = 'template-item';

  const info = document.createElement('div');
  info.className = 'template-info';

  const name = document.createElement('div');
  name.className = 'template-name';
  name.textContent = template.name;

  const details = document.createElement('div');
  details.className = 'template-details';

  const detailsArr = [];
  if (template.startTime) {
    detailsArr.push(`開始: ${template.startTime.substring(0, 5)}`);
  }
  if (template.endTime) {
    detailsArr.push(`終了: ${template.endTime.substring(0, 5)}`);
  }
  if (template.duration) {
    const hours = Math.floor(template.duration / 60);
    const minutes = template.duration % 60;
    if (hours > 0) {
      detailsArr.push(`所要: ${hours}時間${minutes > 0 ? minutes + '分' : ''}`);
    } else {
      detailsArr.push(`所要: ${minutes}分`);
    }
  }
  details.textContent = detailsArr.join(' / ') || '時間未設定';

  info.appendChild(name);
  info.appendChild(details);

  const actions = document.createElement('div');
  actions.className = 'template-actions';

  // 使用ボタン
  const useBtn = document.createElement('button');
  useBtn.className = 'template-use-btn';
  useBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path></svg>';
  useBtn.title = 'このテンプレートを使用';
  useBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    applyTemplate(template);
  });

  // 削除ボタン
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'template-delete-btn';
  deleteBtn.innerHTML = '×';
  deleteBtn.title = 'テンプレートを削除';
  deleteBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    if (confirm(`「${template.name}」を削除しますか?`)) {
      deleteTemplate(template.id);
      renderTemplatesList();
    }
  });

  actions.appendChild(useBtn);
  actions.appendChild(deleteBtn);

  item.appendChild(info);
  item.appendChild(actions);

  // アイテムクリックでも適用
  item.addEventListener('click', () => {
    applyTemplate(template);
  });

  return item;
}

/**
 * テンプレートを適用
 */
function applyTemplate(template) {
  // タスク名
  const titleInput = document.getElementById('task-title');
  if (titleInput) {
    titleInput.value = template.name;
    // 文字数カウントを更新
    const charCount = document.getElementById('title-char-count');
    if (charCount) {
      charCount.textContent = template.name.length;
    }
    // 保存ボタンを有効化
    const saveBtn = document.getElementById('save-btn');
    if (saveBtn) {
      saveBtn.disabled = false;
    }
  }

  // メモ
  const memoInput = document.getElementById('task-memo');
  if (memoInput && template.memo) {
    memoInput.value = template.memo;
  }

  // 所要時間
  const durationSelect = document.getElementById('task-duration');
  if (durationSelect && template.duration) {
    durationSelect.value = template.duration;
  }

  // 開始時刻
  const startTimeInput = document.getElementById('task-start-time');
  if (startTimeInput && template.startTime) {
    startTimeInput.value = template.startTime;
  }

  // 終了時刻
  const endTimeInput = document.getElementById('task-end-time');
  if (endTimeInput && template.endTime) {
    endTimeInput.value = template.endTime;
  }

  // モーダルを閉じる
  closeTemplateModal();
}

/**
 * テンプレート入力フォームを表示
 */
function showTemplateInputForm() {
  const form = document.getElementById('template-input-form');
  const addBtn = document.getElementById('add-template-btn');

  if (form && addBtn) {
    form.style.display = 'block';
    addBtn.style.display = 'none';

    // フォームをクリア
    document.getElementById('template-name-input').value = '';
    document.getElementById('template-memo-input').value = '';
    document.getElementById('template-duration-input').value = '';
    document.getElementById('template-start-time-input').value = '';
    document.getElementById('template-end-time-input').value = '';
  }
}

/**
 * テンプレート入力フォームを非表示
 */
function hideTemplateInputForm() {
  const form = document.getElementById('template-input-form');
  const addBtn = document.getElementById('add-template-btn');

  if (form && addBtn) {
    form.style.display = 'none';
    addBtn.style.display = 'block';
  }
}

/**
 * テンプレート入力フォームから保存
 */
function saveTemplateFromForm() {
  const nameInput = document.getElementById('template-name-input');
  const memoInput = document.getElementById('template-memo-input');
  const durationSelect = document.getElementById('template-duration-input');
  const startTimeInput = document.getElementById('template-start-time-input');
  const endTimeInput = document.getElementById('template-end-time-input');

  const name = nameInput ? nameInput.value.trim() : '';

  if (!name) {
    alert('タスク名を入力してください');
    return;
  }

  const memo = memoInput ? memoInput.value.trim() : '';
  const duration = durationSelect ? parseInt(durationSelect.value) || null : null;
  const startTime = startTimeInput ? startTimeInput.value : null;
  const endTime = endTimeInput ? endTimeInput.value : null;

  addTemplate(name, duration, startTime, endTime, memo);
  hideTemplateInputForm();
  renderTemplatesList();

  alert(`「${name}」をテンプレートとして保存しました`);
}
```

### ui-main.js

```javascript
// ========================================
// メイン初期化ファイル
// ========================================

/**
 * UIの描画やイベントリスナーなど、アプリのメイン機能を起動する
 */
function startApp() {
  try {
    console.log("Starting main application...");

    // UI バージョン適用（新旧ヘッダー切り替え）
    applyUIVersion();

    // メインUIを表示
    showMainApp();

    // i18n 適用（存在しなければ暫定対策にフォールバック）
    try {
      if (typeof applyI18n === 'function') {
        applyI18n('ja');
      } else if (typeof applyI18nFix === 'function') {
        applyI18nFix();
      }
    } catch (e) {
      console.warn('i18n apply failed:', e);
    }

    // チュートリアル初期化
    initTutorial();

    // ゴミ箱クリーンアップ
    cleanupTrash();

    // デイリールーティンタスク作成
    try {
      createDailyRoutineTasks();
    } catch (e) {
      console.warn('Failed to create daily routine tasks:', e);
    }

    // イベントリスナー設定
    initEventListeners();

    // 初回レンダリング
    renderTasks();

    // 24時間ゲージの初期化と更新
    initGaugeDate();
    initGaugeSwipe();
    updateTimeGauge(currentGaugeDate);
    updateGaugeDateLabel();
    setInterval(() => {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const todayISO = formatDateISO(today);
      if (currentGaugeDate === todayISO) {
        updateTimeGauge(currentGaugeDate);
      }
    }, 60000); // 1分ごとに更新

    // 1秒ごとにタスクリストを更新（タイマー表示のため）
    setInterval(() => {
      const tasks = getTasks();
      const hasRunningTimer = tasks.some(t => t.isTimerRunning);
      if (hasRunningTimer) {
        renderTasks();
      }
    }, 1000);

    // スクロール時にヘッダーを隠す
    initHeaderScroll();

  } catch (e) {
    console.error('Initialization error:', e);
    alert('初期化エラーが発生しました。コンソールを確認してください。');
  }
}

/**
 * アプリケーションの全体的な初期化
 */
function init() {
    // auth.jsの認証機能を初期化
    // MainActivity.ktで既に匿名認証済みだが、auth.jsがログイン状態をチェックして適切にアプリを起動する
    initAuth();

    // 検索・フィルター・ソート機能を初期化
    if (typeof window.searchFilter !== 'undefined' && typeof window.searchFilter.init === 'function') {
        window.searchFilter.init();
    }
}

// ========================================
// ヘッダーメニュー表示
// ========================================
function showHeaderMenu(event) {
  // 既存のメニューを削除
  const existingMenu = document.querySelector('.header-dropdown-menu');
  if (existingMenu) {
    existingMenu.remove();
    return; // トグル動作
  }

  // メニューを作成
  const menu = document.createElement('div');
  menu.className = 'task-context-menu header-dropdown-menu';
  menu.style.position = 'fixed';

  // ボタンの位置を基準に配置
  const rect = event.target.closest('button').getBoundingClientRect();
  menu.style.top = `${rect.bottom + 5}px`;
  menu.style.right = `10px`;

  // 検索・絞り込み
  const searchFilterItem = document.createElement('div');
  searchFilterItem.className = 'menu-item';
  searchFilterItem.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:8px; display:inline-block; vertical-align:middle;"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path></svg> 検索・絞り込み';
  searchFilterItem.addEventListener('click', () => {
    if (typeof openSearchFilterModal === 'function') {
      openSearchFilterModal();
    }
    menu.remove();
  });
  menu.appendChild(searchFilterItem);

  // X共有
  const shareItem = document.createElement('div');
  shareItem.className = 'menu-item';
  shareItem.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:8px; display:inline-block; vertical-align:middle;"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line></svg> X共有';
  shareItem.addEventListener('click', () => {
    if (typeof generateAndShareImage === 'function') {
      generateAndShareImage();
    }
    menu.remove();
  });
  menu.appendChild(shareItem);

  // 分析
  const analyticsItem = document.createElement('div');
  analyticsItem.className = 'menu-item';
  analyticsItem.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:8px; display:inline-block; vertical-align:middle;"><rect x="3" y="13" width="4" height="8"></rect><rect x="10" y="8" width="4" height="13"></rect><rect x="17" y="3" width="4" height="18"></rect></svg> 分析';
  analyticsItem.addEventListener('click', () => {
    if (typeof openAnalyticsModal === 'function') {
      openAnalyticsModal();
    }
    menu.remove();
  });
  menu.appendChild(analyticsItem);

  document.body.appendChild(menu);

  // メニュー外をクリックで閉じる
  setTimeout(() => {
    const closeHandler = (e) => {
      if (!menu.contains(e.target) && !event.target.closest('button').contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeHandler);
        document.removeEventListener('touchstart', closeHandler);
      }
    };
    document.addEventListener('click', closeHandler);
    document.addEventListener('touchstart', closeHandler);
  }, 0);
}

// ========================================
// UI バージョン切り替え機能
// ========================================
function toggleUIVersion(version) {
  localStorage.setItem('ui-version', version);
  applyUIVersion();
}

function isNewUIEnabled() {
  return (localStorage.getItem('ui-version') || 'new') === 'new';
}

function applyUIVersion() {
  const version = localStorage.getItem('ui-version') || 'new';
  const oldHeader = document.getElementById('old-header');
  const newHeader = document.getElementById('new-header');
  const oldGaugeContainer = document.getElementById('old-time-gauge-container');
  const newGaugeContainer = document.getElementById('new-time-gauge-container');
  const oldBulkSelect = document.getElementById('old-bulk-select-button-container');
  const newBulkSelect = document.getElementById('new-bulk-select-button-container');

  if (version === 'new') {
    // 新ヘッダーを表示
    if (oldHeader) oldHeader.style.display = 'none';
    if (newHeader) newHeader.style.display = 'flex';

    // 新ゲージセクション全体を表示
    if (oldGaugeContainer) oldGaugeContainer.style.display = 'none';
    if (newGaugeContainer) newGaugeContainer.style.display = 'block';

    // 新複数選択ボタンを表示
    if (oldBulkSelect) oldBulkSelect.style.display = 'none';
    if (newBulkSelect) newBulkSelect.style.display = 'flex';

    // 新ゲージを初期化・レンダリング
    if (typeof renderNewGauge === 'function') {
      renderNewGauge(currentGaugeDate);
    }
  } else {
    // 旧ヘッダーを表示
    if (oldHeader) oldHeader.style.display = 'flex';
    if (newHeader) newHeader.style.display = 'none';

    // 旧ゲージセクション全体を表示
    if (oldGaugeContainer) oldGaugeContainer.style.display = 'block';
    if (newGaugeContainer) newGaugeContainer.style.display = 'none';

    // 旧複数選択ボタンを表示
    if (oldBulkSelect) oldBulkSelect.style.display = 'flex';
    if (newBulkSelect) newBulkSelect.style.display = 'none';
  }

  console.log(`UI Version applied: ${version}`);
}

// ========================================
// 文字化け暫定対策（主要UIの文言を上書き）
// ========================================
function setText(selector, text) {
  const el = document.querySelector(selector);
  if (el) el.textContent = text;
}

function setButtonText(selector, text) {
  const el = document.querySelector(selector);
  if (el) el.innerText = text;
}

function applyI18nFix() {
  // 設定モーダル タイトル/ボタン
  setText('#settings-modal .modal-header h2', '設定');
  setButtonText('#save-settings-btn', '保存');

  // 設定モーダル セクション見出し（登場順）
  const sectionTitles = document.querySelectorAll('#settings-modal .settings-section-title');
  if (sectionTitles && sectionTitles.length) {
    if (sectionTitles[0]) sectionTitles[0].textContent = '🎨 表示設定';
    if (sectionTitles[1]) sectionTitles[1].textContent = '🔔 通知設定';
    if (sectionTitles[2]) sectionTitles[2].textContent = '⏱ ルーチン';
    if (sectionTitles[3]) sectionTitles[3].textContent = '⚡ クイックアクション';
  }

  // 完了セクション
  setText('#completed-section .toggle-text', '完了済み');

  // ログインモーダル
  setText('#login-modal #login-modal-title', 'ログイン');
  setButtonText('#google-login-btn', 'Googleでログイン');
  setButtonText('#continue-anonymous-btn', '匿名のまま使い続ける');
  setButtonText('#logout-btn', 'ログアウト');

  // アカウント情報ラベル
  const labels = document.querySelectorAll('#account-info-section .form-group label');
  if (labels && labels.length) {
    if (labels[0]) labels[0].textContent = '表示名';
    if (labels[1]) labels[1].textContent = 'メールアドレス';
    if (labels[2]) labels[2].textContent = 'ステータス';
  }

  // ゲージのナビボタン（前日/翌日）
  const prevBtn = document.getElementById('gauge-prev-btn');
  if (prevBtn) {
    prevBtn.setAttribute('aria-label', '前の日に移動');
    prevBtn.setAttribute('title', '前の日に移動');
  }
  const nextBtn = document.getElementById('gauge-next-btn');
  if (nextBtn) {
    nextBtn.setAttribute('aria-label', '次の日に移動');
    nextBtn.setAttribute('title', '次の日に移動');
  }
}

// ========================================
// ヘッダースクロール制御
// ========================================
function initHeaderScroll() {
  const header = document.querySelector('.header');
  const version = localStorage.getItem('ui-version') || 'new';
  const activeHeader = version === 'new' ? document.getElementById('new-header') : document.getElementById('old-header');

  let lastScrollTop = 0;
  let isScrolling = false;
  let scrollTimeout;

  window.addEventListener('scroll', () => {
    const currentScroll = window.pageYOffset || document.documentElement.scrollTop;

    clearTimeout(scrollTimeout);
    isScrolling = true;

    if (currentScroll > lastScrollTop && currentScroll > 100) {
      if (activeHeader) activeHeader.classList.add('header-hidden');
    } else if (currentScroll < lastScrollTop) {
      if (activeHeader) activeHeader.classList.remove('header-hidden');
    }

    if (currentScroll <= 0) {
      if (activeHeader) activeHeader.classList.remove('header-hidden');
    }

    lastScrollTop = currentScroll <= 0 ? 0 : currentScroll;

    scrollTimeout = setTimeout(() => {
      isScrolling = false;
    }, 200);
  }, { passive: true });
}

// DOMロード後に初期化実行
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
```

---

**End of Document**

Generated by PowerShell script
Total files processed:
- HTML: 1 file
- CSS: 29 files
- JavaScript: 47 files
